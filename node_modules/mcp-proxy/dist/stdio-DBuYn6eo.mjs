import { createRequire } from "node:module";
import { randomUUID } from "node:crypto";
import { URL as URL$1 } from "node:url";
import http from "http";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i$3 = 0, n = keys.length, key$1; i$3 < n; i$3++) {
			key$1 = keys[i$3];
			if (!__hasOwnProp.call(to, key$1) && key$1 !== except) {
				__defProp(to, key$1, {
					get: ((k) => from[k]).bind(null, key$1),
					enumerable: !(desc = __getOwnPropDesc(from, key$1)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region src/authentication.ts
var AuthenticationMiddleware = class {
	constructor(config$1 = {}) {
		this.config = config$1;
	}
	getScopeChallengeResponse(requiredScopes, errorDescription, requestId) {
		const headers = { "Content-Type": "application/json" };
		if (this.config.oauth?.protectedResource?.resource) {
			const parts = [
				"Bearer",
				"error=\"insufficient_scope\"",
				`scope="${requiredScopes.join(" ")}"`,
				`resource_metadata="${this.config.oauth.protectedResource.resource}/.well-known/oauth-protected-resource"`
			];
			if (errorDescription) {
				const escaped = errorDescription.replace(/"/g, "\\\"");
				parts.push(`error_description="${escaped}"`);
			}
			headers["WWW-Authenticate"] = parts.join(", ");
		}
		return {
			body: JSON.stringify({
				error: {
					code: -32001,
					data: {
						error: "insufficient_scope",
						required_scopes: requiredScopes
					},
					message: errorDescription || "Insufficient scope"
				},
				id: requestId ?? null,
				jsonrpc: "2.0"
			}),
			headers,
			statusCode: 403
		};
	}
	getUnauthorizedResponse(options) {
		const headers = { "Content-Type": "application/json" };
		if (this.config.oauth) {
			const params = [];
			if (this.config.oauth.realm) params.push(`realm="${this.config.oauth.realm}"`);
			if (this.config.oauth.protectedResource?.resource) params.push(`resource_metadata="${this.config.oauth.protectedResource.resource}/.well-known/oauth-protected-resource"`);
			const error$1 = options?.error || this.config.oauth.error || "invalid_token";
			params.push(`error="${error$1}"`);
			const escaped = (options?.error_description || this.config.oauth.error_description || "Unauthorized: Invalid or missing API key").replace(/"/g, "\\\"");
			params.push(`error_description="${escaped}"`);
			const error_uri = options?.error_uri || this.config.oauth.error_uri;
			if (error_uri) params.push(`error_uri="${error_uri}"`);
			const scope = options?.scope || this.config.oauth.scope;
			if (scope) params.push(`scope="${scope}"`);
			if (params.length > 0) headers["WWW-Authenticate"] = `Bearer ${params.join(", ")}`;
		}
		return {
			body: JSON.stringify({
				error: {
					code: 401,
					message: options?.error_description || "Unauthorized: Invalid or missing API key"
				},
				id: null,
				jsonrpc: "2.0"
			}),
			headers
		};
	}
	validateRequest(req) {
		if (!this.config.apiKey) return true;
		const apiKey = req.headers["x-api-key"];
		if (!apiKey || typeof apiKey !== "string") return false;
		return apiKey === this.config.apiKey;
	}
};

//#endregion
//#region src/InMemoryEventStore.ts
/**
* Simple in-memory implementation of the EventStore interface for resumability
* This is primarily intended for examples and testing, not for production use
* where a persistent storage solution would be more appropriate.
*/
var InMemoryEventStore = class {
	events = /* @__PURE__ */ new Map();
	lastTimestamp = 0;
	lastTimestampCounter = 0;
	/**
	* Replays events that occurred after a specific event ID
	* Implements EventStore.replayEventsAfter
	*/
	async replayEventsAfter(lastEventId, { send }) {
		if (!lastEventId || !this.events.has(lastEventId)) return "";
		const streamId = this.getStreamIdFromEventId(lastEventId);
		if (!streamId) return "";
		let foundLastEvent = false;
		const sortedEvents = [...this.events.entries()].sort((a, b) => a[0].localeCompare(b[0]));
		for (const [eventId, { message, streamId: eventStreamId }] of sortedEvents) {
			if (eventStreamId !== streamId) continue;
			if (eventId === lastEventId) {
				foundLastEvent = true;
				continue;
			}
			if (foundLastEvent) await send(eventId, message);
		}
		return streamId;
	}
	/**
	* Stores an event with a generated event ID
	* Implements EventStore.storeEvent
	*/
	async storeEvent(streamId, message) {
		const eventId = this.generateEventId(streamId);
		this.events.set(eventId, {
			message,
			streamId
		});
		return eventId;
	}
	/**
	* Generates a monotonic unique event ID in
	* `${streamId}_${timestamp}_${counter}_${random}` format.
	*/
	generateEventId(streamId) {
		const now = Date.now();
		if (now === this.lastTimestamp) this.lastTimestampCounter++;
		else {
			this.lastTimestampCounter = 0;
			this.lastTimestamp = now;
		}
		return `${streamId}_${now.toString()}_${this.lastTimestampCounter.toString(36).padStart(4, "0")}_${Math.random().toString(36).substring(2, 5)}`;
	}
	/**
	* Extracts the stream ID from an event ID
	*/
	getStreamIdFromEventId(eventId) {
		const parts = eventId.split("_");
		return parts.length > 0 ? parts[0] : "";
	}
};

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/core.js
/** A special constant with type `never` */
const NEVER = Object.freeze({ status: "aborted" });
function $constructor(name, initializer$2, params) {
	function init(inst, def$30) {
		var _a;
		Object.defineProperty(inst, "_zod", {
			value: inst._zod ?? {},
			enumerable: false
		});
		(_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
		inst._zod.traits.add(name);
		initializer$2(inst, def$30);
		for (const k in _$1.prototype) if (!(k in inst)) Object.defineProperty(inst, k, { value: _$1.prototype[k].bind(inst) });
		inst._zod.constr = _$1;
		inst._zod.def = def$30;
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name });
	function _$1(def$30) {
		var _a;
		const inst = params?.Parent ? new Definition() : this;
		init(inst, def$30);
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		for (const fn of inst._zod.deferred) fn();
		return inst;
	}
	Object.defineProperty(_$1, "init", { value: init });
	Object.defineProperty(_$1, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name);
	} });
	Object.defineProperty(_$1, "name", { value: name });
	return _$1;
}
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
const globalConfig = {};
function config(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/util.js
function getEnumValues(entries) {
	const numericValues = Object.values(entries).filter((v) => typeof v === "number");
	return Object.entries(entries).filter(([k, _$1]) => numericValues.indexOf(+k) === -1).map(([_$1, v]) => v);
}
function jsonStringifyReplacer(_$1, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	return { get value() {
		{
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function nullish(input) {
	return input === null || input === void 0;
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
function defineLazy(object$1, key$1, getter) {
	Object.defineProperty(object$1, key$1, {
		get() {
			{
				const value = getter();
				object$1[key$1] = value;
				return value;
			}
			throw new Error("cached value already set");
		},
		set(v) {
			Object.defineProperty(object$1, key$1, { value: v });
		},
		configurable: true
	});
}
function assignProp(target, prop, value) {
	Object.defineProperty(target, prop, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function esc(str$1) {
	return JSON.stringify(str$1);
}
const captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
	return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
	try {
		new Function("");
		return true;
	} catch (_$1) {
		return false;
	}
});
function isPlainObject$1(o) {
	if (isObject(o) === false) return false;
	const ctor = o.constructor;
	if (ctor === void 0) return true;
	const prot = ctor.prototype;
	if (isObject(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
	return true;
}
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
function escapeRegex(str$1) {
	return str$1.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def$30, params) {
	const cl = new inst._zod.constr(def$30 ?? inst._zod.def);
	if (!def$30 || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== void 0) {
		if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k) => {
		return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
	const newShape = {};
	const currDef = schema._zod.def;
	for (const key$1 in mask) {
		if (!(key$1 in currDef.shape)) throw new Error(`Unrecognized key: "${key$1}"`);
		if (!mask[key$1]) continue;
		newShape[key$1] = currDef.shape[key$1];
	}
	return clone(schema, {
		...schema._zod.def,
		shape: newShape,
		checks: []
	});
}
function omit(schema, mask) {
	const newShape = { ...schema._zod.def.shape };
	const currDef = schema._zod.def;
	for (const key$1 in mask) {
		if (!(key$1 in currDef.shape)) throw new Error(`Unrecognized key: "${key$1}"`);
		if (!mask[key$1]) continue;
		delete newShape[key$1];
	}
	return clone(schema, {
		...schema._zod.def,
		shape: newShape,
		checks: []
	});
}
function extend(schema, shape) {
	if (!isPlainObject$1(shape)) throw new Error("Invalid input to extend: expected a plain object");
	return clone(schema, {
		...schema._zod.def,
		get shape() {
			const _shape = {
				...schema._zod.def.shape,
				...shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		checks: []
	});
}
function merge(a, b) {
	return clone(a, {
		...a._zod.def,
		get shape() {
			const _shape = {
				...a._zod.def.shape,
				...b._zod.def.shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		catchall: b._zod.def.catchall,
		checks: []
	});
}
function partial(Class, schema, mask) {
	const oldShape = schema._zod.def.shape;
	const shape = { ...oldShape };
	if (mask) for (const key$1 in mask) {
		if (!(key$1 in oldShape)) throw new Error(`Unrecognized key: "${key$1}"`);
		if (!mask[key$1]) continue;
		shape[key$1] = Class ? new Class({
			type: "optional",
			innerType: oldShape[key$1]
		}) : oldShape[key$1];
	}
	else for (const key$1 in oldShape) shape[key$1] = Class ? new Class({
		type: "optional",
		innerType: oldShape[key$1]
	}) : oldShape[key$1];
	return clone(schema, {
		...schema._zod.def,
		shape,
		checks: []
	});
}
function required(Class, schema, mask) {
	const oldShape = schema._zod.def.shape;
	const shape = { ...oldShape };
	if (mask) for (const key$1 in mask) {
		if (!(key$1 in shape)) throw new Error(`Unrecognized key: "${key$1}"`);
		if (!mask[key$1]) continue;
		shape[key$1] = new Class({
			type: "nonoptional",
			innerType: oldShape[key$1]
		});
	}
	else for (const key$1 in oldShape) shape[key$1] = new Class({
		type: "nonoptional",
		innerType: oldShape[key$1]
	});
	return clone(schema, {
		...schema._zod.def,
		shape,
		checks: []
	});
}
function aborted(x, startIndex = 0) {
	for (let i$3 = startIndex; i$3 < x.issues.length; i$3++) if (x.issues[i$3]?.continue !== true) return true;
	return false;
}
function prefixIssues(path, issues) {
	return issues.map((iss) => {
		var _a;
		(_a = iss).path ?? (_a.path = []);
		iss.path.unshift(path);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config$1) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? "Invalid input";
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) delete full.input;
	return full;
}
function getLengthableOrigin(input) {
	if (Array.isArray(input)) return "array";
	if (typeof input === "string") return "string";
	return "unknown";
}
function issue(...args) {
	const [iss, input, inst] = args;
	if (typeof iss === "string") return {
		message: iss,
		code: "custom",
		input,
		inst
	};
	return { ...iss };
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/errors.js
const initializer$1 = (inst, def$30) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def$30,
		enumerable: false
	});
	Object.defineProperty(inst, "message", {
		get() {
			return JSON.stringify(def$30, jsonStringifyReplacer, 2);
		},
		enumerable: true
	});
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error$1, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = {};
	const formErrors = [];
	for (const sub of error$1.issues) if (sub.path.length > 0) {
		fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
		fieldErrors[sub.path[0]].push(mapper(sub));
	} else formErrors.push(mapper(sub));
	return {
		formErrors,
		fieldErrors
	};
}
function formatError(error$1, _mapper) {
	const mapper = _mapper || function(issue$1) {
		return issue$1.message;
	};
	const fieldErrors = { _errors: [] };
	const processError = (error$2) => {
		for (const issue$1 of error$2.issues) if (issue$1.code === "invalid_union" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }));
		else if (issue$1.code === "invalid_key") processError({ issues: issue$1.issues });
		else if (issue$1.code === "invalid_element") processError({ issues: issue$1.issues });
		else if (issue$1.path.length === 0) fieldErrors._errors.push(mapper(issue$1));
		else {
			let curr = fieldErrors;
			let i$3 = 0;
			while (i$3 < issue$1.path.length) {
				const el = issue$1.path[i$3];
				if (!(i$3 === issue$1.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
				else {
					curr[el] = curr[el] || { _errors: [] };
					curr[el]._errors.push(mapper(issue$1));
				}
				curr = curr[el];
				i$3++;
			}
		}
	};
	processError(error$1);
	return fieldErrors;
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/parse.js
const _parse = (_Err) => (schema, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$4 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse$2 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/regexes.js
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 4122 UUID.
*
* @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = (version$1) => {
	if (!version$1) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
	return /* @__PURE__ */ new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$1}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
	return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$2 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
	const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	return typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time$1(args) {
	return /* @__PURE__ */ new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
	const time$2 = timeSource({ precision: args.precision });
	const opts = ["Z"];
	if (args.local) opts.push("");
	if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
	const timeRegex = `${time$2}(?:${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
	const regex$1 = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return /* @__PURE__ */ new RegExp(`^${regex$1}$`);
};
const integer = /^\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?/i;
const boolean$1 = /true|false/i;
const _null$2 = /null/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/checks.js
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def$30) => {
	var _a;
	inst._zod ?? (inst._zod = {});
	inst._zod.def = def$30;
	(_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
	number: "number",
	bigint: "bigint",
	object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	const origin = numericOriginMap[typeof def$30.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def$30.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
		if (def$30.value < curr) if (def$30.inclusive) bag.maximum = def$30.value;
		else bag.exclusiveMaximum = def$30.value;
	});
	inst._zod.check = (payload) => {
		if (def$30.inclusive ? payload.value <= def$30.value : payload.value < def$30.value) return;
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def$30.value,
			input: payload.value,
			inclusive: def$30.inclusive,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	const origin = numericOriginMap[typeof def$30.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def$30.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
		if (def$30.value > curr) if (def$30.inclusive) bag.minimum = def$30.value;
		else bag.exclusiveMinimum = def$30.value;
	});
	inst._zod.check = (payload) => {
		if (def$30.inclusive ? payload.value >= def$30.value : payload.value > def$30.value) return;
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def$30.value,
			input: payload.value,
			inclusive: def$30.inclusive,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	inst._zod.onattach.push((inst$1) => {
		var _a;
		(_a = inst$1._zod.bag).multipleOf ?? (_a.multipleOf = def$30.value);
	});
	inst._zod.check = (payload) => {
		if (typeof payload.value !== typeof def$30.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
		if (typeof payload.value === "bigint" ? payload.value % def$30.value === BigInt(0) : floatSafeRemainder(payload.value, def$30.value) === 0) return;
		payload.issues.push({
			origin: typeof payload.value,
			code: "not_multiple_of",
			divisor: def$30.value,
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	def$30.format = def$30.format || "float64";
	const isInt = def$30.format?.includes("int");
	const origin = isInt ? "int" : "number";
	const [minimum, maximum] = NUMBER_FORMAT_RANGES[def$30.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def$30.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
		if (isInt) bag.pattern = integer;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (isInt) {
			if (!Number.isInteger(input)) {
				payload.issues.push({
					expected: origin,
					format: def$30.format,
					code: "invalid_type",
					input,
					inst
				});
				return;
			}
			if (!Number.isSafeInteger(input)) {
				if (input > 0) payload.issues.push({
					input,
					code: "too_big",
					maximum: Number.MAX_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					continue: !def$30.abort
				});
				else payload.issues.push({
					input,
					code: "too_small",
					minimum: Number.MIN_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					continue: !def$30.abort
				});
				return;
			}
		}
		if (input < minimum) payload.issues.push({
			origin: "number",
			input,
			code: "too_small",
			minimum,
			inclusive: true,
			inst,
			continue: !def$30.abort
		});
		if (input > maximum) payload.issues.push({
			origin: "number",
			input,
			code: "too_big",
			maximum,
			inst
		});
	};
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def$30) => {
	var _a;
	$ZodCheck.init(inst, def$30);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def$30.maximum < curr) inst$1._zod.bag.maximum = def$30.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length <= def$30.maximum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def$30.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def$30) => {
	var _a;
	$ZodCheck.init(inst, def$30);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def$30.minimum > curr) inst$1._zod.bag.minimum = def$30.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length >= def$30.minimum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def$30.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def$30) => {
	var _a;
	$ZodCheck.init(inst, def$30);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def$30.length;
		bag.maximum = def$30.length;
		bag.length = def$30.length;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length === def$30.length) return;
		const origin = getLengthableOrigin(input);
		const tooBig = length > def$30.length;
		payload.issues.push({
			origin,
			...tooBig ? {
				code: "too_big",
				maximum: def$30.length
			} : {
				code: "too_small",
				minimum: def$30.length
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def$30) => {
	var _a, _b;
	$ZodCheck.init(inst, def$30);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def$30.format;
		if (def$30.pattern) {
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(def$30.pattern);
		}
	});
	if (def$30.pattern) (_a = inst._zod).check ?? (_a.check = (payload) => {
		def$30.pattern.lastIndex = 0;
		if (def$30.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: def$30.format,
			input: payload.value,
			...def$30.pattern ? { pattern: def$30.pattern.toString() } : {},
			inst,
			continue: !def$30.abort
		});
	});
	else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def$30) => {
	$ZodCheckStringFormat.init(inst, def$30);
	inst._zod.check = (payload) => {
		def$30.pattern.lastIndex = 0;
		if (def$30.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "regex",
			input: payload.value,
			pattern: def$30.pattern.toString(),
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = lowercase);
	$ZodCheckStringFormat.init(inst, def$30);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = uppercase);
	$ZodCheckStringFormat.init(inst, def$30);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	const escapedRegex = escapeRegex(def$30.includes);
	const pattern = new RegExp(typeof def$30.position === "number" ? `^.{${def$30.position}}${escapedRegex}` : escapedRegex);
	def$30.pattern = pattern;
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.includes(def$30.includes, def$30.position)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "includes",
			includes: def$30.includes,
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	const pattern = /* @__PURE__ */ new RegExp(`^${escapeRegex(def$30.prefix)}.*`);
	def$30.pattern ?? (def$30.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.startsWith(def$30.prefix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "starts_with",
			prefix: def$30.prefix,
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	const pattern = /* @__PURE__ */ new RegExp(`.*${escapeRegex(def$30.suffix)}$`);
	def$30.pattern ?? (def$30.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.endsWith(def$30.suffix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "ends_with",
			suffix: def$30.suffix,
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	inst._zod.check = (payload) => {
		payload.value = def$30.tx(payload.value);
	};
});

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/doc.js
var Doc = class {
	constructor(args = []) {
		this.content = [];
		this.indent = 0;
		if (this) this.args = args;
	}
	indented(fn) {
		this.indent += 1;
		fn(this);
		this.indent -= 1;
	}
	write(arg) {
		if (typeof arg === "function") {
			arg(this, { execution: "sync" });
			arg(this, { execution: "async" });
			return;
		}
		const lines = arg.split("\n").filter((x) => x);
		const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
		const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
		for (const line$1 of dedented) this.content.push(line$1);
	}
	compile() {
		const F = Function;
		const args = this?.args;
		const lines = [...(this?.content ?? [``]).map((x) => `  ${x}`)];
		return new F(...args, lines.join("\n"));
	}
};

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/versions.js
const version = {
	major: 4,
	minor: 0,
	patch: 0
};

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/schemas.js
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def$30) => {
	var _a;
	inst ?? (inst = {});
	inst._zod.def = def$30;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
	for (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);
	if (checks.length === 0) {
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks$1, ctx) => {
			let isAborted = aborted(payload);
			let asyncResult;
			for (const ch of checks$1) {
				if (ch._zod.def.when) {
					if (!ch._zod.def.when(payload)) continue;
				} else if (isAborted) continue;
				const currLen = payload.issues.length;
				const _$1 = ch._zod.check(payload);
				if (_$1 instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
				if (asyncResult || _$1 instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
					await _$1;
					if (payload.issues.length === currLen) return;
					if (!isAborted) isAborted = aborted(payload, currLen);
				});
				else {
					if (payload.issues.length === currLen) continue;
					if (!isAborted) isAborted = aborted(payload, currLen);
				}
			}
			if (asyncResult) return asyncResult.then(() => {
				return payload;
			});
			return payload;
		};
		inst._zod.run = (payload, ctx) => {
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result$1) => runChecks(result$1, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	inst["~standard"] = {
		validate: (value) => {
			try {
				const r = safeParse$2(inst, value);
				return r.success ? { value: r.data } : { issues: r.error?.issues };
			} catch (_$1) {
				return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	};
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
	inst._zod.parse = (payload, _$1) => {
		if (def$30.coerce) try {
			payload.value = String(payload.value);
		} catch (_$2) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def$30) => {
	$ZodCheckStringFormat.init(inst, def$30);
	$ZodString.init(inst, def$30);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = guid);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def$30) => {
	if (def$30.version) {
		const v = {
			v1: 1,
			v2: 2,
			v3: 3,
			v4: 4,
			v5: 5,
			v6: 6,
			v7: 7,
			v8: 8
		}[def$30.version];
		if (v === void 0) throw new Error(`Invalid UUID version: "${def$30.version}"`);
		def$30.pattern ?? (def$30.pattern = uuid(v));
	} else def$30.pattern ?? (def$30.pattern = uuid());
	$ZodStringFormat.init(inst, def$30);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = email);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def$30) => {
	$ZodStringFormat.init(inst, def$30);
	inst._zod.check = (payload) => {
		try {
			const orig = payload.value;
			const url$1 = new URL(orig);
			const href = url$1.href;
			if (def$30.hostname) {
				def$30.hostname.lastIndex = 0;
				if (!def$30.hostname.test(url$1.hostname)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid hostname",
					pattern: hostname.source,
					input: payload.value,
					inst,
					continue: !def$30.abort
				});
			}
			if (def$30.protocol) {
				def$30.protocol.lastIndex = 0;
				if (!def$30.protocol.test(url$1.protocol.endsWith(":") ? url$1.protocol.slice(0, -1) : url$1.protocol)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid protocol",
					pattern: def$30.protocol.source,
					input: payload.value,
					inst,
					continue: !def$30.abort
				});
			}
			if (!orig.endsWith("/") && href.endsWith("/")) payload.value = href.slice(0, -1);
			else payload.value = href;
			return;
		} catch (_$1) {
			payload.issues.push({
				code: "invalid_format",
				format: "url",
				input: payload.value,
				inst,
				continue: !def$30.abort
			});
		}
	};
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = emoji());
	$ZodStringFormat.init(inst, def$30);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = nanoid);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = cuid);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = cuid2);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = ulid);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = xid);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = ksuid);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = datetime$1(def$30));
	$ZodStringFormat.init(inst, def$30);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = date$2);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = time$1(def$30));
	$ZodStringFormat.init(inst, def$30);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = duration$1);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = ipv4);
	$ZodStringFormat.init(inst, def$30);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = `ipv4`;
	});
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = ipv6);
	$ZodStringFormat.init(inst, def$30);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = `ipv6`;
	});
	inst._zod.check = (payload) => {
		try {
			new URL(`http://[${payload.value}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "ipv6",
				input: payload.value,
				inst,
				continue: !def$30.abort
			});
		}
	};
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = cidrv4);
	$ZodStringFormat.init(inst, def$30);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = cidrv6);
	$ZodStringFormat.init(inst, def$30);
	inst._zod.check = (payload) => {
		const [address, prefix] = payload.value.split("/");
		try {
			if (!prefix) throw new Error();
			const prefixNum = Number(prefix);
			if (`${prefixNum}` !== prefix) throw new Error();
			if (prefixNum < 0 || prefixNum > 128) throw new Error();
			new URL(`http://[${address}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "cidrv6",
				input: payload.value,
				inst,
				continue: !def$30.abort
			});
		}
	};
});
function isValidBase64(data) {
	if (data === "") return true;
	if (data.length % 4 !== 0) return false;
	try {
		atob(data);
		return true;
	} catch {
		return false;
	}
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = base64);
	$ZodStringFormat.init(inst, def$30);
	inst._zod.onattach.push((inst$1) => {
		inst$1._zod.bag.contentEncoding = "base64";
	});
	inst._zod.check = (payload) => {
		if (isValidBase64(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64",
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
function isValidBase64URL(data) {
	if (!base64url.test(data)) return false;
	const base64$1 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
	return isValidBase64(base64$1.padEnd(Math.ceil(base64$1.length / 4) * 4, "="));
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = base64url);
	$ZodStringFormat.init(inst, def$30);
	inst._zod.onattach.push((inst$1) => {
		inst$1._zod.bag.contentEncoding = "base64url";
	});
	inst._zod.check = (payload) => {
		if (isValidBase64URL(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64url",
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def$30) => {
	def$30.pattern ?? (def$30.pattern = e164);
	$ZodStringFormat.init(inst, def$30);
});
function isValidJWT(token, algorithm = null) {
	try {
		const tokensParts = token.split(".");
		if (tokensParts.length !== 3) return false;
		const [header] = tokensParts;
		if (!header) return false;
		const parsedHeader = JSON.parse(atob(header));
		if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
		if (!parsedHeader.alg) return false;
		if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
		return true;
	} catch {
		return false;
	}
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def$30) => {
	$ZodStringFormat.init(inst, def$30);
	inst._zod.check = (payload) => {
		if (isValidJWT(payload.value, def$30.alg)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "jwt",
			input: payload.value,
			inst,
			continue: !def$30.abort
		});
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def$30.coerce) try {
			payload.value = Number(payload.value);
		} catch (_$1) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def$30) => {
	$ZodCheckNumberFormat.init(inst, def$30);
	$ZodNumber.init(inst, def$30);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.pattern = boolean$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def$30.coerce) try {
			payload.value = Boolean(payload.value);
		} catch (_$1) {}
		const input = payload.value;
		if (typeof input === "boolean") return payload;
		payload.issues.push({
			expected: "boolean",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.pattern = _null$2;
	inst._zod.values = new Set([null]);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (input === null) return payload;
		payload.issues.push({
			expected: "null",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload, _ctx) => {
		payload.issues.push({
			expected: "never",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index) {
	if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
	final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i$3 = 0; i$3 < input.length; i$3++) {
			const item = input[i$3];
			const result = def$30.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i$3)));
			else handleArrayResult(result, payload, i$3);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleObjectResult(result, final, key$1) {
	if (result.issues.length) final.issues.push(...prefixIssues(key$1, result.issues));
	final.value[key$1] = result.value;
}
function handleOptionalObjectResult(result, final, key$1, input) {
	if (result.issues.length) if (input[key$1] === void 0) if (key$1 in input) final.value[key$1] = void 0;
	else final.value[key$1] = result.value;
	else final.issues.push(...prefixIssues(key$1, result.issues));
	else if (result.value === void 0) {
		if (key$1 in input) final.value[key$1] = void 0;
	} else final.value[key$1] = result.value;
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	const _normalized = cached(() => {
		const keys = Object.keys(def$30.shape);
		for (const k of keys) if (!(def$30.shape[k] instanceof $ZodType)) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
		const okeys = optionalKeys(def$30.shape);
		return {
			shape: def$30.shape,
			keys,
			keySet: new Set(keys),
			numKeys: keys.length,
			optionalKeys: new Set(okeys)
		};
	});
	defineLazy(inst._zod, "propValues", () => {
		const shape = def$30.shape;
		const propValues = {};
		for (const key$1 in shape) {
			const field = shape[key$1]._zod;
			if (field.values) {
				propValues[key$1] ?? (propValues[key$1] = /* @__PURE__ */ new Set());
				for (const v of field.values) propValues[key$1].add(v);
			}
		}
		return propValues;
	});
	const generateFastpass = (shape) => {
		const doc = new Doc([
			"shape",
			"payload",
			"ctx"
		]);
		const normalized = _normalized.value;
		const parseStr = (key$1) => {
			const k = esc(key$1);
			return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
		};
		doc.write(`const input = payload.value;`);
		const ids = Object.create(null);
		let counter = 0;
		for (const key$1 of normalized.keys) ids[key$1] = `key_${counter++}`;
		doc.write(`const newResult = {}`);
		for (const key$1 of normalized.keys) if (normalized.optionalKeys.has(key$1)) {
			const id = ids[key$1];
			doc.write(`const ${id} = ${parseStr(key$1)};`);
			const k = esc(key$1);
			doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
		} else {
			const id = ids[key$1];
			doc.write(`const ${id} = ${parseStr(key$1)};`);
			doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key$1)}, ...iss.path] : [${esc(key$1)}]
          })));`);
			doc.write(`newResult[${esc(key$1)}] = ${id}.value`);
		}
		doc.write(`payload.value = newResult;`);
		doc.write(`return payload;`);
		const fn = doc.compile();
		return (payload, ctx) => fn(shape, payload, ctx);
	};
	let fastpass;
	const isObject$1 = isObject;
	const jit = !globalConfig.jitless;
	const allowsEval$1 = allowsEval;
	const fastEnabled = jit && allowsEval$1.value;
	const catchall = def$30.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
			if (!fastpass) fastpass = generateFastpass(def$30.shape);
			payload = fastpass(payload, ctx);
		} else {
			payload.value = {};
			const shape = value.shape;
			for (const key$1 of value.keys) {
				const el = shape[key$1];
				const r = el._zod.run({
					value: input[key$1],
					issues: []
				}, ctx);
				const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
				if (r instanceof Promise) proms.push(r.then((r$1) => isOptional ? handleOptionalObjectResult(r$1, payload, key$1, input) : handleObjectResult(r$1, payload, key$1)));
				else if (isOptional) handleOptionalObjectResult(r, payload, key$1, input);
				else handleObjectResult(r, payload, key$1);
			}
		}
		if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
		const unrecognized = [];
		const keySet = value.keySet;
		const _catchall = catchall._zod;
		const t = _catchall.def.type;
		for (const key$1 of Object.keys(input)) {
			if (keySet.has(key$1)) continue;
			if (t === "never") {
				unrecognized.push(key$1);
				continue;
			}
			const r = _catchall.run({
				value: input[key$1],
				issues: []
			}, ctx);
			if (r instanceof Promise) proms.push(r.then((r$1) => handleObjectResult(r$1, payload, key$1)));
			else handleObjectResult(r, payload, key$1);
		}
		if (unrecognized.length) payload.issues.push({
			code: "unrecognized_keys",
			keys: unrecognized,
			input,
			inst
		});
		if (!proms.length) return payload;
		return Promise.all(proms).then(() => {
			return payload;
		});
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) if (result.issues.length === 0) {
		final.value = result.value;
		return final;
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	defineLazy(inst._zod, "optin", () => def$30.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "optout", () => def$30.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "values", () => {
		if (def$30.options.every((o) => o._zod.values)) return new Set(def$30.options.flatMap((option) => Array.from(option._zod.values)));
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def$30.options.every((o) => o._zod.pattern)) {
			const patterns = def$30.options.map((o) => o._zod.pattern);
			return /* @__PURE__ */ new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
	});
	inst._zod.parse = (payload, ctx) => {
		let async = false;
		const results = [];
		for (const option of def$30.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleUnionResults(results$1, payload, inst, ctx);
		});
	};
});
const $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def$30) => {
	$ZodUnion.init(inst, def$30);
	const _super = inst._zod.parse;
	defineLazy(inst._zod, "propValues", () => {
		const propValues = {};
		for (const option of def$30.options) {
			const pv = option._zod.propValues;
			if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index "${def$30.options.indexOf(option)}"`);
			for (const [k, v] of Object.entries(pv)) {
				if (!propValues[k]) propValues[k] = /* @__PURE__ */ new Set();
				for (const val of v) propValues[k].add(val);
			}
		}
		return propValues;
	});
	const disc = cached(() => {
		const opts = def$30.options;
		const map$1 = /* @__PURE__ */ new Map();
		for (const o of opts) {
			const values = o._zod.propValues[def$30.discriminator];
			if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index "${def$30.options.indexOf(o)}"`);
			for (const v of values) {
				if (map$1.has(v)) throw new Error(`Duplicate discriminator value "${String(v)}"`);
				map$1.set(v, o);
			}
		}
		return map$1;
	});
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isObject(input)) {
			payload.issues.push({
				code: "invalid_type",
				expected: "object",
				input,
				inst
			});
			return payload;
		}
		const opt = disc.value.get(input?.[def$30.discriminator]);
		if (opt) return opt._zod.run(payload, ctx);
		if (def$30.unionFallback) return _super(payload, ctx);
		payload.issues.push({
			code: "invalid_union",
			errors: [],
			note: "No matching discriminator",
			input,
			path: [def$30.discriminator],
			inst
		});
		return payload;
	};
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		const left = def$30.left._zod.run({
			value: input,
			issues: []
		}, ctx);
		const right = def$30.right._zod.run({
			value: input,
			issues: []
		}, ctx);
		if (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left$1, right$1]) => {
			return handleIntersectionResults(payload, left$1, right$1);
		});
		return handleIntersectionResults(payload, left, right);
	};
});
function mergeValues(a, b) {
	if (a === b) return {
		valid: true,
		data: a
	};
	if (a instanceof Date && b instanceof Date && +a === +b) return {
		valid: true,
		data: a
	};
	if (isPlainObject$1(a) && isPlainObject$1(b)) {
		const bKeys = Object.keys(b);
		const sharedKeys = Object.keys(a).filter((key$1) => bKeys.indexOf(key$1) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key$1 of sharedKeys) {
			const sharedValue = mergeValues(a[key$1], b[key$1]);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [key$1, ...sharedValue.mergeErrorPath]
			};
			newObj[key$1] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) return {
			valid: false,
			mergeErrorPath: []
		};
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
			};
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	}
	return {
		valid: false,
		mergeErrorPath: []
	};
}
function handleIntersectionResults(result, left, right) {
	if (left.issues.length) result.issues.push(...left.issues);
	if (right.issues.length) result.issues.push(...right.issues);
	if (aborted(result)) return result;
	const merged = mergeValues(left.value, right.value);
	if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
	result.value = merged.data;
	return result;
}
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isPlainObject$1(input)) {
			payload.issues.push({
				expected: "record",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		if (def$30.keyType._zod.values) {
			const values = def$30.keyType._zod.values;
			payload.value = {};
			for (const key$1 of values) if (typeof key$1 === "string" || typeof key$1 === "number" || typeof key$1 === "symbol") {
				const result = def$30.valueType._zod.run({
					value: input[key$1],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => {
					if (result$1.issues.length) payload.issues.push(...prefixIssues(key$1, result$1.issues));
					payload.value[key$1] = result$1.value;
				}));
				else {
					if (result.issues.length) payload.issues.push(...prefixIssues(key$1, result.issues));
					payload.value[key$1] = result.value;
				}
			}
			let unrecognized;
			for (const key$1 in input) if (!values.has(key$1)) {
				unrecognized = unrecognized ?? [];
				unrecognized.push(key$1);
			}
			if (unrecognized && unrecognized.length > 0) payload.issues.push({
				code: "unrecognized_keys",
				input,
				inst,
				keys: unrecognized
			});
		} else {
			payload.value = {};
			for (const key$1 of Reflect.ownKeys(input)) {
				if (key$1 === "__proto__") continue;
				const keyResult = def$30.keyType._zod.run({
					value: key$1,
					issues: []
				}, ctx);
				if (keyResult instanceof Promise) throw new Error("Async schemas not supported in object keys currently");
				if (keyResult.issues.length) {
					payload.issues.push({
						origin: "record",
						code: "invalid_key",
						issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
						input: key$1,
						path: [key$1],
						inst
					});
					payload.value[keyResult.value] = keyResult.value;
					continue;
				}
				const result = def$30.valueType._zod.run({
					value: input[key$1],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => {
					if (result$1.issues.length) payload.issues.push(...prefixIssues(key$1, result$1.issues));
					payload.value[keyResult.value] = result$1.value;
				}));
				else {
					if (result.issues.length) payload.issues.push(...prefixIssues(key$1, result.issues));
					payload.value[keyResult.value] = result.value;
				}
			}
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	const values = getEnumValues(def$30.entries);
	inst._zod.values = new Set(values);
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (inst._zod.values.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.values = new Set(def$30.values);
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${def$30.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (inst._zod.values.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values: def$30.values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload, _ctx) => {
		const _out = def$30.transform(payload.value, payload);
		if (_ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output) => {
			payload.value = output;
			return payload;
		});
		if (_out instanceof Promise) throw new $ZodAsyncError();
		payload.value = _out;
		return payload;
	};
});
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def$30.innerType._zod.values ? new Set([...def$30.innerType._zod.values, void 0]) : void 0;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def$30.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def$30.innerType._zod.optin === "optional") return def$30.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) return payload;
		return def$30.innerType._zod.run(payload, ctx);
	};
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	defineLazy(inst._zod, "optin", () => def$30.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def$30.innerType._zod.optout);
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def$30.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
	});
	defineLazy(inst._zod, "values", () => {
		return def$30.innerType._zod.values ? new Set([...def$30.innerType._zod.values, null]) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === null) return payload;
		return def$30.innerType._zod.run(payload, ctx);
	};
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def$30.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === void 0) {
			payload.value = def$30.defaultValue;
			/**
			* $ZodDefault always returns the default value immediately.
			* It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
			return payload;
		}
		const result = def$30.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleDefaultResult(result$1, def$30));
		return handleDefaultResult(result, def$30);
	};
});
function handleDefaultResult(payload, def$30) {
	if (payload.value === void 0) payload.value = def$30.defaultValue;
	return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def$30.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === void 0) payload.value = def$30.defaultValue;
		return def$30.innerType._zod.run(payload, ctx);
	};
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	defineLazy(inst._zod, "values", () => {
		const v = def$30.innerType._zod.values;
		return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		const result = def$30.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleNonOptionalResult(result$1, inst));
		return handleNonOptionalResult(result, inst);
	};
});
function handleNonOptionalResult(payload, inst) {
	if (!payload.issues.length && payload.value === void 0) payload.issues.push({
		code: "invalid_type",
		expected: "nonoptional",
		input: payload.value,
		inst
	});
	return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "optout", () => def$30.innerType._zod.optout);
	defineLazy(inst._zod, "values", () => def$30.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		const result = def$30.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => {
			payload.value = result$1.value;
			if (result$1.issues.length) {
				payload.value = def$30.catchValue({
					...payload,
					error: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
					input: payload.value
				});
				payload.issues = [];
			}
			return payload;
		});
		payload.value = result.value;
		if (result.issues.length) {
			payload.value = def$30.catchValue({
				...payload,
				error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
				input: payload.value
			});
			payload.issues = [];
		}
		return payload;
	};
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	defineLazy(inst._zod, "values", () => def$30.in._zod.values);
	defineLazy(inst._zod, "optin", () => def$30.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def$30.out._zod.optout);
	inst._zod.parse = (payload, ctx) => {
		const left = def$30.in._zod.run(payload, ctx);
		if (left instanceof Promise) return left.then((left$1) => handlePipeResult(left$1, def$30, ctx));
		return handlePipeResult(left, def$30, ctx);
	};
});
function handlePipeResult(left, def$30, ctx) {
	if (aborted(left)) return left;
	return def$30.out._zod.run({
		value: left.value,
		issues: left.issues
	}, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	defineLazy(inst._zod, "propValues", () => def$30.innerType._zod.propValues);
	defineLazy(inst._zod, "values", () => def$30.innerType._zod.values);
	defineLazy(inst._zod, "optin", () => def$30.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def$30.innerType._zod.optout);
	inst._zod.parse = (payload, ctx) => {
		const result = def$30.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then(handleReadonlyResult);
		return handleReadonlyResult(result);
	};
});
function handleReadonlyResult(payload) {
	payload.value = Object.freeze(payload.value);
	return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def$30) => {
	$ZodCheck.init(inst, def$30);
	$ZodType.init(inst, def$30);
	inst._zod.parse = (payload, _$1) => {
		return payload;
	};
	inst._zod.check = (payload) => {
		const input = payload.value;
		const r = def$30.fn(input);
		if (r instanceof Promise) return r.then((r$1) => handleRefineResult(r$1, payload, input, inst));
		handleRefineResult(r, payload, input, inst);
	};
});
function handleRefineResult(result, payload, input, inst) {
	if (!result) {
		const _iss = {
			code: "custom",
			input,
			inst,
			path: [...inst._zod.def.path ?? []],
			continue: !inst._zod.def.abort
		};
		if (inst._zod.def.params) _iss.params = inst._zod.def.params;
		payload.issues.push(issue(_iss));
	}
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/registries.js
var $ZodRegistry = class {
	constructor() {
		this._map = /* @__PURE__ */ new Map();
		this._idmap = /* @__PURE__ */ new Map();
	}
	add(schema, ..._meta) {
		const meta = _meta[0];
		this._map.set(schema, meta);
		if (meta && typeof meta === "object" && "id" in meta) {
			if (this._idmap.has(meta.id)) throw new Error(`ID ${meta.id} already exists in the registry`);
			this._idmap.set(meta.id, schema);
		}
		return this;
	}
	clear() {
		this._map = /* @__PURE__ */ new Map();
		this._idmap = /* @__PURE__ */ new Map();
		return this;
	}
	remove(schema) {
		const meta = this._map.get(schema);
		if (meta && typeof meta === "object" && "id" in meta) this._idmap.delete(meta.id);
		this._map.delete(schema);
		return this;
	}
	get(schema) {
		const p = schema._zod.parent;
		if (p) {
			const pm = { ...this.get(p) ?? {} };
			delete pm.id;
			return {
				...pm,
				...this._map.get(schema)
			};
		}
		return this._map.get(schema);
	}
	has(schema) {
		return this._map.has(schema);
	}
};
function registry() {
	return new $ZodRegistry();
}
const globalRegistry = /* @__PURE__ */ registry();

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/api.js
function _string(Class, params) {
	return new Class({
		type: "string",
		...normalizeParams(params)
	});
}
function _email(Class, params) {
	return new Class({
		type: "string",
		format: "email",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _guid(Class, params) {
	return new Class({
		type: "string",
		format: "guid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _uuid(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _uuidv4(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v4",
		...normalizeParams(params)
	});
}
function _uuidv6(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v6",
		...normalizeParams(params)
	});
}
function _uuidv7(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v7",
		...normalizeParams(params)
	});
}
function _url(Class, params) {
	return new Class({
		type: "string",
		format: "url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _emoji(Class, params) {
	return new Class({
		type: "string",
		format: "emoji",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _nanoid(Class, params) {
	return new Class({
		type: "string",
		format: "nanoid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cuid(Class, params) {
	return new Class({
		type: "string",
		format: "cuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cuid2(Class, params) {
	return new Class({
		type: "string",
		format: "cuid2",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ulid(Class, params) {
	return new Class({
		type: "string",
		format: "ulid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _xid(Class, params) {
	return new Class({
		type: "string",
		format: "xid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ksuid(Class, params) {
	return new Class({
		type: "string",
		format: "ksuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ipv4(Class, params) {
	return new Class({
		type: "string",
		format: "ipv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ipv6(Class, params) {
	return new Class({
		type: "string",
		format: "ipv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cidrv4(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cidrv6(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _base64(Class, params) {
	return new Class({
		type: "string",
		format: "base64",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _base64url(Class, params) {
	return new Class({
		type: "string",
		format: "base64url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _e164(Class, params) {
	return new Class({
		type: "string",
		format: "e164",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _jwt(Class, params) {
	return new Class({
		type: "string",
		format: "jwt",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _isoDateTime(Class, params) {
	return new Class({
		type: "string",
		format: "datetime",
		check: "string_format",
		offset: false,
		local: false,
		precision: null,
		...normalizeParams(params)
	});
}
function _isoDate(Class, params) {
	return new Class({
		type: "string",
		format: "date",
		check: "string_format",
		...normalizeParams(params)
	});
}
function _isoTime(Class, params) {
	return new Class({
		type: "string",
		format: "time",
		check: "string_format",
		precision: null,
		...normalizeParams(params)
	});
}
function _isoDuration(Class, params) {
	return new Class({
		type: "string",
		format: "duration",
		check: "string_format",
		...normalizeParams(params)
	});
}
function _number(Class, params) {
	return new Class({
		type: "number",
		checks: [],
		...normalizeParams(params)
	});
}
function _coercedNumber(Class, params) {
	return new Class({
		type: "number",
		coerce: true,
		checks: [],
		...normalizeParams(params)
	});
}
function _int(Class, params) {
	return new Class({
		type: "number",
		check: "number_format",
		abort: false,
		format: "safeint",
		...normalizeParams(params)
	});
}
function _boolean(Class, params) {
	return new Class({
		type: "boolean",
		...normalizeParams(params)
	});
}
function _null$1(Class, params) {
	return new Class({
		type: "null",
		...normalizeParams(params)
	});
}
function _any(Class) {
	return new Class({ type: "any" });
}
function _unknown(Class) {
	return new Class({ type: "unknown" });
}
function _never(Class, params) {
	return new Class({
		type: "never",
		...normalizeParams(params)
	});
}
function _lt(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
function _lte(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
function _gt(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
function _gte(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
function _multipleOf(value, params) {
	return new $ZodCheckMultipleOf({
		check: "multiple_of",
		...normalizeParams(params),
		value
	});
}
function _maxLength(maximum, params) {
	return new $ZodCheckMaxLength({
		check: "max_length",
		...normalizeParams(params),
		maximum
	});
}
function _minLength(minimum, params) {
	return new $ZodCheckMinLength({
		check: "min_length",
		...normalizeParams(params),
		minimum
	});
}
function _length(length, params) {
	return new $ZodCheckLengthEquals({
		check: "length_equals",
		...normalizeParams(params),
		length
	});
}
function _regex(pattern, params) {
	return new $ZodCheckRegex({
		check: "string_format",
		format: "regex",
		...normalizeParams(params),
		pattern
	});
}
function _lowercase(params) {
	return new $ZodCheckLowerCase({
		check: "string_format",
		format: "lowercase",
		...normalizeParams(params)
	});
}
function _uppercase(params) {
	return new $ZodCheckUpperCase({
		check: "string_format",
		format: "uppercase",
		...normalizeParams(params)
	});
}
function _includes(includes, params) {
	return new $ZodCheckIncludes({
		check: "string_format",
		format: "includes",
		...normalizeParams(params),
		includes
	});
}
function _startsWith(prefix, params) {
	return new $ZodCheckStartsWith({
		check: "string_format",
		format: "starts_with",
		...normalizeParams(params),
		prefix
	});
}
function _endsWith(suffix, params) {
	return new $ZodCheckEndsWith({
		check: "string_format",
		format: "ends_with",
		...normalizeParams(params),
		suffix
	});
}
function _overwrite(tx) {
	return new $ZodCheckOverwrite({
		check: "overwrite",
		tx
	});
}
function _normalize(form) {
	return _overwrite((input) => input.normalize(form));
}
function _trim() {
	return _overwrite((input) => input.trim());
}
function _toLowerCase() {
	return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
	return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
	return new Class({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
function _custom(Class, fn, _params) {
	const norm = normalizeParams(_params);
	norm.abort ?? (norm.abort = true);
	return new Class({
		type: "custom",
		check: "custom",
		fn,
		...norm
	});
}
function _refine(Class, fn, _params) {
	return new Class({
		type: "custom",
		check: "custom",
		fn,
		...normalizeParams(_params)
	});
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/iso.js
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def$30) => {
	$ZodISODateTime.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
function datetime(params) {
	return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def$30) => {
	$ZodISODate.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
function date$1(params) {
	return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def$30) => {
	$ZodISOTime.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
function time(params) {
	return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def$30) => {
	$ZodISODuration.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
function duration(params) {
	return _isoDuration(ZodISODuration, params);
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/errors.js
const initializer = (inst, issues) => {
	$ZodError.init(inst, issues);
	inst.name = "ZodError";
	Object.defineProperties(inst, {
		format: { value: (mapper) => formatError(inst, mapper) },
		flatten: { value: (mapper) => flattenError(inst, mapper) },
		addIssue: { value: (issue$1) => inst.issues.push(issue$1) },
		addIssues: { value: (issues$1) => inst.issues.push(...issues$1) },
		isEmpty: { get() {
			return inst.issues.length === 0;
		} }
	});
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/parse.js
const parse$3 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse$1 = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/schemas.js
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def$30) => {
	$ZodType.init(inst, def$30);
	inst.def = def$30;
	Object.defineProperty(inst, "_def", { value: def$30 });
	inst.check = (...checks) => {
		return inst.clone({
			...def$30,
			checks: [...def$30.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
				check: ch,
				def: { check: "custom" },
				onattach: []
			} } : ch)]
		});
	};
	inst.clone = (def$31, params) => clone(inst, def$31, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta) => {
		reg.add(inst, meta);
		return inst;
	});
	inst.parse = (data, params) => parse$3(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse$1(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
	inst.spa = inst.safeParseAsync;
	inst.refine = (check$1, params) => inst.check(refine(check$1, params));
	inst.superRefine = (refinement) => inst.check(superRefine(refinement));
	inst.overwrite = (fn) => inst.check(_overwrite(fn));
	inst.optional = () => optional(inst);
	inst.nullable = () => nullable(inst);
	inst.nullish = () => optional(nullable(inst));
	inst.nonoptional = (params) => nonoptional(inst, params);
	inst.array = () => array(inst);
	inst.or = (arg) => union([inst, arg]);
	inst.and = (arg) => intersection(inst, arg);
	inst.transform = (tx) => pipe(inst, transform(tx));
	inst.default = (def$31) => _default(inst, def$31);
	inst.prefault = (def$31) => prefault(inst, def$31);
	inst.catch = (params) => _catch(inst, params);
	inst.pipe = (target) => pipe(inst, target);
	inst.readonly = () => readonly(inst);
	inst.describe = (description) => {
		const cl = inst.clone();
		globalRegistry.add(cl, { description });
		return cl;
	};
	Object.defineProperty(inst, "description", {
		get() {
			return globalRegistry.get(inst)?.description;
		},
		configurable: true
	});
	inst.meta = (...args) => {
		if (args.length === 0) return globalRegistry.get(inst);
		const cl = inst.clone();
		globalRegistry.add(cl, args[0]);
		return cl;
	};
	inst.isOptional = () => inst.safeParse(void 0).success;
	inst.isNullable = () => inst.safeParse(null).success;
	return inst;
});
/** @internal */
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def$30) => {
	$ZodString.init(inst, def$30);
	ZodType.init(inst, def$30);
	const bag = inst._zod.bag;
	inst.format = bag.format ?? null;
	inst.minLength = bag.minimum ?? null;
	inst.maxLength = bag.maximum ?? null;
	inst.regex = (...args) => inst.check(_regex(...args));
	inst.includes = (...args) => inst.check(_includes(...args));
	inst.startsWith = (...args) => inst.check(_startsWith(...args));
	inst.endsWith = (...args) => inst.check(_endsWith(...args));
	inst.min = (...args) => inst.check(_minLength(...args));
	inst.max = (...args) => inst.check(_maxLength(...args));
	inst.length = (...args) => inst.check(_length(...args));
	inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
	inst.lowercase = (params) => inst.check(_lowercase(params));
	inst.uppercase = (params) => inst.check(_uppercase(params));
	inst.trim = () => inst.check(_trim());
	inst.normalize = (...args) => inst.check(_normalize(...args));
	inst.toLowerCase = () => inst.check(_toLowerCase());
	inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def$30) => {
	$ZodString.init(inst, def$30);
	_ZodString.init(inst, def$30);
	inst.email = (params) => inst.check(_email(ZodEmail, params));
	inst.url = (params) => inst.check(_url(ZodURL, params));
	inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
	inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
	inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
	inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
	inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
	inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
	inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
	inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
	inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
	inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
	inst.xid = (params) => inst.check(_xid(ZodXID, params));
	inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
	inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
	inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
	inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
	inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
	inst.e164 = (params) => inst.check(_e164(ZodE164, params));
	inst.datetime = (params) => inst.check(datetime(params));
	inst.date = (params) => inst.check(date$1(params));
	inst.time = (params) => inst.check(time(params));
	inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
	return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def$30) => {
	$ZodStringFormat.init(inst, def$30);
	_ZodString.init(inst, def$30);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def$30) => {
	$ZodEmail.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def$30) => {
	$ZodGUID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def$30) => {
	$ZodUUID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def$30) => {
	$ZodURL.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
function url(params) {
	return _url(ZodURL, params);
}
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def$30) => {
	$ZodEmoji.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def$30) => {
	$ZodNanoID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def$30) => {
	$ZodCUID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def$30) => {
	$ZodCUID2.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def$30) => {
	$ZodULID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def$30) => {
	$ZodXID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def$30) => {
	$ZodKSUID.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def$30) => {
	$ZodIPv4.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def$30) => {
	$ZodIPv6.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def$30) => {
	$ZodCIDRv4.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def$30) => {
	$ZodCIDRv6.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def$30) => {
	$ZodBase64.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def$30) => {
	$ZodBase64URL.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def$30) => {
	$ZodE164.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def$30) => {
	$ZodJWT.init(inst, def$30);
	ZodStringFormat.init(inst, def$30);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def$30) => {
	$ZodNumber.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.int = (params) => inst.check(int(params));
	inst.safe = (params) => inst.check(int(params));
	inst.positive = (params) => inst.check(_gt(0, params));
	inst.nonnegative = (params) => inst.check(_gte(0, params));
	inst.negative = (params) => inst.check(_lt(0, params));
	inst.nonpositive = (params) => inst.check(_lte(0, params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	inst.step = (value, params) => inst.check(_multipleOf(value, params));
	inst.finite = () => inst;
	const bag = inst._zod.bag;
	inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
	inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
	inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
	inst.isFinite = true;
	inst.format = bag.format ?? null;
});
function number(params) {
	return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def$30) => {
	$ZodNumberFormat.init(inst, def$30);
	ZodNumber.init(inst, def$30);
});
function int(params) {
	return _int(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def$30) => {
	$ZodBoolean.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function boolean(params) {
	return _boolean(ZodBoolean, params);
}
const ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def$30) => {
	$ZodNull.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function _null(params) {
	return _null$1(ZodNull, params);
}
const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def$30) => {
	$ZodAny.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function any() {
	return _any(ZodAny);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def$30) => {
	$ZodUnknown.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function unknown() {
	return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def$30) => {
	$ZodNever.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function never(params) {
	return _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def$30) => {
	$ZodArray.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.element = def$30.element;
	inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
	inst.nonempty = (params) => inst.check(_minLength(1, params));
	inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
	inst.length = (len, params) => inst.check(_length(len, params));
	inst.unwrap = () => inst.element;
});
function array(element, params) {
	return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def$30) => {
	$ZodObject.init(inst, def$30);
	ZodType.init(inst, def$30);
	defineLazy(inst, "shape", () => def$30.shape);
	inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
	inst.catchall = (catchall) => inst.clone({
		...inst._zod.def,
		catchall
	});
	inst.passthrough = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.loose = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.strict = () => inst.clone({
		...inst._zod.def,
		catchall: never()
	});
	inst.strip = () => inst.clone({
		...inst._zod.def,
		catchall: void 0
	});
	inst.extend = (incoming) => {
		return extend(inst, incoming);
	};
	inst.merge = (other) => merge(inst, other);
	inst.pick = (mask) => pick(inst, mask);
	inst.omit = (mask) => omit(inst, mask);
	inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
	inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
	return new ZodObject({
		type: "object",
		get shape() {
			assignProp(this, "shape", { ...shape });
			return this.shape;
		},
		...normalizeParams(params)
	});
}
function looseObject(shape, params) {
	return new ZodObject({
		type: "object",
		get shape() {
			assignProp(this, "shape", { ...shape });
			return this.shape;
		},
		catchall: unknown(),
		...normalizeParams(params)
	});
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def$30) => {
	$ZodUnion.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.options = def$30.options;
});
function union(options, params) {
	return new ZodUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def$30) => {
	ZodUnion.init(inst, def$30);
	$ZodDiscriminatedUnion.init(inst, def$30);
});
function discriminatedUnion(discriminator, options, params) {
	return new ZodDiscriminatedUnion({
		type: "union",
		options,
		discriminator,
		...normalizeParams(params)
	});
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def$30) => {
	$ZodIntersection.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function intersection(left, right) {
	return new ZodIntersection({
		type: "intersection",
		left,
		right
	});
}
const ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def$30) => {
	$ZodRecord.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.keyType = def$30.keyType;
	inst.valueType = def$30.valueType;
});
function record(keyType, valueType, params) {
	return new ZodRecord({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def$30) => {
	$ZodEnum.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.enum = def$30.entries;
	inst.options = Object.values(def$30.entries);
	const keys = new Set(Object.keys(def$30.entries));
	inst.extract = (values, params) => {
		const newEntries = {};
		for (const value of values) if (keys.has(value)) newEntries[value] = def$30.entries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def$30,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
	inst.exclude = (values, params) => {
		const newEntries = { ...def$30.entries };
		for (const value of values) if (keys.has(value)) delete newEntries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def$30,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
});
function _enum(values, params) {
	return new ZodEnum({
		type: "enum",
		entries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,
		...normalizeParams(params)
	});
}
const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def$30) => {
	$ZodLiteral.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.values = new Set(def$30.values);
	Object.defineProperty(inst, "value", { get() {
		if (def$30.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
		return def$30.values[0];
	} });
});
function literal(value, params) {
	return new ZodLiteral({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def$30) => {
	$ZodTransform.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst._zod.parse = (payload, _ctx) => {
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, def$30));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = inst);
				_issue.continue ?? (_issue.continue = true);
				payload.issues.push(issue(_issue));
			}
		};
		const output = def$30.transform(payload.value, payload);
		if (output instanceof Promise) return output.then((output$1) => {
			payload.value = output$1;
			return payload;
		});
		payload.value = output;
		return payload;
	};
});
function transform(fn) {
	return new ZodTransform({
		type: "transform",
		transform: fn
	});
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def$30) => {
	$ZodOptional.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
	return new ZodOptional({
		type: "optional",
		innerType
	});
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def$30) => {
	$ZodNullable.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
	return new ZodNullable({
		type: "nullable",
		innerType
	});
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def$30) => {
	$ZodDefault.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
	return new ZodDefault({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : defaultValue;
		}
	});
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def$30) => {
	$ZodPrefault.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
	return new ZodPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : defaultValue;
		}
	});
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def$30) => {
	$ZodNonOptional.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
	return new ZodNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def$30) => {
	$ZodCatch.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
	return new ZodCatch({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def$30) => {
	$ZodPipe.init(inst, def$30);
	ZodType.init(inst, def$30);
	inst.in = def$30.in;
	inst.out = def$30.out;
});
function pipe(in_, out) {
	return new ZodPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def$30) => {
	$ZodReadonly.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function readonly(innerType) {
	return new ZodReadonly({
		type: "readonly",
		innerType
	});
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def$30) => {
	$ZodCustom.init(inst, def$30);
	ZodType.init(inst, def$30);
});
function check(fn) {
	const ch = new $ZodCheck({ check: "custom" });
	ch._zod.check = fn;
	return ch;
}
function custom(fn, _params) {
	return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
	return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
	const ch = check((payload) => {
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = ch);
				_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
				payload.issues.push(issue(_issue));
			}
		};
		return fn(payload.value, payload);
	});
	return ch;
}
function preprocess(fn, schema) {
	return pipe(transform(fn), schema);
}

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
const LATEST_PROTOCOL_VERSION = "2025-11-25";
const DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
const SUPPORTED_PROTOCOL_VERSIONS = [
	LATEST_PROTOCOL_VERSION,
	"2025-06-18",
	"2025-03-26",
	"2024-11-05",
	"2024-10-07"
];
const RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
const JSONRPC_VERSION = "2.0";
/**
* Assert 'object' type schema.
*
* @internal
*/
const AssertObjectSchema = custom((v) => v !== null && (typeof v === "object" || typeof v === "function"));
/**
* A progress token, used to associate progress notifications with the original request.
*/
const ProgressTokenSchema = union([string(), number().int()]);
/**
* An opaque token used to represent a cursor for pagination.
*/
const CursorSchema = string();
/**
* Task creation parameters, used to ask that the server create a task to represent a request.
*/
const TaskCreationParamsSchema = looseObject({
	ttl: union([number(), _null()]).optional(),
	pollInterval: number().optional()
});
/**
* Task association metadata, used to signal which task a message originated from.
*/
const RelatedTaskMetadataSchema = looseObject({ taskId: string() });
const RequestMetaSchema = looseObject({
	progressToken: ProgressTokenSchema.optional(),
	[RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
/**
* Common params for any request.
*/
const BaseRequestParamsSchema = looseObject({
	task: TaskCreationParamsSchema.optional(),
	_meta: RequestMetaSchema.optional()
});
const RequestSchema = object({
	method: string(),
	params: BaseRequestParamsSchema.optional()
});
const NotificationsParamsSchema = looseObject({ _meta: object({ [RELATED_TASK_META_KEY]: optional(RelatedTaskMetadataSchema) }).passthrough().optional() });
const NotificationSchema = object({
	method: string(),
	params: NotificationsParamsSchema.optional()
});
const ResultSchema = looseObject({ _meta: looseObject({ [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional() }).optional() });
/**
* A uniquely identifying ID for a request in JSON-RPC.
*/
const RequestIdSchema = union([string(), number().int()]);
/**
* A request that expects a response.
*/
const JSONRPCRequestSchema = object({
	jsonrpc: literal(JSONRPC_VERSION),
	id: RequestIdSchema,
	...RequestSchema.shape
}).strict();
const isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
/**
* A notification which does not expect a response.
*/
const JSONRPCNotificationSchema = object({
	jsonrpc: literal(JSONRPC_VERSION),
	...NotificationSchema.shape
}).strict();
const isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
/**
* A successful (non-error) response to a request.
*/
const JSONRPCResponseSchema = object({
	jsonrpc: literal(JSONRPC_VERSION),
	id: RequestIdSchema,
	result: ResultSchema
}).strict();
const isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;
/**
* Error codes defined by the JSON-RPC specification.
*/
var ErrorCode;
(function(ErrorCode$1) {
	ErrorCode$1[ErrorCode$1["ConnectionClosed"] = -32e3] = "ConnectionClosed";
	ErrorCode$1[ErrorCode$1["RequestTimeout"] = -32001] = "RequestTimeout";
	ErrorCode$1[ErrorCode$1["ParseError"] = -32700] = "ParseError";
	ErrorCode$1[ErrorCode$1["InvalidRequest"] = -32600] = "InvalidRequest";
	ErrorCode$1[ErrorCode$1["MethodNotFound"] = -32601] = "MethodNotFound";
	ErrorCode$1[ErrorCode$1["InvalidParams"] = -32602] = "InvalidParams";
	ErrorCode$1[ErrorCode$1["InternalError"] = -32603] = "InternalError";
	ErrorCode$1[ErrorCode$1["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
/**
* A response to a request that indicates an error occurred.
*/
const JSONRPCErrorSchema = object({
	jsonrpc: literal(JSONRPC_VERSION),
	id: RequestIdSchema,
	error: object({
		code: number().int(),
		message: string(),
		data: optional(unknown())
	})
}).strict();
const isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;
const JSONRPCMessageSchema = union([
	JSONRPCRequestSchema,
	JSONRPCNotificationSchema,
	JSONRPCResponseSchema,
	JSONRPCErrorSchema
]);
/**
* A response that indicates success but carries no data.
*/
const EmptyResultSchema = ResultSchema.strict();
const CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
	requestId: RequestIdSchema,
	reason: string().optional()
});
/**
* This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
*
* The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
*
* This notification indicates that the result will be unused, so any associated processing SHOULD cease.
*
* A client MUST NOT attempt to cancel its `initialize` request.
*/
const CancelledNotificationSchema = NotificationSchema.extend({
	method: literal("notifications/cancelled"),
	params: CancelledNotificationParamsSchema
});
/**
* Icon schema for use in tools, prompts, resources, and implementations.
*/
const IconSchema = object({
	src: string(),
	mimeType: string().optional(),
	sizes: array(string()).optional()
});
/**
* Base schema to add `icons` property.
*
*/
const IconsSchema = object({ icons: array(IconSchema).optional() });
/**
* Base metadata interface for common properties across resources, tools, prompts, and implementations.
*/
const BaseMetadataSchema = object({
	name: string(),
	title: string().optional()
});
/**
* Describes the name and version of an MCP implementation.
*/
const ImplementationSchema = BaseMetadataSchema.extend({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	version: string(),
	websiteUrl: string().optional()
});
const FormElicitationCapabilitySchema = intersection(object({ applyDefaults: boolean().optional() }), record(string(), unknown()));
const ElicitationCapabilitySchema = preprocess((value) => {
	if (value && typeof value === "object" && !Array.isArray(value)) {
		if (Object.keys(value).length === 0) return { form: {} };
	}
	return value;
}, intersection(object({
	form: FormElicitationCapabilitySchema.optional(),
	url: AssertObjectSchema.optional()
}), record(string(), unknown()).optional()));
/**
* Task capabilities for clients, indicating which request types support task creation.
*/
const ClientTasksCapabilitySchema = object({
	list: optional(object({}).passthrough()),
	cancel: optional(object({}).passthrough()),
	requests: optional(object({
		sampling: optional(object({ createMessage: optional(object({}).passthrough()) }).passthrough()),
		elicitation: optional(object({ create: optional(object({}).passthrough()) }).passthrough())
	}).passthrough())
}).passthrough();
/**
* Task capabilities for servers, indicating which request types support task creation.
*/
const ServerTasksCapabilitySchema = object({
	list: optional(object({}).passthrough()),
	cancel: optional(object({}).passthrough()),
	requests: optional(object({ tools: optional(object({ call: optional(object({}).passthrough()) }).passthrough()) }).passthrough())
}).passthrough();
/**
* Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
*/
const ClientCapabilitiesSchema = object({
	experimental: record(string(), AssertObjectSchema).optional(),
	sampling: object({
		context: AssertObjectSchema.optional(),
		tools: AssertObjectSchema.optional()
	}).optional(),
	elicitation: ElicitationCapabilitySchema.optional(),
	roots: object({ listChanged: boolean().optional() }).optional(),
	tasks: optional(ClientTasksCapabilitySchema)
});
const InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
	protocolVersion: string(),
	capabilities: ClientCapabilitiesSchema,
	clientInfo: ImplementationSchema
});
/**
* This request is sent from the client to the server when it first connects, asking it to begin initialization.
*/
const InitializeRequestSchema = RequestSchema.extend({
	method: literal("initialize"),
	params: InitializeRequestParamsSchema
});
const isInitializeRequest = (value) => InitializeRequestSchema.safeParse(value).success;
/**
* Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
*/
const ServerCapabilitiesSchema = object({
	experimental: record(string(), AssertObjectSchema).optional(),
	logging: AssertObjectSchema.optional(),
	completions: AssertObjectSchema.optional(),
	prompts: optional(object({ listChanged: optional(boolean()) })),
	resources: object({
		subscribe: boolean().optional(),
		listChanged: boolean().optional()
	}).optional(),
	tools: object({ listChanged: boolean().optional() }).optional(),
	tasks: optional(ServerTasksCapabilitySchema)
}).passthrough();
/**
* After receiving an initialize request from the client, the server sends this response.
*/
const InitializeResultSchema = ResultSchema.extend({
	protocolVersion: string(),
	capabilities: ServerCapabilitiesSchema,
	serverInfo: ImplementationSchema,
	instructions: string().optional()
});
/**
* This notification is sent from the client to the server after initialization has finished.
*/
const InitializedNotificationSchema = NotificationSchema.extend({ method: literal("notifications/initialized") });
const isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
/**
* A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.
*/
const PingRequestSchema = RequestSchema.extend({ method: literal("ping") });
const ProgressSchema = object({
	progress: number(),
	total: optional(number()),
	message: optional(string())
});
const ProgressNotificationParamsSchema = object({
	...NotificationsParamsSchema.shape,
	...ProgressSchema.shape,
	progressToken: ProgressTokenSchema
});
/**
* An out-of-band notification used to inform the receiver of a progress update for a long-running request.
*
* @category notifications/progress
*/
const ProgressNotificationSchema = NotificationSchema.extend({
	method: literal("notifications/progress"),
	params: ProgressNotificationParamsSchema
});
const PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({ cursor: CursorSchema.optional() });
const PaginatedRequestSchema = RequestSchema.extend({ params: PaginatedRequestParamsSchema.optional() });
const PaginatedResultSchema = ResultSchema.extend({ nextCursor: optional(CursorSchema) });
/**
* A pollable state object associated with a request.
*/
const TaskSchema = object({
	taskId: string(),
	status: _enum([
		"working",
		"input_required",
		"completed",
		"failed",
		"cancelled"
	]),
	ttl: union([number(), _null()]),
	createdAt: string(),
	lastUpdatedAt: string(),
	pollInterval: optional(number()),
	statusMessage: optional(string())
});
/**
* Result returned when a task is created, containing the task data wrapped in a task field.
*/
const CreateTaskResultSchema = ResultSchema.extend({ task: TaskSchema });
/**
* Parameters for task status notification.
*/
const TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
/**
* A notification sent when a task's status changes.
*/
const TaskStatusNotificationSchema = NotificationSchema.extend({
	method: literal("notifications/tasks/status"),
	params: TaskStatusNotificationParamsSchema
});
/**
* A request to get the state of a specific task.
*/
const GetTaskRequestSchema = RequestSchema.extend({
	method: literal("tasks/get"),
	params: BaseRequestParamsSchema.extend({ taskId: string() })
});
/**
* The response to a tasks/get request.
*/
const GetTaskResultSchema = ResultSchema.merge(TaskSchema);
/**
* A request to get the result of a specific task.
*/
const GetTaskPayloadRequestSchema = RequestSchema.extend({
	method: literal("tasks/result"),
	params: BaseRequestParamsSchema.extend({ taskId: string() })
});
/**
* A request to list tasks.
*/
const ListTasksRequestSchema = PaginatedRequestSchema.extend({ method: literal("tasks/list") });
/**
* The response to a tasks/list request.
*/
const ListTasksResultSchema = PaginatedResultSchema.extend({ tasks: array(TaskSchema) });
/**
* A request to cancel a specific task.
*/
const CancelTaskRequestSchema = RequestSchema.extend({
	method: literal("tasks/cancel"),
	params: BaseRequestParamsSchema.extend({ taskId: string() })
});
/**
* The response to a tasks/cancel request.
*/
const CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
/**
* The contents of a specific resource or sub-resource.
*/
const ResourceContentsSchema = object({
	uri: string(),
	mimeType: optional(string()),
	_meta: record(string(), unknown()).optional()
});
const TextResourceContentsSchema = ResourceContentsSchema.extend({ text: string() });
/**
* A Zod schema for validating Base64 strings that is more performant and
* robust for very large inputs than the default regex-based check. It avoids
* stack overflows by using the native `atob` function for validation.
*/
const Base64Schema = string().refine((val) => {
	try {
		atob(val);
		return true;
	} catch (_a) {
		return false;
	}
}, { message: "Invalid Base64 string" });
const BlobResourceContentsSchema = ResourceContentsSchema.extend({ blob: Base64Schema });
/**
* Optional annotations providing clients additional context about a resource.
*/
const AnnotationsSchema = object({
	audience: array(_enum(["user", "assistant"])).optional(),
	priority: number().min(0).max(1).optional(),
	lastModified: datetime({ offset: true }).optional()
});
/**
* A known resource that the server is capable of reading.
*/
const ResourceSchema = object({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	uri: string(),
	description: optional(string()),
	mimeType: optional(string()),
	annotations: AnnotationsSchema.optional(),
	_meta: optional(looseObject({}))
});
/**
* A template description for resources available on the server.
*/
const ResourceTemplateSchema = object({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	uriTemplate: string(),
	description: optional(string()),
	mimeType: optional(string()),
	annotations: AnnotationsSchema.optional(),
	_meta: optional(looseObject({}))
});
/**
* Sent from the client to request a list of resources the server has.
*/
const ListResourcesRequestSchema = PaginatedRequestSchema.extend({ method: literal("resources/list") });
/**
* The server's response to a resources/list request from the client.
*/
const ListResourcesResultSchema = PaginatedResultSchema.extend({ resources: array(ResourceSchema) });
/**
* Sent from the client to request a list of resource templates the server has.
*/
const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({ method: literal("resources/templates/list") });
/**
* The server's response to a resources/templates/list request from the client.
*/
const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({ resourceTemplates: array(ResourceTemplateSchema) });
const ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({ uri: string() });
/**
* Parameters for a `resources/read` request.
*/
const ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
/**
* Sent from the client to the server, to read a specific resource URI.
*/
const ReadResourceRequestSchema = RequestSchema.extend({
	method: literal("resources/read"),
	params: ReadResourceRequestParamsSchema
});
/**
* The server's response to a resources/read request from the client.
*/
const ReadResourceResultSchema = ResultSchema.extend({ contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema])) });
/**
* An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.
*/
const ResourceListChangedNotificationSchema = NotificationSchema.extend({ method: literal("notifications/resources/list_changed") });
const SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
/**
* Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.
*/
const SubscribeRequestSchema = RequestSchema.extend({
	method: literal("resources/subscribe"),
	params: SubscribeRequestParamsSchema
});
const UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
/**
* Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.
*/
const UnsubscribeRequestSchema = RequestSchema.extend({
	method: literal("resources/unsubscribe"),
	params: UnsubscribeRequestParamsSchema
});
/**
* Parameters for a `notifications/resources/updated` notification.
*/
const ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({ uri: string() });
/**
* A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
*/
const ResourceUpdatedNotificationSchema = NotificationSchema.extend({
	method: literal("notifications/resources/updated"),
	params: ResourceUpdatedNotificationParamsSchema
});
/**
* Describes an argument that a prompt can accept.
*/
const PromptArgumentSchema = object({
	name: string(),
	description: optional(string()),
	required: optional(boolean())
});
/**
* A prompt or prompt template that the server offers.
*/
const PromptSchema = object({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	description: optional(string()),
	arguments: optional(array(PromptArgumentSchema)),
	_meta: optional(looseObject({}))
});
/**
* Sent from the client to request a list of prompts and prompt templates the server has.
*/
const ListPromptsRequestSchema = PaginatedRequestSchema.extend({ method: literal("prompts/list") });
/**
* The server's response to a prompts/list request from the client.
*/
const ListPromptsResultSchema = PaginatedResultSchema.extend({ prompts: array(PromptSchema) });
/**
* Parameters for a `prompts/get` request.
*/
const GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
	name: string(),
	arguments: record(string(), string()).optional()
});
/**
* Used by the client to get a prompt provided by the server.
*/
const GetPromptRequestSchema = RequestSchema.extend({
	method: literal("prompts/get"),
	params: GetPromptRequestParamsSchema
});
/**
* Text provided to or from an LLM.
*/
const TextContentSchema = object({
	type: literal("text"),
	text: string(),
	annotations: AnnotationsSchema.optional(),
	_meta: record(string(), unknown()).optional()
});
/**
* An image provided to or from an LLM.
*/
const ImageContentSchema = object({
	type: literal("image"),
	data: Base64Schema,
	mimeType: string(),
	annotations: AnnotationsSchema.optional(),
	_meta: record(string(), unknown()).optional()
});
/**
* An Audio provided to or from an LLM.
*/
const AudioContentSchema = object({
	type: literal("audio"),
	data: Base64Schema,
	mimeType: string(),
	annotations: AnnotationsSchema.optional(),
	_meta: record(string(), unknown()).optional()
});
/**
* A tool call request from an assistant (LLM).
* Represents the assistant's request to use a tool.
*/
const ToolUseContentSchema = object({
	type: literal("tool_use"),
	name: string(),
	id: string(),
	input: object({}).passthrough(),
	_meta: optional(object({}).passthrough())
}).passthrough();
/**
* The contents of a resource, embedded into a prompt or tool call result.
*/
const EmbeddedResourceSchema = object({
	type: literal("resource"),
	resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
	annotations: AnnotationsSchema.optional(),
	_meta: record(string(), unknown()).optional()
});
/**
* A resource that the server is capable of reading, included in a prompt or tool call result.
*
* Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
*/
const ResourceLinkSchema = ResourceSchema.extend({ type: literal("resource_link") });
/**
* A content block that can be used in prompts and tool results.
*/
const ContentBlockSchema = union([
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema,
	ResourceLinkSchema,
	EmbeddedResourceSchema
]);
/**
* Describes a message returned as part of a prompt.
*/
const PromptMessageSchema = object({
	role: _enum(["user", "assistant"]),
	content: ContentBlockSchema
});
/**
* The server's response to a prompts/get request from the client.
*/
const GetPromptResultSchema = ResultSchema.extend({
	description: optional(string()),
	messages: array(PromptMessageSchema)
});
/**
* An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.
*/
const PromptListChangedNotificationSchema = NotificationSchema.extend({ method: literal("notifications/prompts/list_changed") });
/**
* Additional properties describing a Tool to clients.
*
* NOTE: all properties in ToolAnnotations are **hints**.
* They are not guaranteed to provide a faithful description of
* tool behavior (including descriptive properties like `title`).
*
* Clients should never make tool use decisions based on ToolAnnotations
* received from untrusted servers.
*/
const ToolAnnotationsSchema = object({
	title: string().optional(),
	readOnlyHint: boolean().optional(),
	destructiveHint: boolean().optional(),
	idempotentHint: boolean().optional(),
	openWorldHint: boolean().optional()
});
/**
* Execution-related properties for a tool.
*/
const ToolExecutionSchema = object({ taskSupport: _enum([
	"required",
	"optional",
	"forbidden"
]).optional() });
/**
* Definition for a tool the client can call.
*/
const ToolSchema = object({
	...BaseMetadataSchema.shape,
	...IconsSchema.shape,
	description: string().optional(),
	inputSchema: object({
		type: literal("object"),
		properties: record(string(), AssertObjectSchema).optional(),
		required: array(string()).optional()
	}).catchall(unknown()),
	outputSchema: object({
		type: literal("object"),
		properties: record(string(), AssertObjectSchema).optional(),
		required: array(string()).optional()
	}).catchall(unknown()).optional(),
	annotations: optional(ToolAnnotationsSchema),
	execution: optional(ToolExecutionSchema),
	_meta: record(string(), unknown()).optional()
});
/**
* Sent from the client to request a list of tools the server has.
*/
const ListToolsRequestSchema = PaginatedRequestSchema.extend({ method: literal("tools/list") });
/**
* The server's response to a tools/list request from the client.
*/
const ListToolsResultSchema = PaginatedResultSchema.extend({ tools: array(ToolSchema) });
/**
* The server's response to a tool call.
*/
const CallToolResultSchema = ResultSchema.extend({
	content: array(ContentBlockSchema).default([]),
	structuredContent: record(string(), unknown()).optional(),
	isError: optional(boolean())
});
/**
* CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.
*/
const CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({ toolResult: unknown() }));
/**
* Parameters for a `tools/call` request.
*/
const CallToolRequestParamsSchema = BaseRequestParamsSchema.extend({
	name: string(),
	arguments: optional(record(string(), unknown()))
});
/**
* Used by the client to invoke a tool provided by the server.
*/
const CallToolRequestSchema = RequestSchema.extend({
	method: literal("tools/call"),
	params: CallToolRequestParamsSchema
});
/**
* An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.
*/
const ToolListChangedNotificationSchema = NotificationSchema.extend({ method: literal("notifications/tools/list_changed") });
/**
* The severity of a log message.
*/
const LoggingLevelSchema = _enum([
	"debug",
	"info",
	"notice",
	"warning",
	"error",
	"critical",
	"alert",
	"emergency"
]);
/**
* Parameters for a `logging/setLevel` request.
*/
const SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({ level: LoggingLevelSchema });
/**
* A request from the client to the server, to enable or adjust logging.
*/
const SetLevelRequestSchema = RequestSchema.extend({
	method: literal("logging/setLevel"),
	params: SetLevelRequestParamsSchema
});
/**
* Parameters for a `notifications/message` notification.
*/
const LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
	level: LoggingLevelSchema,
	logger: string().optional(),
	data: unknown()
});
/**
* Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
*/
const LoggingMessageNotificationSchema = NotificationSchema.extend({
	method: literal("notifications/message"),
	params: LoggingMessageNotificationParamsSchema
});
/**
* Hints to use for model selection.
*/
const ModelHintSchema = object({ name: string().optional() });
/**
* The server's preferences for model selection, requested of the client during sampling.
*/
const ModelPreferencesSchema = object({
	hints: optional(array(ModelHintSchema)),
	costPriority: optional(number().min(0).max(1)),
	speedPriority: optional(number().min(0).max(1)),
	intelligencePriority: optional(number().min(0).max(1))
});
/**
* Controls tool usage behavior in sampling requests.
*/
const ToolChoiceSchema = object({ mode: optional(_enum([
	"auto",
	"required",
	"none"
])) });
/**
* The result of a tool execution, provided by the user (server).
* Represents the outcome of invoking a tool requested via ToolUseContent.
*/
const ToolResultContentSchema = object({
	type: literal("tool_result"),
	toolUseId: string().describe("The unique identifier for the corresponding tool call."),
	content: array(ContentBlockSchema).default([]),
	structuredContent: object({}).passthrough().optional(),
	isError: optional(boolean()),
	_meta: optional(object({}).passthrough())
}).passthrough();
/**
* Basic content types for sampling responses (without tool use).
* Used for backwards-compatible CreateMessageResult when tools are not used.
*/
const SamplingContentSchema = discriminatedUnion("type", [
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema
]);
/**
* Content block types allowed in sampling messages.
* This includes text, image, audio, tool use requests, and tool results.
*/
const SamplingMessageContentBlockSchema = discriminatedUnion("type", [
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema,
	ToolUseContentSchema,
	ToolResultContentSchema
]);
/**
* Describes a message issued to or received from an LLM API.
*/
const SamplingMessageSchema = object({
	role: _enum(["user", "assistant"]),
	content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
	_meta: optional(object({}).passthrough())
}).passthrough();
/**
* Parameters for a `sampling/createMessage` request.
*/
const CreateMessageRequestParamsSchema = BaseRequestParamsSchema.extend({
	messages: array(SamplingMessageSchema),
	modelPreferences: ModelPreferencesSchema.optional(),
	systemPrompt: string().optional(),
	includeContext: _enum([
		"none",
		"thisServer",
		"allServers"
	]).optional(),
	temperature: number().optional(),
	maxTokens: number().int(),
	stopSequences: array(string()).optional(),
	metadata: AssertObjectSchema.optional(),
	tools: optional(array(ToolSchema)),
	toolChoice: optional(ToolChoiceSchema)
});
/**
* A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
*/
const CreateMessageRequestSchema = RequestSchema.extend({
	method: literal("sampling/createMessage"),
	params: CreateMessageRequestParamsSchema
});
/**
* The client's response to a sampling/create_message request from the server.
* This is the backwards-compatible version that returns single content (no arrays).
* Used when the request does not include tools.
*/
const CreateMessageResultSchema = ResultSchema.extend({
	model: string(),
	stopReason: optional(_enum([
		"endTurn",
		"stopSequence",
		"maxTokens"
	]).or(string())),
	role: _enum(["user", "assistant"]),
	content: SamplingContentSchema
});
/**
* The client's response to a sampling/create_message request when tools were provided.
* This version supports array content for tool use flows.
*/
const CreateMessageResultWithToolsSchema = ResultSchema.extend({
	model: string(),
	stopReason: optional(_enum([
		"endTurn",
		"stopSequence",
		"maxTokens",
		"toolUse"
	]).or(string())),
	role: _enum(["user", "assistant"]),
	content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
/**
* Primitive schema definition for boolean fields.
*/
const BooleanSchemaSchema = object({
	type: literal("boolean"),
	title: string().optional(),
	description: string().optional(),
	default: boolean().optional()
});
/**
* Primitive schema definition for string fields.
*/
const StringSchemaSchema = object({
	type: literal("string"),
	title: string().optional(),
	description: string().optional(),
	minLength: number().optional(),
	maxLength: number().optional(),
	format: _enum([
		"email",
		"uri",
		"date",
		"date-time"
	]).optional(),
	default: string().optional()
});
/**
* Primitive schema definition for number fields.
*/
const NumberSchemaSchema = object({
	type: _enum(["number", "integer"]),
	title: string().optional(),
	description: string().optional(),
	minimum: number().optional(),
	maximum: number().optional(),
	default: number().optional()
});
/**
* Schema for single-selection enumeration without display titles for options.
*/
const UntitledSingleSelectEnumSchemaSchema = object({
	type: literal("string"),
	title: string().optional(),
	description: string().optional(),
	enum: array(string()),
	default: string().optional()
});
/**
* Schema for single-selection enumeration with display titles for each option.
*/
const TitledSingleSelectEnumSchemaSchema = object({
	type: literal("string"),
	title: string().optional(),
	description: string().optional(),
	oneOf: array(object({
		const: string(),
		title: string()
	})),
	default: string().optional()
});
/**
* Use TitledSingleSelectEnumSchema instead.
* This interface will be removed in a future version.
*/
const LegacyTitledEnumSchemaSchema = object({
	type: literal("string"),
	title: string().optional(),
	description: string().optional(),
	enum: array(string()),
	enumNames: array(string()).optional(),
	default: string().optional()
});
const SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
/**
* Schema for multiple-selection enumeration without display titles for options.
*/
const UntitledMultiSelectEnumSchemaSchema = object({
	type: literal("array"),
	title: string().optional(),
	description: string().optional(),
	minItems: number().optional(),
	maxItems: number().optional(),
	items: object({
		type: literal("string"),
		enum: array(string())
	}),
	default: array(string()).optional()
});
/**
* Schema for multiple-selection enumeration with display titles for each option.
*/
const TitledMultiSelectEnumSchemaSchema = object({
	type: literal("array"),
	title: string().optional(),
	description: string().optional(),
	minItems: number().optional(),
	maxItems: number().optional(),
	items: object({ anyOf: array(object({
		const: string(),
		title: string()
	})) }),
	default: array(string()).optional()
});
/**
* Combined schema for multiple-selection enumeration
*/
const MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
/**
* Primitive schema definition for enum fields.
*/
const EnumSchemaSchema = union([
	LegacyTitledEnumSchemaSchema,
	SingleSelectEnumSchemaSchema,
	MultiSelectEnumSchemaSchema
]);
/**
* Union of all primitive schema definitions.
*/
const PrimitiveSchemaDefinitionSchema = union([
	EnumSchemaSchema,
	BooleanSchemaSchema,
	StringSchemaSchema,
	NumberSchemaSchema
]);
/**
* Parameters for an `elicitation/create` request for form-based elicitation.
*/
const ElicitRequestFormParamsSchema = BaseRequestParamsSchema.extend({
	mode: literal("form").optional(),
	message: string(),
	requestedSchema: object({
		type: literal("object"),
		properties: record(string(), PrimitiveSchemaDefinitionSchema),
		required: array(string()).optional()
	})
});
/**
* Parameters for an `elicitation/create` request for URL-based elicitation.
*/
const ElicitRequestURLParamsSchema = BaseRequestParamsSchema.extend({
	mode: literal("url"),
	message: string(),
	elicitationId: string(),
	url: string().url()
});
/**
* The parameters for a request to elicit additional information from the user via the client.
*/
const ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
/**
* A request from the server to elicit user input via the client.
* The client should present the message and form fields to the user (form mode)
* or navigate to a URL (URL mode).
*/
const ElicitRequestSchema = RequestSchema.extend({
	method: literal("elicitation/create"),
	params: ElicitRequestParamsSchema
});
/**
* Parameters for a `notifications/elicitation/complete` notification.
*
* @category notifications/elicitation/complete
*/
const ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({ elicitationId: string() });
/**
* A notification from the server to the client, informing it of a completion of an out-of-band elicitation request.
*
* @category notifications/elicitation/complete
*/
const ElicitationCompleteNotificationSchema = NotificationSchema.extend({
	method: literal("notifications/elicitation/complete"),
	params: ElicitationCompleteNotificationParamsSchema
});
/**
* The client's response to an elicitation/create request from the server.
*/
const ElicitResultSchema = ResultSchema.extend({
	action: _enum([
		"accept",
		"decline",
		"cancel"
	]),
	content: preprocess((val) => val === null ? void 0 : val, record(string(), union([
		string(),
		number(),
		boolean(),
		array(string())
	])).optional())
});
/**
* A reference to a resource or resource template definition.
*/
const ResourceTemplateReferenceSchema = object({
	type: literal("ref/resource"),
	uri: string()
});
/**
* Identifies a prompt.
*/
const PromptReferenceSchema = object({
	type: literal("ref/prompt"),
	name: string()
});
/**
* Parameters for a `completion/complete` request.
*/
const CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
	ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
	argument: object({
		name: string(),
		value: string()
	}),
	context: object({ arguments: record(string(), string()).optional() }).optional()
});
/**
* A request from the client to the server, to ask for completion options.
*/
const CompleteRequestSchema = RequestSchema.extend({
	method: literal("completion/complete"),
	params: CompleteRequestParamsSchema
});
/**
* The server's response to a completion/complete request
*/
const CompleteResultSchema = ResultSchema.extend({ completion: looseObject({
	values: array(string()).max(100),
	total: optional(number().int()),
	hasMore: optional(boolean())
}) });
/**
* Represents a root directory or file that the server can operate on.
*/
const RootSchema = object({
	uri: string().startsWith("file://"),
	name: string().optional(),
	_meta: record(string(), unknown()).optional()
});
/**
* Sent from the server to request a list of root URIs from the client.
*/
const ListRootsRequestSchema = RequestSchema.extend({ method: literal("roots/list") });
/**
* The client's response to a roots/list request from the server.
*/
const ListRootsResultSchema = ResultSchema.extend({ roots: array(RootSchema) });
/**
* A notification from the client to the server, informing it that the list of roots has changed.
*/
const RootsListChangedNotificationSchema = NotificationSchema.extend({ method: literal("notifications/roots/list_changed") });
const ClientRequestSchema = union([
	PingRequestSchema,
	InitializeRequestSchema,
	CompleteRequestSchema,
	SetLevelRequestSchema,
	GetPromptRequestSchema,
	ListPromptsRequestSchema,
	ListResourcesRequestSchema,
	ListResourceTemplatesRequestSchema,
	ReadResourceRequestSchema,
	SubscribeRequestSchema,
	UnsubscribeRequestSchema,
	CallToolRequestSchema,
	ListToolsRequestSchema,
	GetTaskRequestSchema,
	GetTaskPayloadRequestSchema,
	ListTasksRequestSchema
]);
const ClientNotificationSchema = union([
	CancelledNotificationSchema,
	ProgressNotificationSchema,
	InitializedNotificationSchema,
	RootsListChangedNotificationSchema,
	TaskStatusNotificationSchema
]);
const ClientResultSchema = union([
	EmptyResultSchema,
	CreateMessageResultSchema,
	CreateMessageResultWithToolsSchema,
	ElicitResultSchema,
	ListRootsResultSchema,
	GetTaskResultSchema,
	ListTasksResultSchema,
	CreateTaskResultSchema
]);
const ServerRequestSchema = union([
	PingRequestSchema,
	CreateMessageRequestSchema,
	ElicitRequestSchema,
	ListRootsRequestSchema,
	GetTaskRequestSchema,
	GetTaskPayloadRequestSchema,
	ListTasksRequestSchema
]);
const ServerNotificationSchema = union([
	CancelledNotificationSchema,
	ProgressNotificationSchema,
	LoggingMessageNotificationSchema,
	ResourceUpdatedNotificationSchema,
	ResourceListChangedNotificationSchema,
	ToolListChangedNotificationSchema,
	PromptListChangedNotificationSchema,
	TaskStatusNotificationSchema,
	ElicitationCompleteNotificationSchema
]);
const ServerResultSchema = union([
	EmptyResultSchema,
	InitializeResultSchema,
	CompleteResultSchema,
	GetPromptResultSchema,
	ListPromptsResultSchema,
	ListResourcesResultSchema,
	ListResourceTemplatesResultSchema,
	ReadResourceResultSchema,
	CallToolResultSchema,
	ListToolsResultSchema,
	GetTaskResultSchema,
	ListTasksResultSchema,
	CreateTaskResultSchema
]);
var McpError = class McpError extends Error {
	constructor(code, message, data) {
		super(`MCP error ${code}: ${message}`);
		this.code = code;
		this.data = data;
		this.name = "McpError";
	}
	/**
	* Factory method to create the appropriate error type based on the error code and data
	*/
	static fromError(code, message, data) {
		if (code === ErrorCode.UrlElicitationRequired && data) {
			const errorData = data;
			if (errorData.elicitations) return new UrlElicitationRequiredError(errorData.elicitations, message);
		}
		return new McpError(code, message, data);
	}
};
/**
* Specialized error type when a tool requires a URL mode elicitation.
* This makes it nicer for the client to handle since there is specific data to work with instead of just a code to check against.
*/
var UrlElicitationRequiredError = class extends McpError {
	constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
		super(ErrorCode.UrlElicitationRequired, message, { elicitations });
	}
	get elicitations() {
		var _a, _b;
		return (_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.elicitations) !== null && _b !== void 0 ? _b : [];
	}
};

//#endregion
//#region src/proxyServer.ts
const proxyServer = async ({ client, requestTimeout, server, serverCapabilities }) => {
	if (serverCapabilities?.logging) {
		server.setNotificationHandler(LoggingMessageNotificationSchema, async (args) => {
			return client.notification(args);
		});
		client.setNotificationHandler(LoggingMessageNotificationSchema, async (args) => {
			return server.notification(args);
		});
	}
	if (serverCapabilities?.prompts) {
		server.setRequestHandler(GetPromptRequestSchema, async (args) => {
			return client.getPrompt(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ListPromptsRequestSchema, async (args) => {
			return client.listPrompts(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
	}
	if (serverCapabilities?.resources) {
		server.setRequestHandler(ListResourcesRequestSchema, async (args) => {
			return client.listResources(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ListResourceTemplatesRequestSchema, async (args) => {
			return client.listResourceTemplates(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ReadResourceRequestSchema, async (args) => {
			return client.readResource(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		if (serverCapabilities?.resources.subscribe) {
			server.setNotificationHandler(ResourceUpdatedNotificationSchema, async (args) => {
				return client.notification(args);
			});
			server.setRequestHandler(SubscribeRequestSchema, async (args) => {
				return client.subscribeResource(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
			});
			server.setRequestHandler(UnsubscribeRequestSchema, async (args) => {
				return client.unsubscribeResource(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
			});
		}
	}
	if (serverCapabilities?.tools) {
		server.setRequestHandler(CallToolRequestSchema, async (args) => {
			return client.callTool(args.params, void 0, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ListToolsRequestSchema, async (args) => {
			return client.listTools(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
	}
	if (serverCapabilities?.completions) server.setRequestHandler(CompleteRequestSchema, async (args) => {
		return client.complete(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
	});
};

//#endregion
//#region node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
/*!
* bytes
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015 Jed Watson
* MIT Licensed
*/
var require_bytes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = bytes$1;
	module.exports.format = format$1;
	module.exports.parse = parse$2;
	/**
	* Module variables.
	* @private
	*/
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	var map = {
		b: 1,
		kb: 1024,
		mb: 1 << 20,
		gb: 1 << 30,
		tb: Math.pow(1024, 4),
		pb: Math.pow(1024, 5)
	};
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
	/**
	* Convert the given value in bytes into a string or parse to string to an integer in bytes.
	*
	* @param {string|number} value
	* @param {{
	*  case: [string],
	*  decimalPlaces: [number]
	*  fixedDecimals: [boolean]
	*  thousandsSeparator: [string]
	*  unitSeparator: [string]
	*  }} [options] bytes options.
	*
	* @returns {string|number|null}
	*/
	function bytes$1(value, options) {
		if (typeof value === "string") return parse$2(value);
		if (typeof value === "number") return format$1(value, options);
		return null;
	}
	/**
	* Format the given value in bytes into a string.
	*
	* If the value is negative, it is kept as such. If it is a float,
	* it is rounded.
	*
	* @param {number} value
	* @param {object} [options]
	* @param {number} [options.decimalPlaces=2]
	* @param {number} [options.fixedDecimals=false]
	* @param {string} [options.thousandsSeparator=]
	* @param {string} [options.unit=]
	* @param {string} [options.unitSeparator=]
	*
	* @returns {string|null}
	* @public
	*/
	function format$1(value, options) {
		if (!Number.isFinite(value)) return null;
		var mag = Math.abs(value);
		var thousandsSeparator = options && options.thousandsSeparator || "";
		var unitSeparator = options && options.unitSeparator || "";
		var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
		var fixedDecimals = Boolean(options && options.fixedDecimals);
		var unit = options && options.unit || "";
		if (!unit || !map[unit.toLowerCase()]) if (mag >= map.pb) unit = "PB";
		else if (mag >= map.tb) unit = "TB";
		else if (mag >= map.gb) unit = "GB";
		else if (mag >= map.mb) unit = "MB";
		else if (mag >= map.kb) unit = "KB";
		else unit = "B";
		var str$1 = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);
		if (!fixedDecimals) str$1 = str$1.replace(formatDecimalsRegExp, "$1");
		if (thousandsSeparator) str$1 = str$1.split(".").map(function(s, i$3) {
			return i$3 === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
		}).join(".");
		return str$1 + unitSeparator + unit;
	}
	/**
	* Parse the string value into an integer in bytes.
	*
	* If no unit is given, it is assumed the value is in bytes.
	*
	* @param {number|string} val
	*
	* @returns {number|null}
	* @public
	*/
	function parse$2(val) {
		if (typeof val === "number" && !isNaN(val)) return val;
		if (typeof val !== "string") return null;
		var results = parseRegExp.exec(val);
		var floatValue;
		var unit = "b";
		if (!results) {
			floatValue = parseInt(val, 10);
			unit = "b";
		} else {
			floatValue = parseFloat(results[1]);
			unit = results[4].toLowerCase();
		}
		if (isNaN(floatValue)) return null;
		return Math.floor(map[unit] * floatValue);
	}
}));

//#endregion
//#region node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js
var require_depd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* depd
	* Copyright(c) 2014-2018 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module dependencies.
	*/
	var relative = __require("path").relative;
	/**
	* Module exports.
	*/
	module.exports = depd;
	/**
	* Get the path to base files on.
	*/
	var basePath = process.cwd();
	/**
	* Determine if namespace is contained in the string.
	*/
	function containsNamespace(str$1, namespace) {
		var vals = str$1.split(/[ ,]+/);
		var ns = String(namespace).toLowerCase();
		for (var i$3 = 0; i$3 < vals.length; i$3++) {
			var val = vals[i$3];
			if (val && (val === "*" || val.toLowerCase() === ns)) return true;
		}
		return false;
	}
	/**
	* Convert a data descriptor to accessor descriptor.
	*/
	function convertDataDescriptorToAccessor(obj, prop, message) {
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		var value = descriptor.value;
		descriptor.get = function getter() {
			return value;
		};
		if (descriptor.writable) descriptor.set = function setter(val) {
			return value = val;
		};
		delete descriptor.value;
		delete descriptor.writable;
		Object.defineProperty(obj, prop, descriptor);
		return descriptor;
	}
	/**
	* Create arguments string to keep arity.
	*/
	function createArgumentsString(arity) {
		var str$1 = "";
		for (var i$3 = 0; i$3 < arity; i$3++) str$1 += ", arg" + i$3;
		return str$1.substr(2);
	}
	/**
	* Create stack string from stack.
	*/
	function createStackString(stack) {
		var str$1 = this.name + ": " + this.namespace;
		if (this.message) str$1 += " deprecated " + this.message;
		for (var i$3 = 0; i$3 < stack.length; i$3++) str$1 += "\n    at " + stack[i$3].toString();
		return str$1;
	}
	/**
	* Create deprecate for namespace in caller.
	*/
	function depd(namespace) {
		if (!namespace) throw new TypeError("argument namespace is required");
		var file = callSiteLocation(getStack()[1])[0];
		function deprecate$1(message) {
			log.call(deprecate$1, message);
		}
		deprecate$1._file = file;
		deprecate$1._ignored = isignored(namespace);
		deprecate$1._namespace = namespace;
		deprecate$1._traced = istraced(namespace);
		deprecate$1._warned = Object.create(null);
		deprecate$1.function = wrapfunction;
		deprecate$1.property = wrapproperty;
		return deprecate$1;
	}
	/**
	* Determine if event emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function eehaslisteners(emitter, type) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type)) > 0;
	}
	/**
	* Determine if namespace is ignored.
	*/
	function isignored(namespace) {
		if (process.noDeprecation) return true;
		return containsNamespace(process.env.NO_DEPRECATION || "", namespace);
	}
	/**
	* Determine if namespace is traced.
	*/
	function istraced(namespace) {
		if (process.traceDeprecation) return true;
		return containsNamespace(process.env.TRACE_DEPRECATION || "", namespace);
	}
	/**
	* Display deprecation message.
	*/
	function log(message, site) {
		var haslisteners = eehaslisteners(process, "deprecation");
		if (!haslisteners && this._ignored) return;
		var caller;
		var callFile;
		var callSite;
		var depSite;
		var i$3 = 0;
		var seen = false;
		var stack = getStack();
		var file = this._file;
		if (site) {
			depSite = site;
			callSite = callSiteLocation(stack[1]);
			callSite.name = depSite.name;
			file = callSite[0];
		} else {
			i$3 = 2;
			depSite = callSiteLocation(stack[i$3]);
			callSite = depSite;
		}
		for (; i$3 < stack.length; i$3++) {
			caller = callSiteLocation(stack[i$3]);
			callFile = caller[0];
			if (callFile === file) seen = true;
			else if (callFile === this._file) file = this._file;
			else if (seen) break;
		}
		var key$1 = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
		if (key$1 !== void 0 && key$1 in this._warned) return;
		this._warned[key$1] = true;
		var msg = message;
		if (!msg) msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
		if (haslisteners) {
			var err = DeprecationError(this._namespace, msg, stack.slice(i$3));
			process.emit("deprecation", err);
			return;
		}
		var output = (process.stderr.isTTY ? formatColor : formatPlain).call(this, msg, caller, stack.slice(i$3));
		process.stderr.write(output + "\n", "utf8");
	}
	/**
	* Get call site location as array.
	*/
	function callSiteLocation(callSite) {
		var file = callSite.getFileName() || "<anonymous>";
		var line$1 = callSite.getLineNumber();
		var colm = callSite.getColumnNumber();
		if (callSite.isEval()) file = callSite.getEvalOrigin() + ", " + file;
		var site = [
			file,
			line$1,
			colm
		];
		site.callSite = callSite;
		site.name = callSite.getFunctionName();
		return site;
	}
	/**
	* Generate a default message from the site.
	*/
	function defaultMessage(site) {
		var callSite = site.callSite;
		var funcName = site.name;
		if (!funcName) funcName = "<anonymous@" + formatLocation(site) + ">";
		var context = callSite.getThis();
		var typeName = context && callSite.getTypeName();
		if (typeName === "Object") typeName = void 0;
		if (typeName === "Function") typeName = context.name || typeName;
		return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
	}
	/**
	* Format deprecation message without color.
	*/
	function formatPlain(msg, caller, stack) {
		var formatted = (/* @__PURE__ */ new Date()).toUTCString() + " " + this._namespace + " deprecated " + msg;
		if (this._traced) {
			for (var i$3 = 0; i$3 < stack.length; i$3++) formatted += "\n    at " + stack[i$3].toString();
			return formatted;
		}
		if (caller) formatted += " at " + formatLocation(caller);
		return formatted;
	}
	/**
	* Format deprecation message with color.
	*/
	function formatColor(msg, caller, stack) {
		var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
		if (this._traced) {
			for (var i$3 = 0; i$3 < stack.length; i$3++) formatted += "\n    \x1B[36mat " + stack[i$3].toString() + "\x1B[39m";
			return formatted;
		}
		if (caller) formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
		return formatted;
	}
	/**
	* Format call site location.
	*/
	function formatLocation(callSite) {
		return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
	}
	/**
	* Get the stack as array of call sites.
	*/
	function getStack() {
		var limit = Error.stackTraceLimit;
		var obj = {};
		var prep = Error.prepareStackTrace;
		Error.prepareStackTrace = prepareObjectStackTrace;
		Error.stackTraceLimit = Math.max(10, limit);
		Error.captureStackTrace(obj);
		var stack = obj.stack.slice(1);
		Error.prepareStackTrace = prep;
		Error.stackTraceLimit = limit;
		return stack;
	}
	/**
	* Capture call site stack from v8.
	*/
	function prepareObjectStackTrace(obj, stack) {
		return stack;
	}
	/**
	* Return a wrapped function in a deprecation message.
	*/
	function wrapfunction(fn, message) {
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		var args = createArgumentsString(fn.length);
		var site = callSiteLocation(getStack()[1]);
		site.name = fn.name;
		return new Function("fn", "log", "deprecate", "message", "site", "\"use strict\"\nreturn function (" + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
	}
	/**
	* Wrap property in a deprecation message.
	*/
	function wrapproperty(obj, prop, message) {
		if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new TypeError("argument obj must be object");
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		if (!descriptor) throw new TypeError("must call property on owner object");
		if (!descriptor.configurable) throw new TypeError("property must be configurable");
		var deprecate$1 = this;
		var site = callSiteLocation(getStack()[1]);
		site.name = prop;
		if ("value" in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
		var get = descriptor.get;
		var set = descriptor.set;
		if (typeof get === "function") descriptor.get = function getter() {
			log.call(deprecate$1, message, site);
			return get.apply(this, arguments);
		};
		if (typeof set === "function") descriptor.set = function setter() {
			log.call(deprecate$1, message, site);
			return set.apply(this, arguments);
		};
		Object.defineProperty(obj, prop, descriptor);
	}
	/**
	* Create DeprecationError for deprecation
	*/
	function DeprecationError(namespace, message, stack) {
		var error$1 = /* @__PURE__ */ new Error();
		var stackString;
		Object.defineProperty(error$1, "constructor", { value: DeprecationError });
		Object.defineProperty(error$1, "message", {
			configurable: true,
			enumerable: false,
			value: message,
			writable: true
		});
		Object.defineProperty(error$1, "name", {
			enumerable: false,
			configurable: true,
			value: "DeprecationError",
			writable: true
		});
		Object.defineProperty(error$1, "namespace", {
			configurable: true,
			enumerable: false,
			value: namespace,
			writable: true
		});
		Object.defineProperty(error$1, "stack", {
			configurable: true,
			enumerable: false,
			get: function() {
				if (stackString !== void 0) return stackString;
				return stackString = createStackString.call(this, stack);
			},
			set: function setter(val) {
				stackString = val;
			}
		});
		return error$1;
	}
}));

//#endregion
//#region node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js
var require_setprototypeof = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
		return obj;
	}
	function mixinProperties(obj, proto) {
		for (var prop in proto) if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
		return obj;
	}
}));

//#endregion
//#region node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json
var require_codes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
}));

//#endregion
//#region node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js
/*!
* statuses
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_statuses = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var codes = require_codes();
	/**
	* Module exports.
	* @public
	*/
	module.exports = status;
	status.message = codes;
	status.code = createMessageToStatusCodeMap(codes);
	status.codes = createStatusCodeList(codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	/**
	* Create a map of message to status code.
	* @private
	*/
	function createMessageToStatusCodeMap(codes$1) {
		var map$1 = {};
		Object.keys(codes$1).forEach(function forEachCode(code) {
			var message = codes$1[code];
			var status$1 = Number(code);
			map$1[message.toLowerCase()] = status$1;
		});
		return map$1;
	}
	/**
	* Create a list of all status codes.
	* @private
	*/
	function createStatusCodeList(codes$1) {
		return Object.keys(codes$1).map(function mapCode(code) {
			return Number(code);
		});
	}
	/**
	* Get the status code for given message.
	* @private
	*/
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status.code[msg];
	}
	/**
	* Get the status message for given code.
	* @private
	*/
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error("invalid status code: " + code);
		return status.message[code];
	}
	/**
	* Get the status code.
	*
	* Given a number, this will throw if it is not a known status
	* code, otherwise the code will be returned. Given a string,
	* the string will be parsed for a number and return the code
	* if valid, otherwise will lookup the code assuming this is
	* the status message.
	*
	* @param {string|number} code
	* @returns {number}
	* @public
	*/
	function status(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
}));

//#endregion
//#region node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits$1(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits$1(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}));

//#endregion
//#region node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	try {
		var util = __require("util");
		/* istanbul ignore next */
		if (typeof util.inherits !== "function") throw "";
		module.exports = util.inherits;
	} catch (e) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}));

//#endregion
//#region node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js
/*!
* toidentifier
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_toidentifier = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = toIdentifier$1;
	/**
	* Trasform the given string into a JavaScript identifier
	*
	* @param {string} str
	* @returns {string}
	* @public
	*/
	function toIdentifier$1(str$1) {
		return str$1.split(" ").map(function(token) {
			return token.slice(0, 1).toUpperCase() + token.slice(1);
		}).join("").replace(/[^ _0-9a-z]/gi, "");
	}
}));

//#endregion
//#region node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js
/*!
* http-errors
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_http_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate = require_depd()("http-errors");
	var setPrototypeOf = require_setprototypeof();
	var statuses = require_statuses();
	var inherits = require_inherits();
	var toIdentifier = require_toidentifier();
	/**
	* Module exports.
	* @public
	*/
	module.exports = createError$1;
	module.exports.HttpError = createHttpErrorConstructor();
	module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
	/**
	* Get the code class of a status code.
	* @private
	*/
	function codeClass(status$1) {
		return Number(String(status$1).charAt(0) + "00");
	}
	/**
	* Create a new HTTP Error.
	*
	* @returns {Error}
	* @public
	*/
	function createError$1() {
		var err;
		var msg;
		var status$1 = 500;
		var props = {};
		for (var i$3 = 0; i$3 < arguments.length; i$3++) {
			var arg = arguments[i$3];
			var type = typeof arg;
			if (type === "object" && arg instanceof Error) {
				err = arg;
				status$1 = err.status || err.statusCode || status$1;
			} else if (type === "number" && i$3 === 0) status$1 = arg;
			else if (type === "string") msg = arg;
			else if (type === "object") props = arg;
			else throw new TypeError("argument #" + (i$3 + 1) + " unsupported type " + type);
		}
		if (typeof status$1 === "number" && (status$1 < 400 || status$1 >= 600)) deprecate("non-error status code; use only 4xx or 5xx status codes");
		if (typeof status$1 !== "number" || !statuses.message[status$1] && (status$1 < 400 || status$1 >= 600)) status$1 = 500;
		var HttpError = createError$1[status$1] || createError$1[codeClass(status$1)];
		if (!err) {
			err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status$1]);
			Error.captureStackTrace(err, createError$1);
		}
		if (!HttpError || !(err instanceof HttpError) || err.status !== status$1) {
			err.expose = status$1 < 500;
			err.status = err.statusCode = status$1;
		}
		for (var key$1 in props) if (key$1 !== "status" && key$1 !== "statusCode") err[key$1] = props[key$1];
		return err;
	}
	/**
	* Create HTTP error abstract base class.
	* @private
	*/
	function createHttpErrorConstructor() {
		function HttpError() {
			throw new TypeError("cannot construct abstract class");
		}
		inherits(HttpError, Error);
		return HttpError;
	}
	/**
	* Create a constructor for a client error.
	* @private
	*/
	function createClientErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ClientError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ClientError);
			setPrototypeOf(err, ClientError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ClientError, HttpError);
		nameFunc(ClientError, className);
		ClientError.prototype.status = code;
		ClientError.prototype.statusCode = code;
		ClientError.prototype.expose = true;
		return ClientError;
	}
	/**
	* Create function to test is a value is a HttpError.
	* @private
	*/
	function createIsHttpErrorFunction(HttpError) {
		return function isHttpError(val) {
			if (!val || typeof val !== "object") return false;
			if (val instanceof HttpError) return true;
			return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
		};
	}
	/**
	* Create a constructor for a server error.
	* @private
	*/
	function createServerErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ServerError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ServerError);
			setPrototypeOf(err, ServerError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ServerError, HttpError);
		nameFunc(ServerError, className);
		ServerError.prototype.status = code;
		ServerError.prototype.statusCode = code;
		ServerError.prototype.expose = false;
		return ServerError;
	}
	/**
	* Set the name of a function, if possible.
	* @private
	*/
	function nameFunc(func, name) {
		var desc = Object.getOwnPropertyDescriptor(func, "name");
		if (desc && desc.configurable) {
			desc.value = name;
			Object.defineProperty(func, "name", desc);
		}
	}
	/**
	* Populate the exports object with constructors for every error class.
	* @private
	*/
	function populateConstructorExports(exports$1, codes$1, HttpError) {
		codes$1.forEach(function forEachCode(code) {
			var CodeError;
			var name = toIdentifier(statuses.message[code]);
			switch (codeClass(code)) {
				case 400:
					CodeError = createClientErrorConstructor(HttpError, name, code);
					break;
				case 500:
					CodeError = createServerErrorConstructor(HttpError, name, code);
					break;
			}
			if (CodeError) {
				exports$1[code] = CodeError;
				exports$1[name] = CodeError;
			}
		});
	}
	/**
	* Get a class name from a name identifier.
	* @private
	*/
	function toClassName(name) {
		return name.substr(-5) !== "Error" ? name + "Error" : name;
	}
}));

//#endregion
//#region node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var buffer = __require("buffer");
	var Buffer$9 = buffer.Buffer;
	var safer = {};
	var key;
	for (key in buffer) {
		if (!buffer.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer$9) {
		if (!Buffer$9.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer$9[key];
	}
	safer.Buffer.prototype = Buffer$9.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer$9(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer$9(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	module.exports = safer;
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = /* @__PURE__ */ __commonJSMin(((exports) => {
	var BOMChar = "";
	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str$1) {
		if (this.addBOM) {
			str$1 = BOMChar + str$1;
			this.addBOM = false;
		}
		return this.encoder.write(str$1);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res = this.decoder.write(buf);
		if (this.pass || !res) return res;
		if (res[0] === BOMChar) {
			res = res.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js
var require_merge_exports = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
	function mergeModules$2(target, module$2) {
		for (var key$1 in module$2) if (hasOwn(module$2, key$1)) target[key$1] = module$2[key$1];
	}
	module.exports = mergeModules$2;
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js
var require_internal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$8 = require_safer().Buffer;
	module.exports = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv$2) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "utf8") this.encoder = InternalEncoderUtf8;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer$8.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv$2.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder = __require("string_decoder").StringDecoder;
	function InternalDecoder(options, codec) {
		this.decoder = new StringDecoder(codec.enc);
	}
	InternalDecoder.prototype.write = function(buf) {
		if (!Buffer$8.isBuffer(buf)) buf = Buffer$8.from(buf);
		return this.decoder.write(buf);
	};
	InternalDecoder.prototype.end = function() {
		return this.decoder.end();
	};
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str$1) {
		return Buffer$8.from(str$1, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str$1) {
		str$1 = this.prevStr + str$1;
		var completeQuads = str$1.length - str$1.length % 4;
		this.prevStr = str$1.slice(completeQuads);
		str$1 = str$1.slice(0, completeQuads);
		return Buffer$8.from(str$1, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer$8.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str$1) {
		var buf = Buffer$8.alloc(str$1.length * 3);
		var bufIdx = 0;
		for (var i$3 = 0; i$3 < str$1.length; i$3++) {
			var charCode = str$1.charCodeAt(i$3);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc;
		var contBytes = this.contBytes;
		var accBytes = this.accBytes;
		var res = "";
		for (var i$3 = 0; i$3 < buf.length; i$3++) {
			var curByte = buf[i$3];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
				else res += String.fromCharCode(acc);
			} else res += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res = 0;
		if (this.contBytes > 0) res += this.defaultCharUnicode;
		return res;
	};
	function InternalEncoderUtf8(options, codec) {
		this.highSurrogate = "";
	}
	InternalEncoderUtf8.prototype.write = function(str$1) {
		if (this.highSurrogate) {
			str$1 = this.highSurrogate + str$1;
			this.highSurrogate = "";
		}
		if (str$1.length > 0) {
			var charCode = str$1.charCodeAt(str$1.length - 1);
			if (charCode >= 55296 && charCode < 56320) {
				this.highSurrogate = str$1[str$1.length - 1];
				str$1 = str$1.slice(0, str$1.length - 1);
			}
		}
		return Buffer$8.from(str$1, this.enc);
	};
	InternalEncoderUtf8.prototype.end = function() {
		if (this.highSurrogate) {
			var str$1 = this.highSurrogate;
			this.highSurrogate = "";
			return Buffer$8.from(str$1, this.enc);
		}
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer$7 = require_safer().Buffer;
	exports._utf32 = Utf32Codec;
	function Utf32Codec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
		this.bomAware = true;
		this.isLE = codecOptions.isLE;
	}
	exports.utf32le = {
		type: "_utf32",
		isLE: true
	};
	exports.utf32be = {
		type: "_utf32",
		isLE: false
	};
	exports.ucs4le = "utf32le";
	exports.ucs4be = "utf32be";
	Utf32Codec.prototype.encoder = Utf32Encoder;
	Utf32Codec.prototype.decoder = Utf32Decoder;
	function Utf32Encoder(options, codec) {
		this.isLE = codec.isLE;
		this.highSurrogate = 0;
	}
	Utf32Encoder.prototype.write = function(str$1) {
		var src = Buffer$7.from(str$1, "ucs2");
		var dst = Buffer$7.alloc(src.length * 2);
		var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
		var offset = 0;
		for (var i$3 = 0; i$3 < src.length; i$3 += 2) {
			var code = src.readUInt16LE(i$3);
			var isHighSurrogate = code >= 55296 && code < 56320;
			var isLowSurrogate = code >= 56320 && code < 57344;
			if (this.highSurrogate) if (isHighSurrogate || !isLowSurrogate) {
				write32.call(dst, this.highSurrogate, offset);
				offset += 4;
			} else {
				var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
				write32.call(dst, codepoint, offset);
				offset += 4;
				this.highSurrogate = 0;
				continue;
			}
			if (isHighSurrogate) this.highSurrogate = code;
			else {
				write32.call(dst, code, offset);
				offset += 4;
				this.highSurrogate = 0;
			}
		}
		if (offset < dst.length) dst = dst.slice(0, offset);
		return dst;
	};
	Utf32Encoder.prototype.end = function() {
		if (!this.highSurrogate) return;
		var buf = Buffer$7.alloc(4);
		if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
		else buf.writeUInt32BE(this.highSurrogate, 0);
		this.highSurrogate = 0;
		return buf;
	};
	function Utf32Decoder(options, codec) {
		this.isLE = codec.isLE;
		this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
		this.overflow = [];
	}
	Utf32Decoder.prototype.write = function(src) {
		if (src.length === 0) return "";
		var i$3 = 0;
		var codepoint = 0;
		var dst = Buffer$7.alloc(src.length + 4);
		var offset = 0;
		var isLE = this.isLE;
		var overflow = this.overflow;
		var badChar = this.badChar;
		if (overflow.length > 0) {
			for (; i$3 < src.length && overflow.length < 4; i$3++) overflow.push(src[i$3]);
			if (overflow.length === 4) {
				if (isLE) codepoint = overflow[i$3] | overflow[i$3 + 1] << 8 | overflow[i$3 + 2] << 16 | overflow[i$3 + 3] << 24;
				else codepoint = overflow[i$3 + 3] | overflow[i$3 + 2] << 8 | overflow[i$3 + 1] << 16 | overflow[i$3] << 24;
				overflow.length = 0;
				offset = _writeCodepoint(dst, offset, codepoint, badChar);
			}
		}
		for (; i$3 < src.length - 3; i$3 += 4) {
			if (isLE) codepoint = src[i$3] | src[i$3 + 1] << 8 | src[i$3 + 2] << 16 | src[i$3 + 3] << 24;
			else codepoint = src[i$3 + 3] | src[i$3 + 2] << 8 | src[i$3 + 1] << 16 | src[i$3] << 24;
			offset = _writeCodepoint(dst, offset, codepoint, badChar);
		}
		for (; i$3 < src.length; i$3++) overflow.push(src[i$3]);
		return dst.slice(0, offset).toString("ucs2");
	};
	function _writeCodepoint(dst, offset, codepoint, badChar) {
		if (codepoint < 0 || codepoint > 1114111) codepoint = badChar;
		if (codepoint >= 65536) {
			codepoint -= 65536;
			var high = 55296 | codepoint >> 10;
			dst[offset++] = high & 255;
			dst[offset++] = high >> 8;
			var codepoint = 56320 | codepoint & 1023;
		}
		dst[offset++] = codepoint & 255;
		dst[offset++] = codepoint >> 8;
		return offset;
	}
	Utf32Decoder.prototype.end = function() {
		this.overflow.length = 0;
	};
	exports.utf32 = Utf32AutoCodec;
	exports.ucs4 = "utf32";
	function Utf32AutoCodec(options, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
	function Utf32AutoEncoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
	}
	Utf32AutoEncoder.prototype.write = function(str$1) {
		return this.encoder.write(str$1);
	};
	Utf32AutoEncoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf32AutoDecoder(options, codec) {
		this.decoder = null;
		this.initialBufs = [];
		this.initialBufsLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf32AutoDecoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBufs.push(buf);
			this.initialBufsLen += buf.length;
			if (this.initialBufsLen < 32) return "";
			var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.write(buf);
	};
	Utf32AutoDecoder.prototype.end = function() {
		if (!this.decoder) {
			var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			var trail = this.decoder.end();
			if (trail) resStr += trail;
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.end();
	};
	function detectEncoding$1(bufs, defaultEncoding) {
		var b = [];
		var charsProcessed = 0;
		var invalidLE = 0;
		var invalidBE = 0;
		var bmpCharsLE = 0;
		var bmpCharsBE = 0;
		outerLoop: for (var i$3 = 0; i$3 < bufs.length; i$3++) {
			var buf = bufs[i$3];
			for (var j = 0; j < buf.length; j++) {
				b.push(buf[j]);
				if (b.length === 4) {
					if (charsProcessed === 0) {
						if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) return "utf-32le";
						if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) return "utf-32be";
					}
					if (b[0] !== 0 || b[1] > 16) invalidBE++;
					if (b[3] !== 0 || b[2] > 16) invalidLE++;
					if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
					if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
					b.length = 0;
					charsProcessed++;
					if (charsProcessed >= 100) break outerLoop;
				}
			}
		}
		if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
		if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
		return defaultEncoding || "utf-32le";
	}
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer$6 = require_safer().Buffer;
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str$1) {
		var buf = Buffer$6.from(str$1, "ucs2");
		for (var i$3 = 0; i$3 < buf.length; i$3 += 2) {
			var tmp = buf[i$3];
			buf[i$3] = buf[i$3 + 1];
			buf[i$3 + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer$6.alloc(buf.length + 1);
		var i$3 = 0;
		var j = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i$3 = 1;
			j = 2;
		}
		for (; i$3 < buf.length - 1; i$3 += 2, j += 2) {
			buf2[j] = buf[i$3 + 1];
			buf2[j + 1] = buf[i$3];
		}
		this.overflowByte = i$3 == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {
		this.overflowByte = -1;
	};
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str$1) {
		return this.encoder.write(str$1);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBufs = [];
		this.initialBufsLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBufs.push(buf);
			this.initialBufsLen += buf.length;
			if (this.initialBufsLen < 16) return "";
			var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			var trail = this.decoder.end();
			if (trail) resStr += trail;
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.end();
	};
	function detectEncoding(bufs, defaultEncoding) {
		var b = [];
		var charsProcessed = 0;
		var asciiCharsLE = 0;
		var asciiCharsBE = 0;
		outerLoop: for (var i$3 = 0; i$3 < bufs.length; i$3++) {
			var buf = bufs[i$3];
			for (var j = 0; j < buf.length; j++) {
				b.push(buf[j]);
				if (b.length === 2) {
					if (charsProcessed === 0) {
						if (b[0] === 255 && b[1] === 254) return "utf-16le";
						if (b[0] === 254 && b[1] === 255) return "utf-16be";
					}
					if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
					if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
					b.length = 0;
					charsProcessed++;
					if (charsProcessed >= 100) break outerLoop;
				}
			}
		}
		if (asciiCharsBE > asciiCharsLE) return "utf-16be";
		if (asciiCharsBE < asciiCharsLE) return "utf-16le";
		return defaultEncoding || "utf-16le";
	}
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer$5 = require_safer().Buffer;
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str$1) {
		return Buffer$5.from(str$1.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i$2 = 0; i$2 < 256; i$2++) base64Chars[i$2] = base64Regex.test(String.fromCharCode(i$2));
	var plusChar = "+".charCodeAt(0);
	var minusChar = "-".charCodeAt(0);
	var andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res = "";
		var lastI = 0;
		var inBase64 = this.inBase64;
		var base64Accum = this.base64Accum;
		for (var i$3 = 0; i$3 < buf.length; i$3++) if (!inBase64) {
			if (buf[i$3] == plusChar) {
				res += this.iconv.decode(buf.slice(lastI, i$3), "ascii");
				lastI = i$3 + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i$3]]) {
			if (i$3 == lastI && buf[i$3] == minusChar) res += "+";
			else {
				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i$3), "ascii");
				res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i$3] != minusChar) i$3--;
			lastI = i$3 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7Decoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$5.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer$5.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str$1) {
		var inBase64 = this.inBase64;
		var base64Accum = this.base64Accum;
		var base64AccumIdx = this.base64AccumIdx;
		var buf = Buffer$5.alloc(str$1.length * 5 + 10);
		var bufIdx = 0;
		for (var i$3 = 0; i$3 < str$1.length; i$3++) {
			var uChar = str$1.charCodeAt(i$3);
			if (uChar >= 32 && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer$5.alloc(10);
		var bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res = "";
		var lastI = 0;
		var inBase64 = this.inBase64;
		var base64Accum = this.base64Accum;
		for (var i$3 = 0; i$3 < buf.length; i$3++) if (!inBase64) {
			if (buf[i$3] == andChar) {
				res += this.iconv.decode(buf.slice(lastI, i$3), "ascii");
				lastI = i$3 + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i$3]]) {
			if (i$3 == lastI && buf[i$3] == minusChar) res += "&";
			else {
				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i$3), "ascii").replace(/,/g, "/");
				res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i$3] != minusChar) i$3--;
			lastI = i$3 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$5.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer$4 = require_safer().Buffer;
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv$2) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i$3 = 0; i$3 < 128; i$3++) asciiString += String.fromCharCode(i$3);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer$4.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer$4.alloc(65536, iconv$2.defaultCharSingleByte.charCodeAt(0));
		for (var i$3 = 0; i$3 < codecOptions.chars.length; i$3++) encodeBuf[codecOptions.chars.charCodeAt(i$3)] = i$3;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str$1) {
		var buf = Buffer$4.alloc(str$1.length);
		for (var i$3 = 0; i$3 < str$1.length; i$3++) buf[i$3] = this.encodeBuf[str$1.charCodeAt(i$3)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer$4.alloc(buf.length * 2);
		var idx1 = 0;
		var idx2 = 0;
		for (var i$3 = 0; i$3 < buf.length; i$3++) {
			idx1 = buf[i$3] * 2;
			idx2 = i$3 * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		10029: "maccenteuro",
		maccenteuro: {
			type: "_sbcs",
			chars: "\xA0"
		},
		808: "cp808",
		ibm808: "cp808",
		cp808: {
			type: "_sbcs",
			chars: "\xA0"
		},
		mik: {
			type: "_sbcs",
			chars: "\xA0"
		},
		cp720: {
			type: "_sbcs",
			chars: "\xA0"
		},
		ascii8bit: "ascii",
		usascii: "ascii",
		ansix34: "ascii",
		ansix341968: "ascii",
		ansix341986: "ascii",
		csascii: "ascii",
		cp367: "ascii",
		ibm367: "ascii",
		isoir6: "ascii",
		iso646us: "ascii",
		iso646irv: "ascii",
		us: "ascii",
		latin1: "iso88591",
		latin2: "iso88592",
		latin3: "iso88593",
		latin4: "iso88594",
		latin5: "iso88599",
		latin6: "iso885910",
		latin7: "iso885913",
		latin8: "iso885914",
		latin9: "iso885915",
		latin10: "iso885916",
		csisolatin1: "iso88591",
		csisolatin2: "iso88592",
		csisolatin3: "iso88593",
		csisolatin4: "iso88594",
		csisolatincyrillic: "iso88595",
		csisolatinarabic: "iso88596",
		csisolatingreek: "iso88597",
		csisolatinhebrew: "iso88598",
		csisolatin5: "iso88599",
		csisolatin6: "iso885910",
		l1: "iso88591",
		l2: "iso88592",
		l3: "iso88593",
		l4: "iso88594",
		l5: "iso88599",
		l6: "iso885910",
		l7: "iso885913",
		l8: "iso885914",
		l9: "iso885915",
		l10: "iso885916",
		isoir14: "iso646jp",
		isoir57: "iso646cn",
		isoir100: "iso88591",
		isoir101: "iso88592",
		isoir109: "iso88593",
		isoir110: "iso88594",
		isoir144: "iso88595",
		isoir127: "iso88596",
		isoir126: "iso88597",
		isoir138: "iso88598",
		isoir148: "iso88599",
		isoir157: "iso885910",
		isoir166: "tis620",
		isoir179: "iso885913",
		isoir199: "iso885914",
		isoir203: "iso885915",
		isoir226: "iso885916",
		cp819: "iso88591",
		ibm819: "iso88591",
		cyrillic: "iso88595",
		arabic: "iso88596",
		arabic8: "iso88596",
		ecma114: "iso88596",
		asmo708: "iso88596",
		greek: "iso88597",
		greek8: "iso88597",
		ecma118: "iso88597",
		elot928: "iso88597",
		hebrew: "iso88598",
		hebrew8: "iso88598",
		turkish: "iso88599",
		turkish8: "iso88599",
		thai: "iso885911",
		thai8: "iso885911",
		celtic: "iso885914",
		celtic8: "iso885914",
		isoceltic: "iso885914",
		tis6200: "tis620",
		tis62025291: "tis620",
		tis62025330: "tis620",
		1e4: "macroman",
		10006: "macgreek",
		10007: "maccyrillic",
		10079: "maciceland",
		10081: "macturkish",
		cspc8codepage437: "cp437",
		cspc775baltic: "cp775",
		cspc850multilingual: "cp850",
		cspcp852: "cp852",
		cspc862latinhebrew: "cp862",
		cpgr: "cp869",
		msee: "cp1250",
		mscyrl: "cp1251",
		msansi: "cp1252",
		msgreek: "cp1253",
		msturk: "cp1254",
		mshebr: "cp1255",
		msarab: "cp1256",
		winbaltrim: "cp1257",
		cp20866: "koi8r",
		20866: "koi8r",
		ibm878: "koi8r",
		cskoi8r: "koi8r",
		cp21866: "koi8u",
		21866: "koi8u",
		ibm1168: "koi8u",
		strk10482002: "rk1048",
		tcvn5712: "tcvn",
		tcvn57121: "tcvn",
		gb198880: "iso646cn",
		cn: "iso646cn",
		csiso14jisc6220ro: "iso646jp",
		jisc62201969ro: "iso646jp",
		jp: "iso646jp",
		cshproman8: "hproman8",
		r8: "hproman8",
		roman8: "hproman8",
		xroman8: "hproman8",
		ibm1051: "hproman8",
		mac: "macintosh",
		csmacintosh: "macintosh"
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer$3 = require_safer().Buffer;
	exports._dbcs = DBCSCodec;
	var UNASSIGNED = -1;
	var GB18030_CODE = -2;
	var SEQ_START = -10;
	var NODE_START = -1e3;
	var UNASSIGNED_NODE = new Array(256);
	var DEF_CHAR = -1;
	for (var i$1 = 0; i$1 < 256; i$1++) UNASSIGNED_NODE[i$1] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv$2) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i$3 = 0; i$3 < mappingTable.length; i$3++) this._addDecodeChunk(mappingTable[i$3]);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var commonThirdByteNodeIdx = this.decodeTables.length;
			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
			var commonFourthByteNodeIdx = this.decodeTables.length;
			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
			var firstByteNode = this.decodeTables[0];
			for (var i$3 = 129; i$3 <= 254; i$3++) {
				var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i$3]];
				for (var j = 48; j <= 57; j++) {
					if (secondByteNode[j] === UNASSIGNED) secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
					else if (secondByteNode[j] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 2");
					var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
					for (var k = 129; k <= 254; k++) {
						if (thirdByteNode[k] === UNASSIGNED) thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
						else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) continue;
						else if (thirdByteNode[k] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 3");
						var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
						for (var l = 48; l <= 57; l++) if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
					}
				}
			}
		}
		this.defaultCharUnicode = iconv$2.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i$3 = 0; i$3 < codecOptions.encodeSkipVals.length; i$3++) {
			var val = codecOptions.encodeSkipVals[i$3];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv$2.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes$2 = [];
		for (; addr > 0; addr >>>= 8) bytes$2.push(addr & 255);
		if (bytes$2.length == 0) bytes$2.push(0);
		var node = this.decodeTables[0];
		for (var i$3 = bytes$2.length - 1; i$3 > 0; i$3--) {
			var val = node[bytes$2[i$3]];
			if (val == UNASSIGNED) {
				node[bytes$2[i$3]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k = 1; k < chunk.length; k++) {
			var part = chunk[k];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code = part.charCodeAt(l++);
				if (code >= 55296 && code < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (codeTrail >= 56320 && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (code > 4080 && code <= 4095) {
					var len = 4095 - code + 2;
					var seq = [];
					for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node;
		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node = {};
			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node);
		}
		for (var j = 1; j < seq.length - 1; j++) {
			var oldVal = node[uCode];
			if (typeof oldVal === "object") node = oldVal;
			else {
				node = node[uCode] = {};
				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node = this.decodeTables[nodeIdx];
		var hasValues = false;
		var subNodeEmpty = {};
		for (var i$3 = 0; i$3 < 256; i$3++) {
			var uCode = node[i$3];
			var mbCode = prefix + i$3;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) {
				this._setEncodeChar(uCode, mbCode);
				hasValues = true;
			} else if (uCode <= NODE_START) {
				var subNodeIdx = NODE_START - uCode;
				if (!subNodeEmpty[subNodeIdx]) {
					var newPrefix = mbCode << 8 >>> 0;
					if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;
					else subNodeEmpty[subNodeIdx] = true;
				}
			} else if (uCode <= SEQ_START) {
				this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
				hasValues = true;
			}
		}
		return hasValues;
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str$1) {
		var newBuf = Buffer$3.alloc(str$1.length * (this.gb18030 ? 4 : 3));
		var leadSurrogate = this.leadSurrogate;
		var seqObj = this.seqObj;
		var nextChar = -1;
		var i$3 = 0;
		var j = 0;
		while (true) {
			if (nextChar === -1) {
				if (i$3 == str$1.length) break;
				var uCode = str$1.charCodeAt(i$3++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (uCode >= 55296 && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode === "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			} else if (dbcsCode < 16777216) {
				newBuf[j++] = dbcsCode >> 16;
				newBuf[j++] = dbcsCode >> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			} else {
				newBuf[j++] = dbcsCode >>> 24;
				newBuf[j++] = dbcsCode >>> 16 & 255;
				newBuf[j++] = dbcsCode >>> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer$3.alloc(10);
		var j = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBytes = [];
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer$3.alloc(buf.length * 2);
		var nodeIdx = this.nodeIdx;
		var prevBytes = this.prevBytes;
		var prevOffset = this.prevBytes.length;
		var seqStart = -this.prevBytes.length;
		var uCode;
		for (var i$3 = 0, j = 0; i$3 < buf.length; i$3++) {
			var curByte = i$3 >= 0 ? buf[i$3] : prevBytes[i$3 + prevOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
				uCode = this.defaultCharUnicode.charCodeAt(0);
				i$3 = seqStart;
			} else if (uCode === GB18030_CODE) {
				if (i$3 >= 3) var ptr = (buf[i$3 - 3] - 129) * 12600 + (buf[i$3 - 2] - 48) * 1260 + (buf[i$3 - 1] - 129) * 10 + (curByte - 48);
				else var ptr = (prevBytes[i$3 - 3 + prevOffset] - 129) * 12600 + ((i$3 - 2 >= 0 ? buf[i$3 - 2] : prevBytes[i$3 - 2 + prevOffset]) - 48) * 1260 + ((i$3 - 1 >= 0 ? buf[i$3 - 1] : prevBytes[i$3 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k = 0; k < seq.length - 1; k++) {
					uCode = seq[k];
					newBuf[j++] = uCode & 255;
					newBuf[j++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode >= 65536) {
				uCode -= 65536;
				var uCodeLead = 55296 | uCode >> 10;
				newBuf[j++] = uCodeLead & 255;
				newBuf[j++] = uCodeLead >> 8;
				uCode = 56320 | uCode & 1023;
			}
			newBuf[j++] = uCode & 255;
			newBuf[j++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i$3 + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
		return newBuf.slice(0, j).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBytes.length > 0) {
			ret += this.defaultCharUnicode;
			var bytesArr = this.prevBytes.slice(1);
			this.prevBytes = [];
			this.nodeIdx = 0;
			if (bytesArr.length > 0) ret += this.write(bytesArr);
		}
		this.prevBytes = [];
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0;
		var r = table.length;
		while (l < r - 1) {
			var mid = l + (r - l + 1 >> 1);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		["8180", ""],
		["81b8", ""],
		["81c8", ""],
		["81da", ""],
		["81f0", ""],
		["81fc", ""],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		["849f", ""],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		["875f", ""],
		["877e", ""],
		[
			"8780",
			"",
			4,
			""
		],
		["889f", ""],
		["8940", ""],
		["8980", ""],
		["8a40", ""],
		["8a80", ""],
		["8b40", ""],
		["8b80", ""],
		["8c40", ""],
		["8c80", ""],
		["8d40", ""],
		["8d80", ""],
		["8e40", ""],
		["8e80", ""],
		["8f40", ""],
		["8f80", ""],
		["9040", ""],
		["9080", ""],
		["9140", ""],
		["9180", ""],
		["9240", ""],
		["9280", ""],
		["9340", ""],
		["9380", ""],
		["9440", ""],
		["9480", ""],
		["9540", ""],
		["9580", ""],
		["9640", ""],
		["9680", ""],
		["9740", ""],
		["9780", ""],
		["9840", ""],
		["989f", ""],
		["9940", ""],
		["9980", ""],
		["9a40", ""],
		["9a80", ""],
		["9b40", ""],
		["9b80", ""],
		["9c40", ""],
		["9c80", ""],
		["9d40", ""],
		["9d80", ""],
		["9e40", ""],
		["9e80", ""],
		["9f40", ""],
		["9f80", ""],
		["e040", ""],
		["e080", ""],
		["e140", ""],
		["e180", ""],
		["e240", ""],
		["e280", ""],
		["e340", ""],
		["e380", ""],
		["e440", ""],
		["e480", ""],
		["e540", ""],
		["e580", ""],
		["e640", ""],
		["e680", ""],
		["e740", ""],
		["e780", ""],
		["e840", ""],
		["e880", ""],
		["e940", ""],
		["e980", ""],
		["ea40", ""],
		["ea80", ""],
		["ed40", ""],
		["ed80", ""],
		["ee40", ""],
		["ee80", ""],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		["f940", ""],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		["fa80", ""],
		["fb40", ""],
		["fb80", ""],
		["fc40", ""]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		["a2a1", ""],
		["a2ba", ""],
		["a2ca", ""],
		["a2dc", ""],
		["a2f2", ""],
		["a2fe", ""],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		["a8a1", ""],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		["adc0", ""],
		[
			"addf",
			"",
			4,
			""
		],
		["b0a1", ""],
		["b1a1", ""],
		["b2a1", ""],
		["b3a1", ""],
		["b4a1", ""],
		["b5a1", ""],
		["b6a1", ""],
		["b7a1", ""],
		["b8a1", ""],
		["b9a1", ""],
		["baa1", ""],
		["bba1", ""],
		["bca1", ""],
		["bda1", ""],
		["bea1", ""],
		["bfa1", ""],
		["c0a1", ""],
		["c1a1", ""],
		["c2a1", ""],
		["c3a1", ""],
		["c4a1", ""],
		["c5a1", ""],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["c9a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		["d1a1", ""],
		["d2a1", ""],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		[
			"fcf1",
			"",
			9,
			""
		],
		["8fa2af", ""],
		["8fa2c2", ""],
		["8fa2eb", ""],
		["8fa6e1", ""],
		["8fa6e7", ""],
		["8fa6e9", ""],
		["8fa6ec", ""],
		["8fa6f1", ""],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		["8fa9a1", ""],
		["8fa9a4", ""],
		["8fa9a6", ""],
		["8fa9a8", ""],
		["8fa9ab", ""],
		["8fa9af", ""],
		["8fa9c1", ""],
		["8faaa1", ""],
		["8faaba", ""],
		["8faba1", ""],
		["8fabbd", ""],
		["8fabc5", ""],
		["8fb0a1", ""],
		["8fb1a1", ""],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		["8fb3a1", ""],
		["8fb4a1", ""],
		["8fb5a1", ""],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		["8fb8a1", ""],
		["8fb9a1", ""],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		["8fbba1", ""],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		["8fbfa1", ""],
		["8fc0a1", ""],
		["8fc1a1", ""],
		["8fc2a1", ""],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		["8fc4a1", ""],
		["8fc5a1", ""],
		["8fc6a1", ""],
		["8fc7a1", ""],
		["8fc8a1", ""],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		["8fcaa1", ""],
		["8fcba1", ""],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		["8fcfa1", ""],
		["8fd0a1", ""],
		["8fd1a1", ""],
		[
			"8fd2a1",
			"",
			5
		],
		["8fd3a1", ""],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		["8fd5a1", ""],
		["8fd6a1", ""],
		["8fd7a1", ""],
		["8fd8a1", ""],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		["8fdfa1", ""],
		["8fe0a1", ""],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		["8fe2a1", ""],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		["8fe6a1", ""],
		["8fe7a1", ""],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		["8feca1", ""],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		["a6e0", ""],
		["a6ee", ""],
		["a6f4", ""],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		["a8a1", ""],
		["a8bd", ""],
		["a8c0", ""],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		["a959", ""],
		["a95c", ""],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		["a996", ""],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		["af80", ""],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		["c640", ""],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		["c780", ""],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		["cd80", ""],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		["fe40", ""]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		["a2e3", ""],
		["a2ef", ""],
		["a2fd", ""],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		["a6ec", ""],
		["a6f3", ""],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		["a8bc", ""],
		["a8bf", ""],
		["a8c1", ""],
		[
			"a8ea",
			"",
			20
		],
		["a958", ""],
		["a95b", ""],
		["a95d", ""],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		["fe50", ""],
		[
			"fe80",
			"",
			6,
			"",
			93
		],
		["8135f437", ""]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"uChars": [
			128,
			165,
			169,
			178,
			184,
			216,
			226,
			235,
			238,
			244,
			248,
			251,
			253,
			258,
			276,
			284,
			300,
			325,
			329,
			334,
			364,
			463,
			465,
			467,
			469,
			471,
			473,
			475,
			477,
			506,
			594,
			610,
			712,
			716,
			730,
			930,
			938,
			962,
			970,
			1026,
			1104,
			1106,
			8209,
			8215,
			8218,
			8222,
			8231,
			8241,
			8244,
			8246,
			8252,
			8365,
			8452,
			8454,
			8458,
			8471,
			8482,
			8556,
			8570,
			8596,
			8602,
			8713,
			8720,
			8722,
			8726,
			8731,
			8737,
			8740,
			8742,
			8748,
			8751,
			8760,
			8766,
			8777,
			8781,
			8787,
			8802,
			8808,
			8816,
			8854,
			8858,
			8870,
			8896,
			8979,
			9322,
			9372,
			9548,
			9588,
			9616,
			9622,
			9634,
			9652,
			9662,
			9672,
			9676,
			9680,
			9702,
			9735,
			9738,
			9793,
			9795,
			11906,
			11909,
			11913,
			11917,
			11928,
			11944,
			11947,
			11951,
			11956,
			11960,
			11964,
			11979,
			12284,
			12292,
			12312,
			12319,
			12330,
			12351,
			12436,
			12447,
			12535,
			12543,
			12586,
			12842,
			12850,
			12964,
			13200,
			13215,
			13218,
			13253,
			13263,
			13267,
			13270,
			13384,
			13428,
			13727,
			13839,
			13851,
			14617,
			14703,
			14801,
			14816,
			14964,
			15183,
			15471,
			15585,
			16471,
			16736,
			17208,
			17325,
			17330,
			17374,
			17623,
			17997,
			18018,
			18212,
			18218,
			18301,
			18318,
			18760,
			18811,
			18814,
			18820,
			18823,
			18844,
			18848,
			18872,
			19576,
			19620,
			19738,
			19887,
			40870,
			59244,
			59336,
			59367,
			59413,
			59417,
			59423,
			59431,
			59437,
			59443,
			59452,
			59460,
			59478,
			59493,
			63789,
			63866,
			63894,
			63976,
			63986,
			64016,
			64018,
			64021,
			64025,
			64034,
			64037,
			64042,
			65074,
			65093,
			65107,
			65112,
			65127,
			65132,
			65375,
			65510,
			65536
		],
		"gbChars": [
			0,
			36,
			38,
			45,
			50,
			81,
			89,
			95,
			96,
			100,
			103,
			104,
			105,
			109,
			126,
			133,
			148,
			172,
			175,
			179,
			208,
			306,
			307,
			308,
			309,
			310,
			311,
			312,
			313,
			341,
			428,
			443,
			544,
			545,
			558,
			741,
			742,
			749,
			750,
			805,
			819,
			820,
			7922,
			7924,
			7925,
			7927,
			7934,
			7943,
			7944,
			7945,
			7950,
			8062,
			8148,
			8149,
			8152,
			8164,
			8174,
			8236,
			8240,
			8262,
			8264,
			8374,
			8380,
			8381,
			8384,
			8388,
			8390,
			8392,
			8393,
			8394,
			8396,
			8401,
			8406,
			8416,
			8419,
			8424,
			8437,
			8439,
			8445,
			8482,
			8485,
			8496,
			8521,
			8603,
			8936,
			8946,
			9046,
			9050,
			9063,
			9066,
			9076,
			9092,
			9100,
			9108,
			9111,
			9113,
			9131,
			9162,
			9164,
			9218,
			9219,
			11329,
			11331,
			11334,
			11336,
			11346,
			11361,
			11363,
			11366,
			11370,
			11372,
			11375,
			11389,
			11682,
			11686,
			11687,
			11692,
			11694,
			11714,
			11716,
			11723,
			11725,
			11730,
			11736,
			11982,
			11989,
			12102,
			12336,
			12348,
			12350,
			12384,
			12393,
			12395,
			12397,
			12510,
			12553,
			12851,
			12962,
			12973,
			13738,
			13823,
			13919,
			13933,
			14080,
			14298,
			14585,
			14698,
			15583,
			15847,
			16318,
			16434,
			16438,
			16481,
			16729,
			17102,
			17122,
			17315,
			17320,
			17402,
			17418,
			17859,
			17909,
			17911,
			17915,
			17916,
			17936,
			17939,
			17961,
			18664,
			18703,
			18814,
			18962,
			19043,
			33469,
			33470,
			33471,
			33484,
			33485,
			33490,
			33497,
			33501,
			33505,
			33513,
			33520,
			33536,
			33550,
			37845,
			37921,
			37948,
			38029,
			38038,
			38064,
			38065,
			38066,
			38069,
			38075,
			38076,
			38078,
			39108,
			39109,
			39113,
			39114,
			39115,
			39116,
			39265,
			39394,
			189e3
		]
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		["a8a6", ""],
		["a8a8", ""],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f5a1", ""],
		["f6a1", ""],
		["f7a1", ""],
		["f8a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		["fda1", ""]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		["a140", ""],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		["a3e1", ""],
		["a440", ""],
		["a4a1", ""],
		["a540", ""],
		["a5a1", ""],
		["a640", ""],
		["a6a1", ""],
		["a740", ""],
		["a7a1", ""],
		["a840", ""],
		["a8a1", ""],
		["a940", ""],
		["a9a1", ""],
		["aa40", ""],
		["aaa1", ""],
		["ab40", ""],
		["aba1", ""],
		["ac40", ""],
		["aca1", ""],
		["ad40", ""],
		["ada1", ""],
		["ae40", ""],
		["aea1", ""],
		["af40", ""],
		["afa1", ""],
		["b040", ""],
		["b0a1", ""],
		["b140", ""],
		["b1a1", ""],
		["b240", ""],
		["b2a1", ""],
		["b340", ""],
		["b3a1", ""],
		["b440", ""],
		["b4a1", ""],
		["b540", ""],
		["b5a1", ""],
		["b640", ""],
		["b6a1", ""],
		["b740", ""],
		["b7a1", ""],
		["b840", ""],
		["b8a1", ""],
		["b940", ""],
		["b9a1", ""],
		["ba40", ""],
		["baa1", ""],
		["bb40", ""],
		["bba1", ""],
		["bc40", ""],
		["bca1", ""],
		["bd40", ""],
		["bda1", ""],
		["be40", ""],
		["bea1", ""],
		["bf40", ""],
		["bfa1", ""],
		["c040", ""],
		["c0a1", ""],
		["c140", ""],
		["c1a1", ""],
		["c240", ""],
		["c2a1", ""],
		["c340", ""],
		["c3a1", ""],
		["c440", ""],
		["c4a1", ""],
		["c540", ""],
		["c5a1", ""],
		["c640", ""],
		["c940", ""],
		["c9a1", ""],
		["ca40", ""],
		["caa1", ""],
		["cb40", ""],
		["cba1", ""],
		["cc40", ""],
		["cca1", ""],
		["cd40", ""],
		["cda1", ""],
		["ce40", ""],
		["cea1", ""],
		["cf40", ""],
		["cfa1", ""],
		["d040", ""],
		["d0a1", ""],
		["d140", ""],
		["d1a1", ""],
		["d240", ""],
		["d2a1", ""],
		["d340", ""],
		["d3a1", ""],
		["d440", ""],
		["d4a1", ""],
		["d540", ""],
		["d5a1", ""],
		["d640", ""],
		["d6a1", ""],
		["d740", ""],
		["d7a1", ""],
		["d840", ""],
		["d8a1", ""],
		["d940", ""],
		["d9a1", ""],
		["da40", ""],
		["daa1", ""],
		["db40", ""],
		["dba1", ""],
		["dc40", ""],
		["dca1", ""],
		["dd40", ""],
		["dda1", ""],
		["de40", ""],
		["dea1", ""],
		["df40", ""],
		["dfa1", ""],
		["e040", ""],
		["e0a1", ""],
		["e140", ""],
		["e1a1", ""],
		["e240", ""],
		["e2a1", ""],
		["e340", ""],
		["e3a1", ""],
		["e440", ""],
		["e4a1", ""],
		["e540", ""],
		["e5a1", ""],
		["e640", ""],
		["e6a1", ""],
		["e740", ""],
		["e7a1", ""],
		["e840", ""],
		["e8a1", ""],
		["e940", ""],
		["e9a1", ""],
		["ea40", ""],
		["eaa1", ""],
		["eb40", ""],
		["eba1", ""],
		["ec40", ""],
		["eca1", ""],
		["ed40", ""],
		["eda1", ""],
		["ee40", ""],
		["eea1", ""],
		["ef40", ""],
		["efa1", ""],
		["f040", ""],
		["f0a1", ""],
		["f140", ""],
		["f1a1", ""],
		["f240", ""],
		["f2a1", ""],
		["f340", ""],
		["f3a1", ""],
		["f440", ""],
		["f4a1", ""],
		["f540", ""],
		["f5a1", ""],
		["f640", ""],
		["f6a1", ""],
		["f740", ""],
		["f7a1", ""],
		["f840", ""],
		["f8a1", ""],
		["f940", ""],
		["f9a1", ""]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		["8740", ""],
		["8767", ""],
		["87a1", ""],
		[
			"8840",
			"",
			4,
			""
		],
		["88a1", ""],
		["8940", ""],
		["8943", ""],
		["8946", ""],
		["894c", ""],
		["89a1", ""],
		["89ab", ""],
		["89b0", ""],
		["89b5", ""],
		["89c1", ""],
		["89c5", ""],
		["8a40", ""],
		["8a43", ""],
		["8a64", ""],
		["8a76", ""],
		["8aa1", ""],
		["8aac", ""],
		["8ab2", ""],
		["8abb", ""],
		["8ac9", ""],
		["8ace", ""],
		["8adf", ""],
		["8af6", ""],
		["8b40", ""],
		["8b55", ""],
		["8ba1", ""],
		["8bde", ""],
		["8c40", ""],
		["8ca1", ""],
		["8ca7", ""],
		["8cc9", ""],
		["8cce", ""],
		["8ce6", ""],
		["8d40", ""],
		["8d42", ""],
		["8da1", ""],
		["8e40", ""],
		["8ea1", ""],
		["8f40", ""],
		["8fa1", ""],
		["9040", ""],
		["90a1", ""],
		["9140", ""],
		["91a1", ""],
		["9240", ""],
		["92a1", ""],
		["9340", ""],
		["93a1", ""],
		["9440", ""],
		["94a1", ""],
		["9540", ""],
		["95a1", ""],
		["9640", ""],
		["96a1", ""],
		["9740", ""],
		["97a1", ""],
		["9840", ""],
		["98a1", ""],
		["9940", ""],
		["99a1", ""],
		["9a40", ""],
		["9aa1", ""],
		["9b40", ""],
		["9b62", ""],
		["9ba1", ""],
		["9c40", ""],
		["9ca1", ""],
		["9d40", ""],
		["9da1", ""],
		["9e40", ""],
		["9ea1", ""],
		["9ead", ""],
		["9ec5", ""],
		["9ef5", ""],
		["9f40", ""],
		["9f4f", ""],
		["9fa1", ""],
		["9fae", ""],
		["9fb2", ""],
		["9fc1", ""],
		["9fc9", ""],
		["9fdb", ""],
		["9fe7", ""],
		["9feb", ""],
		["9ff0", ""],
		["a040", ""],
		["a055", ""],
		["a058", ""],
		["a05b", ""],
		["a063", ""],
		["a073", ""],
		["a0a1", ""],
		["a0a6", ""],
		["a0ae", ""],
		["a0b0", ""],
		["a0d4", ""],
		["a0e2", ""],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		["c8a1", ""],
		["c8cd", ""],
		["c8f5", ""],
		["f9fe", ""],
		["fa40", ""],
		["faa1", ""],
		["fb40", ""],
		["fba1", ""],
		["fc40", ""],
		["fca1", ""],
		["fd40", ""],
		["fda1", ""],
		["fe40", ""],
		["fea1", ""]
	];
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		shiftjis: {
			type: "_dbcs",
			table: function() {
				return require_shiftjis();
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		csshiftjis: "shiftjis",
		mskanji: "shiftjis",
		sjis: "shiftjis",
		windows31j: "shiftjis",
		ms31j: "shiftjis",
		xsjis: "shiftjis",
		windows932: "shiftjis",
		ms932: "shiftjis",
		932: "shiftjis",
		cp932: "shiftjis",
		eucjp: {
			type: "_dbcs",
			table: function() {
				return require_eucjp();
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		gb2312: "cp936",
		gb231280: "cp936",
		gb23121980: "cp936",
		csgb2312: "cp936",
		csiso58gb231280: "cp936",
		euccn: "cp936",
		windows936: "cp936",
		ms936: "cp936",
		936: "cp936",
		cp936: {
			type: "_dbcs",
			table: function() {
				return require_cp936();
			}
		},
		gbk: {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			}
		},
		xgbk: "gbk",
		isoir58: "gbk",
		gb18030: {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			},
			gb18030: function() {
				return require_gb18030_ranges();
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		chinese: "gb18030",
		windows949: "cp949",
		ms949: "cp949",
		949: "cp949",
		cp949: {
			type: "_dbcs",
			table: function() {
				return require_cp949();
			}
		},
		cseuckr: "cp949",
		csksc56011987: "cp949",
		euckr: "cp949",
		isoir149: "cp949",
		korean: "cp949",
		ksc56011987: "cp949",
		ksc56011989: "cp949",
		ksc5601: "cp949",
		windows950: "cp950",
		ms950: "cp950",
		950: "cp950",
		cp950: {
			type: "_dbcs",
			table: function() {
				return require_cp950();
			}
		},
		big5: "big5hkscs",
		big5hkscs: {
			type: "_dbcs",
			table: function() {
				return require_cp950().concat(require_big5_added());
			},
			encodeSkipVals: [
				36457,
				36463,
				36478,
				36523,
				36532,
				36557,
				36560,
				36695,
				36713,
				36718,
				36811,
				36862,
				36973,
				36986,
				37060,
				37084,
				37105,
				37311,
				37551,
				37552,
				37553,
				37554,
				37585,
				37959,
				38090,
				38361,
				38652,
				39285,
				39798,
				39800,
				39803,
				39878,
				39902,
				39916,
				39926,
				40002,
				40019,
				40034,
				40040,
				40043,
				40055,
				40124,
				40125,
				40144,
				40279,
				40282,
				40388,
				40431,
				40443,
				40617,
				40687,
				40701,
				40800,
				40907,
				41079,
				41180,
				41183,
				36812,
				37576,
				38468,
				38637,
				41636,
				41637,
				41639,
				41638,
				41676,
				41678
			]
		},
		cnbig5: "big5hkscs",
		csbig5: "big5hkscs",
		xxbig5: "big5hkscs"
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js
var require_encodings = /* @__PURE__ */ __commonJSMin(((exports) => {
	var mergeModules$1 = require_merge_exports();
	var modules = [
		require_internal(),
		require_utf32(),
		require_utf16(),
		require_utf7(),
		require_sbcs_codec(),
		require_sbcs_data(),
		require_sbcs_data_generated(),
		require_dbcs_codec(),
		require_dbcs_data()
	];
	for (var i = 0; i < modules.length; i++) {
		var module$1 = modules[i];
		mergeModules$1(exports, module$1);
	}
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js
var require_streams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$2 = require_safer().Buffer;
	module.exports = function(streamModule$1) {
		var Transform = streamModule$1.Transform;
		function IconvLiteEncoderStream(conv, options) {
			this.conv = conv;
			options = options || {};
			options.decodeStrings = false;
			Transform.call(this, options);
		}
		IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
		IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
			if (typeof chunk !== "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
			try {
				var res = this.conv.write(chunk);
				if (res && res.length) this.push(res);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteEncoderStream.prototype._flush = function(done) {
			try {
				var res = this.conv.end();
				if (res && res.length) this.push(res);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteEncoderStream.prototype.collect = function(cb) {
			var chunks = [];
			this.on("error", cb);
			this.on("data", function(chunk) {
				chunks.push(chunk);
			});
			this.on("end", function() {
				cb(null, Buffer$2.concat(chunks));
			});
			return this;
		};
		function IconvLiteDecoderStream(conv, options) {
			this.conv = conv;
			options = options || {};
			options.encoding = this.encoding = "utf8";
			Transform.call(this, options);
		}
		IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
		IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
			if (!Buffer$2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
			try {
				var res = this.conv.write(chunk);
				if (res && res.length) this.push(res, this.encoding);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteDecoderStream.prototype._flush = function(done) {
			try {
				var res = this.conv.end();
				if (res && res.length) this.push(res, this.encoding);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteDecoderStream.prototype.collect = function(cb) {
			var res = "";
			this.on("error", cb);
			this.on("data", function(chunk) {
				res += chunk;
			});
			this.on("end", function() {
				cb(null, res);
			});
			return this;
		};
		return {
			IconvLiteEncoderStream,
			IconvLiteDecoderStream
		};
	};
}));

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$1 = require_safer().Buffer;
	var bomHandling = require_bom_handling();
	var mergeModules = require_merge_exports();
	var iconv$1 = module.exports;
	iconv$1.encodings = null;
	iconv$1.defaultCharUnicode = "";
	iconv$1.defaultCharSingleByte = "?";
	iconv$1.encode = function encode(str$1, encoding, options) {
		str$1 = "" + (str$1 || "");
		var encoder = iconv$1.getEncoder(encoding, options);
		var res = encoder.write(str$1);
		var trail = encoder.end();
		return trail && trail.length > 0 ? Buffer$1.concat([res, trail]) : res;
	};
	iconv$1.decode = function decode(buf, encoding, options) {
		if (typeof buf === "string") {
			if (!iconv$1.skipDecodeWarning) {
				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
				iconv$1.skipDecodeWarning = true;
			}
			buf = Buffer$1.from("" + (buf || ""), "binary");
		}
		var decoder = iconv$1.getDecoder(encoding, options);
		var res = decoder.write(buf);
		var trail = decoder.end();
		return trail ? res + trail : res;
	};
	iconv$1.encodingExists = function encodingExists(enc) {
		try {
			iconv$1.getCodec(enc);
			return true;
		} catch (e) {
			return false;
		}
	};
	iconv$1.toEncoding = iconv$1.encode;
	iconv$1.fromEncoding = iconv$1.decode;
	iconv$1._codecDataCache = { __proto__: null };
	iconv$1.getCodec = function getCodec(encoding) {
		if (!iconv$1.encodings) {
			var raw = require_encodings();
			iconv$1.encodings = { __proto__: null };
			mergeModules(iconv$1.encodings, raw);
		}
		var enc = iconv$1._canonicalizeEncoding(encoding);
		var codecOptions = {};
		while (true) {
			var codec = iconv$1._codecDataCache[enc];
			if (codec) return codec;
			var codecDef = iconv$1.encodings[enc];
			switch (typeof codecDef) {
				case "string":
					enc = codecDef;
					break;
				case "object":
					for (var key$1 in codecDef) codecOptions[key$1] = codecDef[key$1];
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					enc = codecDef.type;
					break;
				case "function":
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					codec = new codecDef(codecOptions, iconv$1);
					iconv$1._codecDataCache[codecOptions.encodingName] = codec;
					return codec;
				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
			}
		}
	};
	iconv$1._canonicalizeEncoding = function(encoding) {
		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	};
	iconv$1.getEncoder = function getEncoder(encoding, options) {
		var codec = iconv$1.getCodec(encoding);
		var encoder = new codec.encoder(options, codec);
		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
		return encoder;
	};
	iconv$1.getDecoder = function getDecoder$1(encoding, options) {
		var codec = iconv$1.getCodec(encoding);
		var decoder = new codec.decoder(options, codec);
		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
		return decoder;
	};
	iconv$1.enableStreamingAPI = function enableStreamingAPI(streamModule$1) {
		if (iconv$1.supportsStreams) return;
		var streams = require_streams()(streamModule$1);
		iconv$1.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
		iconv$1.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
		iconv$1.encodeStream = function encodeStream(encoding, options) {
			return new iconv$1.IconvLiteEncoderStream(iconv$1.getEncoder(encoding, options), options);
		};
		iconv$1.decodeStream = function decodeStream(encoding, options) {
			return new iconv$1.IconvLiteDecoderStream(iconv$1.getDecoder(encoding, options), options);
		};
		iconv$1.supportsStreams = true;
	};
	var streamModule;
	try {
		streamModule = __require("stream");
	} catch (e) {}
	if (streamModule && streamModule.Transform) iconv$1.enableStreamingAPI(streamModule);
	else iconv$1.encodeStream = iconv$1.decodeStream = function() {
		throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
	};
}));

//#endregion
//#region node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js
/*!
* unpipe
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_unpipe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = unpipe$1;
	/**
	* Determine if there are Node.js pipe-like data listeners.
	* @private
	*/
	function hasPipeDataListeners(stream) {
		var listeners = stream.listeners("data");
		for (var i$3 = 0; i$3 < listeners.length; i$3++) if (listeners[i$3].name === "ondata") return true;
		return false;
	}
	/**
	* Unpipe a stream from all destinations.
	*
	* @param {object} stream
	* @public
	*/
	function unpipe$1(stream) {
		if (!stream) throw new TypeError("argument stream is required");
		if (typeof stream.unpipe === "function") {
			stream.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream)) return;
		var listener;
		var listeners = stream.listeners("close");
		for (var i$3 = 0; i$3 < listeners.length; i$3++) {
			listener = listeners[i$3];
			if (listener.name !== "cleanup" && listener.name !== "onclose") continue;
			listener.call(stream);
		}
	}
}));

//#endregion
//#region node_modules/.pnpm/raw-body@3.0.1/node_modules/raw-body/index.js
/*!
* raw-body
* Copyright(c) 2013-2014 Jonathan Ong
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_raw_body = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks();
	var bytes = require_bytes();
	var createError = require_http_errors();
	var iconv = require_lib();
	var unpipe = require_unpipe();
	/**
	* Module exports.
	* @public
	*/
	module.exports = getRawBody$2;
	/**
	* Module variables.
	* @private
	*/
	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
	/**
	* Get the decoder for a given encoding.
	*
	* @param {string} encoding
	* @private
	*/
	function getDecoder(encoding) {
		if (!encoding) return null;
		try {
			return iconv.getDecoder(encoding);
		} catch (e) {
			if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
			throw createError(415, "specified encoding unsupported", {
				encoding,
				type: "encoding.unsupported"
			});
		}
	}
	/**
	* Get the raw body of a stream (typically HTTP).
	*
	* @param {object} stream
	* @param {object|string|function} [options]
	* @param {function} [callback]
	* @public
	*/
	function getRawBody$2(stream, options, callback) {
		var done = callback;
		var opts = options || {};
		if (stream === void 0) throw new TypeError("argument stream is required");
		else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") throw new TypeError("argument stream must be a stream");
		if (options === true || typeof options === "string") opts = { encoding: options };
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (done !== void 0 && typeof done !== "function") throw new TypeError("argument callback must be a function");
		if (!done && !global.Promise) throw new TypeError("argument callback is required");
		var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
		var limit = bytes.parse(opts.limit);
		var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
		if (done) return readStream(stream, encoding, length, limit, wrap(done));
		return new Promise(function executor(resolve$2, reject) {
			readStream(stream, encoding, length, limit, function onRead(err, buf) {
				if (err) return reject(err);
				resolve$2(buf);
			});
		});
	}
	/**
	* Halt a stream.
	*
	* @param {Object} stream
	* @private
	*/
	function halt(stream) {
		unpipe(stream);
		if (typeof stream.pause === "function") stream.pause();
	}
	/**
	* Read the data from the stream.
	*
	* @param {object} stream
	* @param {string} encoding
	* @param {number} length
	* @param {number} limit
	* @param {function} callback
	* @public
	*/
	function readStream(stream, encoding, length, limit, callback) {
		var complete = false;
		var sync = true;
		if (limit !== null && length !== null && length > limit) return done(createError(413, "request entity too large", {
			expected: length,
			length,
			limit,
			type: "entity.too.large"
		}));
		var state = stream._readableState;
		if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, "stream encoding should not be set", { type: "stream.encoding.set" }));
		if (typeof stream.readable !== "undefined" && !stream.readable) return done(createError(500, "stream is not readable", { type: "stream.not.readable" }));
		var received = 0;
		var decoder;
		try {
			decoder = getDecoder(encoding);
		} catch (err) {
			return done(err);
		}
		var buffer$1 = decoder ? "" : [];
		stream.on("aborted", onAborted);
		stream.on("close", cleanup);
		stream.on("data", onData);
		stream.on("end", onEnd);
		stream.on("error", onEnd);
		sync = false;
		function done() {
			var args = new Array(arguments.length);
			for (var i$3 = 0; i$3 < args.length; i$3++) args[i$3] = arguments[i$3];
			complete = true;
			if (sync) process.nextTick(invokeCallback);
			else invokeCallback();
			function invokeCallback() {
				cleanup();
				if (args[0]) halt(stream);
				callback.apply(null, args);
			}
		}
		function onAborted() {
			if (complete) return;
			done(createError(400, "request aborted", {
				code: "ECONNABORTED",
				expected: length,
				length,
				received,
				type: "request.aborted"
			}));
		}
		function onData(chunk) {
			if (complete) return;
			received += chunk.length;
			if (limit !== null && received > limit) done(createError(413, "request entity too large", {
				limit,
				received,
				type: "entity.too.large"
			}));
			else if (decoder) buffer$1 += decoder.write(chunk);
			else buffer$1.push(chunk);
		}
		function onEnd(err) {
			if (complete) return;
			if (err) return done(err);
			if (length !== null && received !== length) done(createError(400, "request size did not match content length", {
				expected: length,
				length,
				received,
				type: "request.size.invalid"
			}));
			else done(null, decoder ? buffer$1 + (decoder.end() || "") : Buffer.concat(buffer$1));
		}
		function cleanup() {
			buffer$1 = null;
			stream.removeListener("aborted", onAborted);
			stream.removeListener("data", onData);
			stream.removeListener("end", onEnd);
			stream.removeListener("error", onEnd);
			stream.removeListener("close", cleanup);
		}
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks() {
		try {
			return __require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
}));

//#endregion
//#region node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js
/*!
* content-type
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_content_type = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	*
	* parameter     = token "=" ( token / quoted-string )
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	* quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	* qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	* obs-text      = %x80-FF
	* quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	*/
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
	/**
	* RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	*
	* quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	* obs-text    = %x80-FF
	*/
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
	/**
	* RegExp to match type in RFC 7231 sec 3.1.1.1
	*
	* media-type = type "/" subtype
	* type       = token
	* subtype    = token
	*/
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	exports.parse = parse$1;
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @public
	*/
	function parse$1(string$2) {
		if (!string$2) throw new TypeError("argument string is required");
		var header = typeof string$2 === "object" ? getcontenttype(string$2) : string$2;
		if (typeof header !== "string") throw new TypeError("argument string is required to be a string");
		var index = header.indexOf(";");
		var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
		if (!TYPE_REGEXP.test(type)) throw new TypeError("invalid media type");
		var obj = new ContentType(type.toLowerCase());
		if (index !== -1) {
			var key$1;
			var match;
			var value;
			PARAM_REGEXP.lastIndex = index;
			while (match = PARAM_REGEXP.exec(header)) {
				if (match.index !== index) throw new TypeError("invalid parameter format");
				index += match[0].length;
				key$1 = match[1].toLowerCase();
				value = match[2];
				if (value.charCodeAt(0) === 34) {
					value = value.slice(1, -1);
					if (value.indexOf("\\") !== -1) value = value.replace(QESC_REGEXP, "$1");
				}
				obj.parameters[key$1] = value;
			}
			if (index !== header.length) throw new TypeError("invalid parameter format");
		}
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @private
	*/
	function getcontenttype(obj) {
		var header;
		if (typeof obj.getHeader === "function") header = obj.getHeader("content-type");
		else if (typeof obj.headers === "object") header = obj.headers && obj.headers["content-type"];
		if (typeof header !== "string") throw new TypeError("content-type header is missing from object");
		return header;
	}
	/**
	* Class to represent a content type.
	* @private
	*/
	function ContentType(type) {
		this.parameters = Object.create(null);
		this.type = type;
	}
}));

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/server/sse.js
var import_raw_body$1 = /* @__PURE__ */ __toESM(require_raw_body(), 1);
var import_content_type$1 = /* @__PURE__ */ __toESM(require_content_type(), 1);
const MAXIMUM_MESSAGE_SIZE$1 = "4mb";
/**
* Server transport for SSE: this will send messages over an SSE connection and receive messages from HTTP POST requests.
*
* This transport is only available in Node.js environments.
* @deprecated SSEServerTransport is deprecated. Use StreamableHTTPServerTransport instead.
*/
var SSEServerTransport = class {
	/**
	* Creates a new SSE server transport, which will direct the client to POST messages to the relative or absolute URL identified by `_endpoint`.
	*/
	constructor(_endpoint, res, options) {
		this._endpoint = _endpoint;
		this.res = res;
		this._sessionId = randomUUID();
		this._options = options || { enableDnsRebindingProtection: false };
	}
	/**
	* Validates request headers for DNS rebinding protection.
	* @returns Error message if validation fails, undefined if validation passes.
	*/
	validateRequestHeaders(req) {
		if (!this._options.enableDnsRebindingProtection) return;
		if (this._options.allowedHosts && this._options.allowedHosts.length > 0) {
			const hostHeader = req.headers.host;
			if (!hostHeader || !this._options.allowedHosts.includes(hostHeader)) return `Invalid Host header: ${hostHeader}`;
		}
		if (this._options.allowedOrigins && this._options.allowedOrigins.length > 0) {
			const originHeader = req.headers.origin;
			if (originHeader && !this._options.allowedOrigins.includes(originHeader)) return `Invalid Origin header: ${originHeader}`;
		}
	}
	/**
	* Handles the initial SSE connection request.
	*
	* This should be called when a GET request is made to establish the SSE stream.
	*/
	async start() {
		if (this._sseResponse) throw new Error("SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.");
		this.res.writeHead(200, {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache, no-transform",
			Connection: "keep-alive"
		});
		const endpointUrl = new URL$1(this._endpoint, "http://localhost");
		endpointUrl.searchParams.set("sessionId", this._sessionId);
		const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;
		this.res.write(`event: endpoint\ndata: ${relativeUrlWithSession}\n\n`);
		this._sseResponse = this.res;
		this.res.on("close", () => {
			var _a;
			this._sseResponse = void 0;
			(_a = this.onclose) === null || _a === void 0 || _a.call(this);
		});
	}
	/**
	* Handles incoming POST messages.
	*
	* This should be called when a POST request is made to send a message to the server.
	*/
	async handlePostMessage(req, res, parsedBody) {
		var _a, _b, _c, _d;
		if (!this._sseResponse) {
			const message = "SSE connection not established";
			res.writeHead(500).end(message);
			throw new Error(message);
		}
		const validationError = this.validateRequestHeaders(req);
		if (validationError) {
			res.writeHead(403).end(validationError);
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, new Error(validationError));
			return;
		}
		const authInfo = req.auth;
		const requestInfo = { headers: req.headers };
		let body;
		try {
			const ct = import_content_type$1.parse((_b = req.headers["content-type"]) !== null && _b !== void 0 ? _b : "");
			if (ct.type !== "application/json") throw new Error(`Unsupported content-type: ${ct.type}`);
			body = parsedBody !== null && parsedBody !== void 0 ? parsedBody : await (0, import_raw_body$1.default)(req, {
				limit: MAXIMUM_MESSAGE_SIZE$1,
				encoding: (_c = ct.parameters.charset) !== null && _c !== void 0 ? _c : "utf-8"
			});
		} catch (error$1) {
			res.writeHead(400).end(String(error$1));
			(_d = this.onerror) === null || _d === void 0 || _d.call(this, error$1);
			return;
		}
		try {
			await this.handleMessage(typeof body === "string" ? JSON.parse(body) : body, {
				requestInfo,
				authInfo
			});
		} catch (_e) {
			res.writeHead(400).end(`Invalid message: ${body}`);
			return;
		}
		res.writeHead(202).end("Accepted");
	}
	/**
	* Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.
	*/
	async handleMessage(message, extra) {
		var _a, _b;
		let parsedMessage;
		try {
			parsedMessage = JSONRPCMessageSchema.parse(message);
		} catch (error$1) {
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, error$1);
			throw error$1;
		}
		(_b = this.onmessage) === null || _b === void 0 || _b.call(this, parsedMessage, extra);
	}
	async close() {
		var _a, _b;
		(_a = this._sseResponse) === null || _a === void 0 || _a.end();
		this._sseResponse = void 0;
		(_b = this.onclose) === null || _b === void 0 || _b.call(this);
	}
	async send(message) {
		if (!this._sseResponse) throw new Error("Not connected");
		this._sseResponse.write(`event: message\ndata: ${JSON.stringify(message)}\n\n`);
	}
	/**
	* Returns the session ID for this transport.
	*
	* This can be used to route incoming POST requests.
	*/
	get sessionId() {
		return this._sessionId;
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/server/streamableHttp.js
var import_raw_body = /* @__PURE__ */ __toESM(require_raw_body(), 1);
var import_content_type = /* @__PURE__ */ __toESM(require_content_type(), 1);
const MAXIMUM_MESSAGE_SIZE = "4mb";
/**
* Server transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.
* It supports both SSE streaming and direct HTTP responses.
*
* Usage example:
*
* ```typescript
* // Stateful mode - server sets the session ID
* const statefulTransport = new StreamableHTTPServerTransport({
*   sessionIdGenerator: () => randomUUID(),
* });
*
* // Stateless mode - explicitly set session ID to undefined
* const statelessTransport = new StreamableHTTPServerTransport({
*   sessionIdGenerator: undefined,
* });
*
* // Using with pre-parsed request body
* app.post('/mcp', (req, res) => {
*   transport.handleRequest(req, res, req.body);
* });
* ```
*
* In stateful mode:
* - Session ID is generated and included in response headers
* - Session ID is always included in initialization responses
* - Requests with invalid session IDs are rejected with 404 Not Found
* - Non-initialization requests without a session ID are rejected with 400 Bad Request
* - State is maintained in-memory (connections, message history)
*
* In stateless mode:
* - No Session ID is included in any responses
* - No session validation is performed
*/
var StreamableHTTPServerTransport = class {
	constructor(options) {
		var _a, _b;
		this._started = false;
		this._streamMapping = /* @__PURE__ */ new Map();
		this._requestToStreamMapping = /* @__PURE__ */ new Map();
		this._requestResponseMap = /* @__PURE__ */ new Map();
		this._initialized = false;
		this._enableJsonResponse = false;
		this._standaloneSseStreamId = "_GET_stream";
		this.sessionIdGenerator = options.sessionIdGenerator;
		this._enableJsonResponse = (_a = options.enableJsonResponse) !== null && _a !== void 0 ? _a : false;
		this._eventStore = options.eventStore;
		this._onsessioninitialized = options.onsessioninitialized;
		this._onsessionclosed = options.onsessionclosed;
		this._allowedHosts = options.allowedHosts;
		this._allowedOrigins = options.allowedOrigins;
		this._enableDnsRebindingProtection = (_b = options.enableDnsRebindingProtection) !== null && _b !== void 0 ? _b : false;
		this._retryInterval = options.retryInterval;
	}
	/**
	* Starts the transport. This is required by the Transport interface but is a no-op
	* for the Streamable HTTP transport as connections are managed per-request.
	*/
	async start() {
		if (this._started) throw new Error("Transport already started");
		this._started = true;
	}
	/**
	* Validates request headers for DNS rebinding protection.
	* @returns Error message if validation fails, undefined if validation passes.
	*/
	validateRequestHeaders(req) {
		if (!this._enableDnsRebindingProtection) return;
		if (this._allowedHosts && this._allowedHosts.length > 0) {
			const hostHeader = req.headers.host;
			if (!hostHeader || !this._allowedHosts.includes(hostHeader)) return `Invalid Host header: ${hostHeader}`;
		}
		if (this._allowedOrigins && this._allowedOrigins.length > 0) {
			const originHeader = req.headers.origin;
			if (originHeader && !this._allowedOrigins.includes(originHeader)) return `Invalid Origin header: ${originHeader}`;
		}
	}
	/**
	* Handles an incoming HTTP request, whether GET or POST
	*/
	async handleRequest(req, res, parsedBody) {
		var _a;
		const validationError = this.validateRequestHeaders(req);
		if (validationError) {
			res.writeHead(403).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: validationError
				},
				id: null
			}));
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, new Error(validationError));
			return;
		}
		if (req.method === "POST") await this.handlePostRequest(req, res, parsedBody);
		else if (req.method === "GET") await this.handleGetRequest(req, res);
		else if (req.method === "DELETE") await this.handleDeleteRequest(req, res);
		else await this.handleUnsupportedRequest(res);
	}
	/**
	* Writes a priming event to establish resumption capability.
	* Only sends if eventStore is configured (opt-in for resumability) and
	* the client's protocol version supports empty SSE data (>= 2025-11-25).
	*/
	async _maybeWritePrimingEvent(res, streamId, protocolVersion) {
		if (!this._eventStore) return;
		if (protocolVersion < "2025-11-25") return;
		const primingEventId = await this._eventStore.storeEvent(streamId, {});
		let primingEvent = `id: ${primingEventId}\ndata: \n\n`;
		if (this._retryInterval !== void 0) primingEvent = `id: ${primingEventId}\nretry: ${this._retryInterval}\ndata: \n\n`;
		res.write(primingEvent);
	}
	/**
	* Handles GET requests for SSE stream
	*/
	async handleGetRequest(req, res) {
		const acceptHeader = req.headers.accept;
		if (!(acceptHeader === null || acceptHeader === void 0 ? void 0 : acceptHeader.includes("text/event-stream"))) {
			res.writeHead(406).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Not Acceptable: Client must accept text/event-stream"
				},
				id: null
			}));
			return;
		}
		if (!this.validateSession(req, res)) return;
		if (!this.validateProtocolVersion(req, res)) return;
		if (this._eventStore) {
			const lastEventId = req.headers["last-event-id"];
			if (lastEventId) {
				await this.replayEvents(lastEventId, res);
				return;
			}
		}
		const headers = {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache, no-transform",
			Connection: "keep-alive"
		};
		if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
		if (this._streamMapping.get(this._standaloneSseStreamId) !== void 0) {
			res.writeHead(409).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Conflict: Only one SSE stream is allowed per session"
				},
				id: null
			}));
			return;
		}
		res.writeHead(200, headers).flushHeaders();
		this._streamMapping.set(this._standaloneSseStreamId, res);
		res.on("close", () => {
			this._streamMapping.delete(this._standaloneSseStreamId);
		});
		res.on("error", (error$1) => {
			var _a;
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, error$1);
		});
	}
	/**
	* Replays events that would have been sent after the specified event ID
	* Only used when resumability is enabled
	*/
	async replayEvents(lastEventId, res) {
		var _a;
		if (!this._eventStore) return;
		try {
			let streamId;
			if (this._eventStore.getStreamIdForEventId) {
				streamId = await this._eventStore.getStreamIdForEventId(lastEventId);
				if (!streamId) {
					res.writeHead(400).end(JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32e3,
							message: "Invalid event ID format"
						},
						id: null
					}));
					return;
				}
				if (this._streamMapping.get(streamId) !== void 0) {
					res.writeHead(409).end(JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32e3,
							message: "Conflict: Stream already has an active connection"
						},
						id: null
					}));
					return;
				}
			}
			const headers = {
				"Content-Type": "text/event-stream",
				"Cache-Control": "no-cache, no-transform",
				Connection: "keep-alive"
			};
			if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
			res.writeHead(200, headers).flushHeaders();
			const replayedStreamId = await this._eventStore.replayEventsAfter(lastEventId, { send: async (eventId, message) => {
				var _a$1;
				if (!this.writeSSEEvent(res, message, eventId)) {
					(_a$1 = this.onerror) === null || _a$1 === void 0 || _a$1.call(this, /* @__PURE__ */ new Error("Failed replay events"));
					res.end();
				}
			} });
			this._streamMapping.set(replayedStreamId, res);
			res.on("close", () => {
				this._streamMapping.delete(replayedStreamId);
			});
			res.on("error", (error$1) => {
				var _a$1;
				(_a$1 = this.onerror) === null || _a$1 === void 0 || _a$1.call(this, error$1);
			});
		} catch (error$1) {
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, error$1);
		}
	}
	/**
	* Writes an event to the SSE stream with proper formatting
	*/
	writeSSEEvent(res, message, eventId) {
		let eventData = `event: message\n`;
		if (eventId) eventData += `id: ${eventId}\n`;
		eventData += `data: ${JSON.stringify(message)}\n\n`;
		return res.write(eventData);
	}
	/**
	* Handles unsupported requests (PUT, PATCH, etc.)
	*/
	async handleUnsupportedRequest(res) {
		res.writeHead(405, { Allow: "GET, POST, DELETE" }).end(JSON.stringify({
			jsonrpc: "2.0",
			error: {
				code: -32e3,
				message: "Method not allowed."
			},
			id: null
		}));
	}
	/**
	* Handles POST requests containing JSON-RPC messages
	*/
	async handlePostRequest(req, res, parsedBody) {
		var _a, _b, _c, _d, _e, _f;
		try {
			const acceptHeader = req.headers.accept;
			if (!(acceptHeader === null || acceptHeader === void 0 ? void 0 : acceptHeader.includes("application/json")) || !acceptHeader.includes("text/event-stream")) {
				res.writeHead(406).end(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32e3,
						message: "Not Acceptable: Client must accept both application/json and text/event-stream"
					},
					id: null
				}));
				return;
			}
			const ct = req.headers["content-type"];
			if (!ct || !ct.includes("application/json")) {
				res.writeHead(415).end(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32e3,
						message: "Unsupported Media Type: Content-Type must be application/json"
					},
					id: null
				}));
				return;
			}
			const authInfo = req.auth;
			const requestInfo = { headers: req.headers };
			let rawMessage;
			if (parsedBody !== void 0) rawMessage = parsedBody;
			else {
				const body = await (0, import_raw_body.default)(req, {
					limit: MAXIMUM_MESSAGE_SIZE,
					encoding: (_a = import_content_type.parse(ct).parameters.charset) !== null && _a !== void 0 ? _a : "utf-8"
				});
				rawMessage = JSON.parse(body.toString());
			}
			let messages;
			if (Array.isArray(rawMessage)) messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
			else messages = [JSONRPCMessageSchema.parse(rawMessage)];
			const isInitializationRequest = messages.some(isInitializeRequest);
			if (isInitializationRequest) {
				if (this._initialized && this.sessionId !== void 0) {
					res.writeHead(400).end(JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32600,
							message: "Invalid Request: Server already initialized"
						},
						id: null
					}));
					return;
				}
				if (messages.length > 1) {
					res.writeHead(400).end(JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32600,
							message: "Invalid Request: Only one initialization request is allowed"
						},
						id: null
					}));
					return;
				}
				this.sessionId = (_b = this.sessionIdGenerator) === null || _b === void 0 ? void 0 : _b.call(this);
				this._initialized = true;
				if (this.sessionId && this._onsessioninitialized) await Promise.resolve(this._onsessioninitialized(this.sessionId));
			}
			if (!isInitializationRequest) {
				if (!this.validateSession(req, res)) return;
				if (!this.validateProtocolVersion(req, res)) return;
			}
			const hasRequests = messages.some(isJSONRPCRequest);
			if (!hasRequests) {
				res.writeHead(202).end();
				for (const message of messages) (_c = this.onmessage) === null || _c === void 0 || _c.call(this, message, {
					authInfo,
					requestInfo
				});
			} else if (hasRequests) {
				const streamId = randomUUID();
				const initRequest = messages.find((m) => isInitializeRequest(m));
				const clientProtocolVersion = initRequest ? initRequest.params.protocolVersion : (_d = req.headers["mcp-protocol-version"]) !== null && _d !== void 0 ? _d : DEFAULT_NEGOTIATED_PROTOCOL_VERSION;
				if (!this._enableJsonResponse) {
					const headers = {
						"Content-Type": "text/event-stream",
						"Cache-Control": "no-cache",
						Connection: "keep-alive"
					};
					if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
					res.writeHead(200, headers);
					await this._maybeWritePrimingEvent(res, streamId, clientProtocolVersion);
				}
				for (const message of messages) if (isJSONRPCRequest(message)) {
					this._streamMapping.set(streamId, res);
					this._requestToStreamMapping.set(message.id, streamId);
				}
				res.on("close", () => {
					this._streamMapping.delete(streamId);
				});
				res.on("error", (error$1) => {
					var _a$1;
					(_a$1 = this.onerror) === null || _a$1 === void 0 || _a$1.call(this, error$1);
				});
				for (const message of messages) {
					let closeSSEStream;
					let closeStandaloneSSEStream;
					if (isJSONRPCRequest(message) && this._eventStore && clientProtocolVersion >= "2025-11-25") {
						closeSSEStream = () => {
							this.closeSSEStream(message.id);
						};
						closeStandaloneSSEStream = () => {
							this.closeStandaloneSSEStream();
						};
					}
					(_e = this.onmessage) === null || _e === void 0 || _e.call(this, message, {
						authInfo,
						requestInfo,
						closeSSEStream,
						closeStandaloneSSEStream
					});
				}
			}
		} catch (error$1) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32700,
					message: "Parse error",
					data: String(error$1)
				},
				id: null
			}));
			(_f = this.onerror) === null || _f === void 0 || _f.call(this, error$1);
		}
	}
	/**
	* Handles DELETE requests to terminate sessions
	*/
	async handleDeleteRequest(req, res) {
		var _a;
		if (!this.validateSession(req, res)) return;
		if (!this.validateProtocolVersion(req, res)) return;
		await Promise.resolve((_a = this._onsessionclosed) === null || _a === void 0 ? void 0 : _a.call(this, this.sessionId));
		await this.close();
		res.writeHead(200).end();
	}
	/**
	* Validates session ID for non-initialization requests
	* Returns true if the session is valid, false otherwise
	*/
	validateSession(req, res) {
		if (this.sessionIdGenerator === void 0) return true;
		if (!this._initialized) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Bad Request: Server not initialized"
				},
				id: null
			}));
			return false;
		}
		const sessionId = req.headers["mcp-session-id"];
		if (!sessionId) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Bad Request: Mcp-Session-Id header is required"
				},
				id: null
			}));
			return false;
		} else if (Array.isArray(sessionId)) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Bad Request: Mcp-Session-Id header must be a single value"
				},
				id: null
			}));
			return false;
		} else if (sessionId !== this.sessionId) {
			res.writeHead(404).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32001,
					message: "Session not found"
				},
				id: null
			}));
			return false;
		}
		return true;
	}
	validateProtocolVersion(req, res) {
		var _a;
		let protocolVersion = (_a = req.headers["mcp-protocol-version"]) !== null && _a !== void 0 ? _a : DEFAULT_NEGOTIATED_PROTOCOL_VERSION;
		if (Array.isArray(protocolVersion)) protocolVersion = protocolVersion[protocolVersion.length - 1];
		if (!SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: `Bad Request: Unsupported protocol version (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(", ")})`
				},
				id: null
			}));
			return false;
		}
		return true;
	}
	async close() {
		var _a;
		this._streamMapping.forEach((response) => {
			response.end();
		});
		this._streamMapping.clear();
		this._requestResponseMap.clear();
		(_a = this.onclose) === null || _a === void 0 || _a.call(this);
	}
	/**
	* Close an SSE stream for a specific request, triggering client reconnection.
	* Use this to implement polling behavior during long-running operations -
	* client will reconnect after the retry interval specified in the priming event.
	*/
	closeSSEStream(requestId) {
		const streamId = this._requestToStreamMapping.get(requestId);
		if (!streamId) return;
		const stream = this._streamMapping.get(streamId);
		if (stream) {
			stream.end();
			this._streamMapping.delete(streamId);
		}
	}
	/**
	* Close the standalone GET SSE stream, triggering client reconnection.
	* Use this to implement polling behavior for server-initiated notifications.
	*/
	closeStandaloneSSEStream() {
		const stream = this._streamMapping.get(this._standaloneSseStreamId);
		if (stream) {
			stream.end();
			this._streamMapping.delete(this._standaloneSseStreamId);
		}
	}
	async send(message, options) {
		let requestId = options === null || options === void 0 ? void 0 : options.relatedRequestId;
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) requestId = message.id;
		if (requestId === void 0) {
			if (isJSONRPCResponse(message) || isJSONRPCError(message)) throw new Error("Cannot send a response on a standalone SSE stream unless resuming a previous client request");
			let eventId;
			if (this._eventStore) eventId = await this._eventStore.storeEvent(this._standaloneSseStreamId, message);
			const standaloneSse = this._streamMapping.get(this._standaloneSseStreamId);
			if (standaloneSse === void 0) return;
			this.writeSSEEvent(standaloneSse, message, eventId);
			return;
		}
		const streamId = this._requestToStreamMapping.get(requestId);
		const response = this._streamMapping.get(streamId);
		if (!streamId) throw new Error(`No connection established for request ID: ${String(requestId)}`);
		if (!this._enableJsonResponse) {
			let eventId;
			if (this._eventStore) eventId = await this._eventStore.storeEvent(streamId, message);
			if (response) this.writeSSEEvent(response, message, eventId);
		}
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
			this._requestResponseMap.set(requestId, message);
			const relatedIds = Array.from(this._requestToStreamMapping.entries()).filter(([_$1, streamId$1]) => this._streamMapping.get(streamId$1) === response).map(([id]) => id);
			if (relatedIds.every((id) => this._requestResponseMap.has(id))) {
				if (!response) throw new Error(`No connection established for request ID: ${String(requestId)}`);
				if (this._enableJsonResponse) {
					const headers = { "Content-Type": "application/json" };
					if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
					const responses = relatedIds.map((id) => this._requestResponseMap.get(id));
					response.writeHead(200, headers);
					if (responses.length === 1) response.end(JSON.stringify(responses[0]));
					else response.end(JSON.stringify(responses));
				} else response.end();
				for (const id of relatedIds) {
					this._requestResponseMap.delete(id);
					this._requestToStreamMapping.delete(id);
				}
			}
		}
	}
};

//#endregion
//#region src/startHTTPServer.ts
const getBody = (request) => {
	return new Promise((resolve$2) => {
		const bodyParts = [];
		let body;
		request.on("data", (chunk) => {
			bodyParts.push(chunk);
		}).on("end", () => {
			body = Buffer.concat(bodyParts).toString();
			try {
				resolve$2(JSON.parse(body));
			} catch (error$1) {
				console.error("[mcp-proxy] error parsing body", error$1);
				resolve$2(null);
			}
		});
	});
};
const createJsonRpcErrorResponse = (code, message) => {
	return JSON.stringify({
		error: {
			code,
			message
		},
		id: null,
		jsonrpc: "2.0"
	});
};
const getWWWAuthenticateHeader = (oauth, options) => {
	if (!oauth) return;
	const params = [];
	if (oauth.realm) params.push(`realm="${oauth.realm}"`);
	if (oauth.protectedResource?.resource) params.push(`resource_metadata="${oauth.protectedResource.resource}/.well-known/oauth-protected-resource"`);
	const error$1 = options?.error || oauth.error;
	if (error$1) params.push(`error="${error$1}"`);
	const error_description = options?.error_description || oauth.error_description;
	if (error_description) {
		const escaped = error_description.replace(/"/g, "\\\"");
		params.push(`error_description="${escaped}"`);
	}
	const error_uri = options?.error_uri || oauth.error_uri;
	if (error_uri) params.push(`error_uri="${error_uri}"`);
	const scope = options?.scope || oauth.scope;
	if (scope) params.push(`scope="${scope}"`);
	if (params.length === 0) return;
	return `Bearer ${params.join(", ")}`;
};
const isScopeChallengeError = (error$1) => {
	return typeof error$1 === "object" && error$1 !== null && "name" in error$1 && error$1.name === "InsufficientScopeError" && "data" in error$1 && typeof error$1.data === "object" && error$1.data !== null && "error" in error$1.data && error$1.data.error === "insufficient_scope";
};
const handleResponseError = async (error$1, res) => {
	if (error$1 && typeof error$1 === "object" && "status" in error$1 && "headers" in error$1 && "statusText" in error$1 || error$1 instanceof Response) {
		const responseError = error$1;
		const fixedHeaders = {};
		responseError.headers.forEach((value, key$1) => {
			if (fixedHeaders[key$1]) if (Array.isArray(fixedHeaders[key$1])) fixedHeaders[key$1].push(value);
			else fixedHeaders[key$1] = [fixedHeaders[key$1], value];
			else fixedHeaders[key$1] = value;
		});
		const body = await responseError.text();
		res.writeHead(responseError.status, responseError.statusText, fixedHeaders);
		res.end(body);
		return true;
	}
	return false;
};
const cleanupServer = async (server, onClose) => {
	if (onClose) await onClose(server);
	try {
		await server.close();
	} catch (error$1) {
		console.error("[mcp-proxy] error closing server", error$1);
	}
};
const applyCorsHeaders = (req, res, corsOptions) => {
	if (!req.headers.origin) return;
	const defaultCorsOptions = {
		allowedHeaders: "Content-Type, Authorization, Accept, Mcp-Session-Id, Last-Event-Id",
		credentials: true,
		exposedHeaders: ["Mcp-Session-Id"],
		methods: [
			"GET",
			"POST",
			"OPTIONS"
		],
		origin: "*"
	};
	let finalCorsOptions;
	if (corsOptions === false) return;
	else if (corsOptions === true || corsOptions === void 0) finalCorsOptions = defaultCorsOptions;
	else finalCorsOptions = {
		...defaultCorsOptions,
		...corsOptions
	};
	try {
		const origin = new URL(req.headers.origin);
		let allowedOrigin = "*";
		if (finalCorsOptions.origin) {
			if (typeof finalCorsOptions.origin === "string") allowedOrigin = finalCorsOptions.origin;
			else if (Array.isArray(finalCorsOptions.origin)) allowedOrigin = finalCorsOptions.origin.includes(origin.origin) ? origin.origin : "false";
			else if (typeof finalCorsOptions.origin === "function") allowedOrigin = finalCorsOptions.origin(origin.origin) ? origin.origin : "false";
		}
		if (allowedOrigin !== "false") res.setHeader("Access-Control-Allow-Origin", allowedOrigin);
		if (finalCorsOptions.credentials !== void 0) res.setHeader("Access-Control-Allow-Credentials", finalCorsOptions.credentials.toString());
		if (finalCorsOptions.methods) res.setHeader("Access-Control-Allow-Methods", finalCorsOptions.methods.join(", "));
		if (finalCorsOptions.allowedHeaders) {
			const allowedHeaders = typeof finalCorsOptions.allowedHeaders === "string" ? finalCorsOptions.allowedHeaders : finalCorsOptions.allowedHeaders.join(", ");
			res.setHeader("Access-Control-Allow-Headers", allowedHeaders);
		}
		if (finalCorsOptions.exposedHeaders) res.setHeader("Access-Control-Expose-Headers", finalCorsOptions.exposedHeaders.join(", "));
		if (finalCorsOptions.maxAge !== void 0) res.setHeader("Access-Control-Max-Age", finalCorsOptions.maxAge.toString());
	} catch (error$1) {
		console.error("[mcp-proxy] error parsing origin", error$1);
	}
};
const handleStreamRequest = async ({ activeTransports, authenticate, authMiddleware, createServer, enableJsonResponse, endpoint, eventStore, oauth, onClose, onConnect, req, res, stateless }) => {
	if (req.method === "POST" && new URL(req.url, "http://localhost").pathname === endpoint) {
		let body;
		try {
			const sessionId = Array.isArray(req.headers["mcp-session-id"]) ? req.headers["mcp-session-id"][0] : req.headers["mcp-session-id"];
			let transport;
			let server;
			body = await getBody(req);
			if (stateless && authenticate) try {
				const authResult = await authenticate(req);
				if (!authResult || typeof authResult === "object" && "authenticated" in authResult && !authResult.authenticated) {
					const errorMessage = authResult && typeof authResult === "object" && "error" in authResult && typeof authResult.error === "string" ? authResult.error : "Unauthorized: Authentication failed";
					res.setHeader("Content-Type", "application/json");
					const wwwAuthHeader = getWWWAuthenticateHeader(oauth, {
						error: "invalid_token",
						error_description: errorMessage
					});
					if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
					res.writeHead(401).end(JSON.stringify({
						error: {
							code: -32e3,
							message: errorMessage
						},
						id: body?.id ?? null,
						jsonrpc: "2.0"
					}));
					return true;
				}
			} catch (error$1) {
				if (await handleResponseError(error$1, res)) return true;
				const errorMessage = error$1 instanceof Error ? error$1.message : "Unauthorized: Authentication error";
				console.error("Authentication error:", error$1);
				res.setHeader("Content-Type", "application/json");
				const wwwAuthHeader = getWWWAuthenticateHeader(oauth, {
					error: "invalid_token",
					error_description: errorMessage
				});
				if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
				res.writeHead(401).end(JSON.stringify({
					error: {
						code: -32e3,
						message: errorMessage
					},
					id: body?.id ?? null,
					jsonrpc: "2.0"
				}));
				return true;
			}
			if (sessionId) {
				const activeTransport = activeTransports[sessionId];
				if (!activeTransport) {
					res.setHeader("Content-Type", "application/json");
					res.writeHead(404).end(createJsonRpcErrorResponse(-32001, "Session not found"));
					return true;
				}
				transport = activeTransport.transport;
				server = activeTransport.server;
			} else if (!sessionId && isInitializeRequest(body)) {
				transport = new StreamableHTTPServerTransport({
					enableJsonResponse,
					eventStore: eventStore || new InMemoryEventStore(),
					onsessioninitialized: (_sessionId) => {
						if (!stateless && _sessionId) activeTransports[_sessionId] = {
							server,
							transport
						};
					},
					sessionIdGenerator: stateless ? void 0 : randomUUID
				});
				let isCleaningUp = false;
				transport.onclose = async () => {
					const sid = transport.sessionId;
					if (isCleaningUp) return;
					isCleaningUp = true;
					if (!stateless && sid && activeTransports[sid]) {
						await cleanupServer(server, onClose);
						delete activeTransports[sid];
					} else if (stateless) await cleanupServer(server, onClose);
				};
				try {
					server = await createServer(req);
				} catch (error$1) {
					if (await handleResponseError(error$1, res)) return true;
					const errorMessage = error$1 instanceof Error ? error$1.message : String(error$1);
					if (errorMessage.includes("Authentication") || errorMessage.includes("Invalid JWT") || errorMessage.includes("Token") || errorMessage.includes("Unauthorized")) {
						res.setHeader("Content-Type", "application/json");
						const wwwAuthHeader = getWWWAuthenticateHeader(oauth, {
							error: "invalid_token",
							error_description: errorMessage
						});
						if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
						res.writeHead(401).end(JSON.stringify({
							error: {
								code: -32e3,
								message: errorMessage
							},
							id: body?.id ?? null,
							jsonrpc: "2.0"
						}));
						return true;
					}
					res.writeHead(500).end("Error creating server");
					return true;
				}
				server.connect(transport);
				if (onConnect) await onConnect(server);
				await transport.handleRequest(req, res, body);
				return true;
			} else if (stateless && !sessionId && !isInitializeRequest(body)) {
				transport = new StreamableHTTPServerTransport({
					enableJsonResponse,
					eventStore: eventStore || new InMemoryEventStore(),
					onsessioninitialized: () => {},
					sessionIdGenerator: void 0
				});
				try {
					server = await createServer(req);
				} catch (error$1) {
					if (await handleResponseError(error$1, res)) return true;
					const errorMessage = error$1 instanceof Error ? error$1.message : String(error$1);
					if (errorMessage.includes("Authentication") || errorMessage.includes("Invalid JWT") || errorMessage.includes("Token") || errorMessage.includes("Unauthorized")) {
						res.setHeader("Content-Type", "application/json");
						const wwwAuthHeader = getWWWAuthenticateHeader(oauth, {
							error: "invalid_token",
							error_description: errorMessage
						});
						if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
						res.writeHead(401).end(JSON.stringify({
							error: {
								code: -32e3,
								message: errorMessage
							},
							id: body?.id ?? null,
							jsonrpc: "2.0"
						}));
						return true;
					}
					res.writeHead(500).end("Error creating server");
					return true;
				}
				server.connect(transport);
				if (onConnect) await onConnect(server);
				await transport.handleRequest(req, res, body);
				return true;
			} else {
				res.setHeader("Content-Type", "application/json");
				res.writeHead(400).end(createJsonRpcErrorResponse(-32e3, "Bad Request: No valid session ID provided"));
				return true;
			}
			await transport.handleRequest(req, res, body);
			return true;
		} catch (error$1) {
			if (isScopeChallengeError(error$1)) {
				const response = authMiddleware.getScopeChallengeResponse(error$1.data.requiredScopes, error$1.data.errorDescription, body?.id);
				res.writeHead(response.statusCode, response.headers);
				res.end(response.body);
				return true;
			}
			console.error("[mcp-proxy] error handling request", error$1);
			res.setHeader("Content-Type", "application/json");
			res.writeHead(500).end(createJsonRpcErrorResponse(-32603, "Internal Server Error"));
		}
		return true;
	}
	if (req.method === "GET" && new URL(req.url, "http://localhost").pathname === endpoint) {
		const sessionId = req.headers["mcp-session-id"];
		const activeTransport = sessionId ? activeTransports[sessionId] : void 0;
		if (!sessionId) {
			res.writeHead(400).end("No sessionId");
			return true;
		}
		if (!activeTransport) {
			res.writeHead(400).end("No active transport");
			return true;
		}
		const lastEventId = req.headers["last-event-id"];
		if (lastEventId) console.log(`[mcp-proxy] client reconnecting with Last-Event-ID ${lastEventId} for session ID ${sessionId}`);
		else console.log(`[mcp-proxy] establishing new SSE stream for session ID ${sessionId}`);
		await activeTransport.transport.handleRequest(req, res);
		return true;
	}
	if (req.method === "DELETE" && new URL(req.url, "http://localhost").pathname === endpoint) {
		console.log("[mcp-proxy] received delete request");
		const sessionId = req.headers["mcp-session-id"];
		if (!sessionId) {
			res.writeHead(400).end("Invalid or missing sessionId");
			return true;
		}
		console.log("[mcp-proxy] received delete request for session", sessionId);
		const activeTransport = activeTransports[sessionId];
		if (!activeTransport) {
			res.writeHead(400).end("No active transport");
			return true;
		}
		try {
			await activeTransport.transport.handleRequest(req, res);
			await cleanupServer(activeTransport.server, onClose);
		} catch (error$1) {
			console.error("[mcp-proxy] error handling delete request", error$1);
			res.writeHead(500).end("Error handling delete request");
		}
		return true;
	}
	return false;
};
const handleSSERequest = async ({ activeTransports, createServer, endpoint, onClose, onConnect, req, res }) => {
	if (req.method === "GET" && new URL(req.url, "http://localhost").pathname === endpoint) {
		const transport = new SSEServerTransport("/messages", res);
		let server;
		try {
			server = await createServer(req);
		} catch (error$1) {
			if (await handleResponseError(error$1, res)) return true;
			res.writeHead(500).end("Error creating server");
			return true;
		}
		activeTransports[transport.sessionId] = transport;
		let closed = false;
		let isCleaningUp = false;
		res.on("close", async () => {
			closed = true;
			if (isCleaningUp) return;
			isCleaningUp = true;
			await cleanupServer(server, onClose);
			delete activeTransports[transport.sessionId];
		});
		try {
			await server.connect(transport);
			await transport.send({
				jsonrpc: "2.0",
				method: "notifications/message",
				params: {
					data: "SSE Connection established",
					level: "info"
				}
			});
			if (onConnect) await onConnect(server);
		} catch (error$1) {
			if (!closed) {
				console.error("[mcp-proxy] error connecting to server", error$1);
				res.writeHead(500).end("Error connecting to server");
			}
		}
		return true;
	}
	if (req.method === "POST" && req.url?.startsWith("/messages")) {
		const sessionId = new URL(req.url, "https://example.com").searchParams.get("sessionId");
		if (!sessionId) {
			res.writeHead(400).end("No sessionId");
			return true;
		}
		const activeTransport = activeTransports[sessionId];
		if (!activeTransport) {
			res.writeHead(400).end("No active transport");
			return true;
		}
		await activeTransport.handlePostMessage(req, res);
		return true;
	}
	return false;
};
const startHTTPServer = async ({ apiKey, authenticate, cors, createServer, enableJsonResponse, eventStore, host = "::", oauth, onClose, onConnect, onUnhandledRequest, port, sseEndpoint = "/sse", stateless, streamEndpoint = "/mcp" }) => {
	const activeSSETransports = {};
	const activeStreamTransports = {};
	const authMiddleware = new AuthenticationMiddleware({
		apiKey,
		oauth
	});
	/**
	* @author https://dev.classmethod.jp/articles/mcp-sse/
	*/
	const httpServer = http.createServer(async (req, res) => {
		applyCorsHeaders(req, res, cors);
		if (req.method === "OPTIONS") {
			res.writeHead(204);
			res.end();
			return;
		}
		if (req.method === "GET" && req.url === `/ping`) {
			res.writeHead(200).end("pong");
			return;
		}
		if (!authMiddleware.validateRequest(req)) {
			const authResponse = authMiddleware.getUnauthorizedResponse();
			res.writeHead(401, authResponse.headers);
			res.end(authResponse.body);
			return;
		}
		if (sseEndpoint && await handleSSERequest({
			activeTransports: activeSSETransports,
			createServer,
			endpoint: sseEndpoint,
			onClose,
			onConnect,
			req,
			res
		})) return;
		if (streamEndpoint && await handleStreamRequest({
			activeTransports: activeStreamTransports,
			authenticate,
			authMiddleware,
			createServer,
			enableJsonResponse,
			endpoint: streamEndpoint,
			eventStore,
			oauth,
			onClose,
			onConnect,
			req,
			res,
			stateless
		})) return;
		if (onUnhandledRequest) await onUnhandledRequest(req, res);
		else res.writeHead(404).end();
	});
	await new Promise((resolve$2) => {
		httpServer.listen(port, host, () => {
			resolve$2(void 0);
		});
	});
	return { close: async () => {
		for (const transport of Object.values(activeSSETransports)) await transport.close();
		for (const transport of Object.values(activeStreamTransports)) await transport.transport.close();
		return new Promise((resolve$2, reject) => {
			httpServer.close((error$1) => {
				if (error$1) {
					reject(error$1);
					return;
				}
				resolve$2();
			});
		});
	} };
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
	return !!s._zod;
}
function safeParse(schema, data) {
	if (isZ4Schema(schema)) return safeParse$2(schema, data);
	return schema.safeParse(data);
}
function getObjectShape(schema) {
	var _a, _b;
	if (!schema) return void 0;
	let rawShape;
	if (isZ4Schema(schema)) rawShape = (_b = (_a = schema._zod) === null || _a === void 0 ? void 0 : _a.def) === null || _b === void 0 ? void 0 : _b.shape;
	else rawShape = schema.shape;
	if (!rawShape) return void 0;
	if (typeof rawShape === "function") try {
		return rawShape();
	} catch (_c) {
		return;
	}
	return rawShape;
}
/**
* Gets the literal value from a schema, if it's a literal schema.
* Works with both Zod v3 and v4.
* Returns undefined if the schema is not a literal or the value cannot be determined.
*/
function getLiteralValue(schema) {
	var _a;
	if (isZ4Schema(schema)) {
		const def$31 = (_a = schema._zod) === null || _a === void 0 ? void 0 : _a.def;
		if (def$31) {
			if (def$31.value !== void 0) return def$31.value;
			if (Array.isArray(def$31.values) && def$31.values.length > 0) return def$31.values[0];
		}
	}
	const def$30 = schema._def;
	if (def$30) {
		if (def$30.value !== void 0) return def$30.value;
		if (Array.isArray(def$30.values) && def$30.values.length > 0) return def$30.values[0];
	}
	const directValue = schema.value;
	if (directValue !== void 0) return directValue;
}

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
/**
* Experimental task interfaces for MCP SDK.
* WARNING: These APIs are experimental and may change without notice.
*/
/**
* Checks if a task status represents a terminal state.
* Terminal states are those where the task has finished and will not change.
*
* @param status - The task status to check
* @returns True if the status is terminal (completed, failed, or cancelled)
* @experimental
*/
function isTerminal(status$1) {
	return status$1 === "completed" || status$1 === "failed" || status$1 === "cancelled";
}

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
	const shape = getObjectShape(schema);
	const methodSchema = shape === null || shape === void 0 ? void 0 : shape.method;
	if (!methodSchema) throw new Error("Schema is missing a method literal");
	const value = getLiteralValue(methodSchema);
	if (typeof value !== "string") throw new Error("Schema method literal must be a string");
	return value;
}
function parseWithCompat(schema, data) {
	const result = safeParse(schema, data);
	if (!result.success) throw result.error;
	return result.data;
}

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
/**
* The default request timeout, in miliseconds.
*/
const DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
/**
* Implements MCP protocol framing on top of a pluggable transport, including
* features like request/response linking, notifications, and progress.
*/
var Protocol = class {
	constructor(_options) {
		this._options = _options;
		this._requestMessageId = 0;
		this._requestHandlers = /* @__PURE__ */ new Map();
		this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
		this._notificationHandlers = /* @__PURE__ */ new Map();
		this._responseHandlers = /* @__PURE__ */ new Map();
		this._progressHandlers = /* @__PURE__ */ new Map();
		this._timeoutInfo = /* @__PURE__ */ new Map();
		this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
		this._taskProgressTokens = /* @__PURE__ */ new Map();
		this._requestResolvers = /* @__PURE__ */ new Map();
		this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
			this._oncancel(notification);
		});
		this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
			this._onprogress(notification);
		});
		this.setRequestHandler(PingRequestSchema, (_request) => ({}));
		this._taskStore = _options === null || _options === void 0 ? void 0 : _options.taskStore;
		this._taskMessageQueue = _options === null || _options === void 0 ? void 0 : _options.taskMessageQueue;
		if (this._taskStore) {
			this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
				const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
				if (!task) throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
				return { ...task };
			});
			this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
				const handleTaskResult = async () => {
					var _a;
					const taskId = request.params.taskId;
					if (this._taskMessageQueue) {
						let queuedMessage;
						while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
							if (queuedMessage.type === "response" || queuedMessage.type === "error") {
								const message = queuedMessage.message;
								const requestId = message.id;
								const resolver = this._requestResolvers.get(requestId);
								if (resolver) {
									this._requestResolvers.delete(requestId);
									if (queuedMessage.type === "response") resolver(message);
									else {
										const errorMessage = message;
										resolver(new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data));
									}
								} else {
									const messageType = queuedMessage.type === "response" ? "Response" : "Error";
									this._onerror(/* @__PURE__ */ new Error(`${messageType} handler missing for request ${requestId}`));
								}
								continue;
							}
							await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.send(queuedMessage.message, { relatedRequestId: extra.requestId }));
						}
					}
					const task = await this._taskStore.getTask(taskId, extra.sessionId);
					if (!task) throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
					if (!isTerminal(task.status)) {
						await this._waitForTaskUpdate(taskId, extra.signal);
						return await handleTaskResult();
					}
					if (isTerminal(task.status)) {
						const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
						this._clearTaskQueue(taskId);
						return {
							...result,
							_meta: {
								...result._meta,
								[RELATED_TASK_META_KEY]: { taskId }
							}
						};
					}
					return await handleTaskResult();
				};
				return await handleTaskResult();
			});
			this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
				var _a;
				try {
					const { tasks, nextCursor } = await this._taskStore.listTasks((_a = request.params) === null || _a === void 0 ? void 0 : _a.cursor, extra.sessionId);
					return {
						tasks,
						nextCursor,
						_meta: {}
					};
				} catch (error$1) {
					throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error$1 instanceof Error ? error$1.message : String(error$1)}`);
				}
			});
			this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
				try {
					const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
					if (!task) throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
					if (isTerminal(task.status)) throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
					await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
					this._clearTaskQueue(request.params.taskId);
					const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
					if (!cancelledTask) throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
					return {
						_meta: {},
						...cancelledTask
					};
				} catch (error$1) {
					if (error$1 instanceof McpError) throw error$1;
					throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error$1 instanceof Error ? error$1.message : String(error$1)}`);
				}
			});
		}
	}
	async _oncancel(notification) {
		const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
		controller === null || controller === void 0 || controller.abort(notification.params.reason);
	}
	_setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
		this._timeoutInfo.set(messageId, {
			timeoutId: setTimeout(onTimeout, timeout),
			startTime: Date.now(),
			timeout,
			maxTotalTimeout,
			resetTimeoutOnProgress,
			onTimeout
		});
	}
	_resetTimeout(messageId) {
		const info = this._timeoutInfo.get(messageId);
		if (!info) return false;
		const totalElapsed = Date.now() - info.startTime;
		if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
			this._timeoutInfo.delete(messageId);
			throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
				maxTotalTimeout: info.maxTotalTimeout,
				totalElapsed
			});
		}
		clearTimeout(info.timeoutId);
		info.timeoutId = setTimeout(info.onTimeout, info.timeout);
		return true;
	}
	_cleanupTimeout(messageId) {
		const info = this._timeoutInfo.get(messageId);
		if (info) {
			clearTimeout(info.timeoutId);
			this._timeoutInfo.delete(messageId);
		}
	}
	/**
	* Attaches to the given transport, starts it, and starts listening for messages.
	*
	* The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
	*/
	async connect(transport) {
		var _a, _b, _c;
		this._transport = transport;
		const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
		this._transport.onclose = () => {
			_onclose === null || _onclose === void 0 || _onclose();
			this._onclose();
		};
		const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
		this._transport.onerror = (error$1) => {
			_onerror === null || _onerror === void 0 || _onerror(error$1);
			this._onerror(error$1);
		};
		const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
		this._transport.onmessage = (message, extra) => {
			_onmessage === null || _onmessage === void 0 || _onmessage(message, extra);
			if (isJSONRPCResponse(message) || isJSONRPCError(message)) this._onresponse(message);
			else if (isJSONRPCRequest(message)) this._onrequest(message, extra);
			else if (isJSONRPCNotification(message)) this._onnotification(message);
			else this._onerror(/* @__PURE__ */ new Error(`Unknown message type: ${JSON.stringify(message)}`));
		};
		await this._transport.start();
	}
	_onclose() {
		var _a;
		const responseHandlers = this._responseHandlers;
		this._responseHandlers = /* @__PURE__ */ new Map();
		this._progressHandlers.clear();
		this._taskProgressTokens.clear();
		this._pendingDebouncedNotifications.clear();
		const error$1 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
		this._transport = void 0;
		(_a = this.onclose) === null || _a === void 0 || _a.call(this);
		for (const handler of responseHandlers.values()) handler(error$1);
	}
	_onerror(error$1) {
		var _a;
		(_a = this.onerror) === null || _a === void 0 || _a.call(this, error$1);
	}
	_onnotification(notification) {
		var _a;
		const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
		if (handler === void 0) return;
		Promise.resolve().then(() => handler(notification)).catch((error$1) => this._onerror(/* @__PURE__ */ new Error(`Uncaught error in notification handler: ${error$1}`)));
	}
	_onrequest(request, extra) {
		var _a, _b, _c, _d, _e, _f;
		const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
		const capturedTransport = this._transport;
		const relatedTaskId = (_d = (_c = (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta) === null || _c === void 0 ? void 0 : _c[RELATED_TASK_META_KEY]) === null || _d === void 0 ? void 0 : _d.taskId;
		if (handler === void 0) {
			const errorResponse = {
				jsonrpc: "2.0",
				id: request.id,
				error: {
					code: ErrorCode.MethodNotFound,
					message: "Method not found"
				}
			};
			if (relatedTaskId && this._taskMessageQueue) this._enqueueTaskMessage(relatedTaskId, {
				type: "error",
				message: errorResponse,
				timestamp: Date.now()
			}, capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId).catch((error$1) => this._onerror(/* @__PURE__ */ new Error(`Failed to enqueue error response: ${error$1}`)));
			else capturedTransport === null || capturedTransport === void 0 || capturedTransport.send(errorResponse).catch((error$1) => this._onerror(/* @__PURE__ */ new Error(`Failed to send an error response: ${error$1}`)));
			return;
		}
		const abortController = new AbortController();
		this._requestHandlerAbortControllers.set(request.id, abortController);
		const taskCreationParams = (_e = request.params) === null || _e === void 0 ? void 0 : _e.task;
		const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId) : void 0;
		const fullExtra = {
			signal: abortController.signal,
			sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
			_meta: (_f = request.params) === null || _f === void 0 ? void 0 : _f._meta,
			sendNotification: async (notification) => {
				const notificationOptions = { relatedRequestId: request.id };
				if (relatedTaskId) notificationOptions.relatedTask = { taskId: relatedTaskId };
				await this.notification(notification, notificationOptions);
			},
			sendRequest: async (r, resultSchema, options) => {
				var _a$1, _b$1;
				const requestOptions = {
					...options,
					relatedRequestId: request.id
				};
				if (relatedTaskId && !requestOptions.relatedTask) requestOptions.relatedTask = { taskId: relatedTaskId };
				const effectiveTaskId = (_b$1 = (_a$1 = requestOptions.relatedTask) === null || _a$1 === void 0 ? void 0 : _a$1.taskId) !== null && _b$1 !== void 0 ? _b$1 : relatedTaskId;
				if (effectiveTaskId && taskStore) await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
				return await this.request(r, resultSchema, requestOptions);
			},
			authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
			requestId: request.id,
			requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo,
			taskId: relatedTaskId,
			taskStore,
			taskRequestedTtl: taskCreationParams === null || taskCreationParams === void 0 ? void 0 : taskCreationParams.ttl,
			closeSSEStream: extra === null || extra === void 0 ? void 0 : extra.closeSSEStream,
			closeStandaloneSSEStream: extra === null || extra === void 0 ? void 0 : extra.closeStandaloneSSEStream
		};
		Promise.resolve().then(() => {
			if (taskCreationParams) this.assertTaskHandlerCapability(request.method);
		}).then(() => handler(request, fullExtra)).then(async (result) => {
			if (abortController.signal.aborted) return;
			const response = {
				result,
				jsonrpc: "2.0",
				id: request.id
			};
			if (relatedTaskId && this._taskMessageQueue) await this._enqueueTaskMessage(relatedTaskId, {
				type: "response",
				message: response,
				timestamp: Date.now()
			}, capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId);
			else await (capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send(response));
		}, async (error$1) => {
			var _a$1;
			if (abortController.signal.aborted) return;
			const errorResponse = {
				jsonrpc: "2.0",
				id: request.id,
				error: {
					code: Number.isSafeInteger(error$1["code"]) ? error$1["code"] : ErrorCode.InternalError,
					message: (_a$1 = error$1.message) !== null && _a$1 !== void 0 ? _a$1 : "Internal error",
					...error$1["data"] !== void 0 && { data: error$1["data"] }
				}
			};
			if (relatedTaskId && this._taskMessageQueue) await this._enqueueTaskMessage(relatedTaskId, {
				type: "error",
				message: errorResponse,
				timestamp: Date.now()
			}, capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId);
			else await (capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send(errorResponse));
		}).catch((error$1) => this._onerror(/* @__PURE__ */ new Error(`Failed to send response: ${error$1}`))).finally(() => {
			this._requestHandlerAbortControllers.delete(request.id);
		});
	}
	_onprogress(notification) {
		const { progressToken, ...params } = notification.params;
		const messageId = Number(progressToken);
		const handler = this._progressHandlers.get(messageId);
		if (!handler) {
			this._onerror(/* @__PURE__ */ new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
			return;
		}
		const responseHandler = this._responseHandlers.get(messageId);
		const timeoutInfo = this._timeoutInfo.get(messageId);
		if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) try {
			this._resetTimeout(messageId);
		} catch (error$1) {
			this._responseHandlers.delete(messageId);
			this._progressHandlers.delete(messageId);
			this._cleanupTimeout(messageId);
			responseHandler(error$1);
			return;
		}
		handler(params);
	}
	_onresponse(response) {
		const messageId = Number(response.id);
		const resolver = this._requestResolvers.get(messageId);
		if (resolver) {
			this._requestResolvers.delete(messageId);
			if (isJSONRPCResponse(response)) resolver(response);
			else resolver(new McpError(response.error.code, response.error.message, response.error.data));
			return;
		}
		const handler = this._responseHandlers.get(messageId);
		if (handler === void 0) {
			this._onerror(/* @__PURE__ */ new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
			return;
		}
		this._responseHandlers.delete(messageId);
		this._cleanupTimeout(messageId);
		let isTaskResponse = false;
		if (isJSONRPCResponse(response) && response.result && typeof response.result === "object") {
			const result = response.result;
			if (result.task && typeof result.task === "object") {
				const task = result.task;
				if (typeof task.taskId === "string") {
					isTaskResponse = true;
					this._taskProgressTokens.set(task.taskId, messageId);
				}
			}
		}
		if (!isTaskResponse) this._progressHandlers.delete(messageId);
		if (isJSONRPCResponse(response)) handler(response);
		else handler(McpError.fromError(response.error.code, response.error.message, response.error.data));
	}
	get transport() {
		return this._transport;
	}
	/**
	* Closes the connection.
	*/
	async close() {
		var _a;
		await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
	}
	/**
	* Sends a request and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* @example
	* ```typescript
	* const stream = protocol.requestStream(request, resultSchema, options);
	* for await (const message of stream) {
	*   switch (message.type) {
	*     case 'taskCreated':
	*       console.log('Task created:', message.task.taskId);
	*       break;
	*     case 'taskStatus':
	*       console.log('Task status:', message.task.status);
	*       break;
	*     case 'result':
	*       console.log('Final result:', message.result);
	*       break;
	*     case 'error':
	*       console.error('Error:', message.error);
	*       break;
	*   }
	* }
	* ```
	*
	* @experimental Use `client.experimental.tasks.requestStream()` to access this method.
	*/
	async *requestStream(request, resultSchema, options) {
		var _a, _b, _c, _d;
		const { task } = options !== null && options !== void 0 ? options : {};
		if (!task) {
			try {
				yield {
					type: "result",
					result: await this.request(request, resultSchema, options)
				};
			} catch (error$1) {
				yield {
					type: "error",
					error: error$1 instanceof McpError ? error$1 : new McpError(ErrorCode.InternalError, String(error$1))
				};
			}
			return;
		}
		let taskId;
		try {
			const createResult = await this.request(request, CreateTaskResultSchema, options);
			if (createResult.task) {
				taskId = createResult.task.taskId;
				yield {
					type: "taskCreated",
					task: createResult.task
				};
			} else throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
			while (true) {
				const task$1 = await this.getTask({ taskId }, options);
				yield {
					type: "taskStatus",
					task: task$1
				};
				if (isTerminal(task$1.status)) {
					if (task$1.status === "completed") yield {
						type: "result",
						result: await this.getTaskResult({ taskId }, resultSchema, options)
					};
					else if (task$1.status === "failed") yield {
						type: "error",
						error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
					};
					else if (task$1.status === "cancelled") yield {
						type: "error",
						error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
					};
					return;
				}
				if (task$1.status === "input_required") {
					yield {
						type: "result",
						result: await this.getTaskResult({ taskId }, resultSchema, options)
					};
					return;
				}
				const pollInterval = (_c = (_a = task$1.pollInterval) !== null && _a !== void 0 ? _a : (_b = this._options) === null || _b === void 0 ? void 0 : _b.defaultTaskPollInterval) !== null && _c !== void 0 ? _c : 1e3;
				await new Promise((resolve$2) => setTimeout(resolve$2, pollInterval));
				(_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 || _d.throwIfAborted();
			}
		} catch (error$1) {
			yield {
				type: "error",
				error: error$1 instanceof McpError ? error$1 : new McpError(ErrorCode.InternalError, String(error$1))
			};
		}
	}
	/**
	* Sends a request and waits for a response.
	*
	* Do not use this method to emit notifications! Use notification() instead.
	*/
	request(request, resultSchema, options) {
		const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options !== null && options !== void 0 ? options : {};
		return new Promise((resolve$2, reject) => {
			var _a, _b, _c, _d, _e, _f, _g;
			const earlyReject = (error$1) => {
				reject(error$1);
			};
			if (!this._transport) {
				earlyReject(/* @__PURE__ */ new Error("Not connected"));
				return;
			}
			if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) try {
				this.assertCapabilityForMethod(request.method);
				if (task) this.assertTaskCapability(request.method);
			} catch (e) {
				earlyReject(e);
				return;
			}
			(_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 || _b.throwIfAborted();
			const messageId = this._requestMessageId++;
			const jsonrpcRequest = {
				...request,
				jsonrpc: "2.0",
				id: messageId
			};
			if (options === null || options === void 0 ? void 0 : options.onprogress) {
				this._progressHandlers.set(messageId, options.onprogress);
				jsonrpcRequest.params = {
					...request.params,
					_meta: {
						...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
						progressToken: messageId
					}
				};
			}
			if (task) jsonrpcRequest.params = {
				...jsonrpcRequest.params,
				task
			};
			if (relatedTask) jsonrpcRequest.params = {
				...jsonrpcRequest.params,
				_meta: {
					...((_d = jsonrpcRequest.params) === null || _d === void 0 ? void 0 : _d._meta) || {},
					[RELATED_TASK_META_KEY]: relatedTask
				}
			};
			const cancel = (reason) => {
				var _a$1;
				this._responseHandlers.delete(messageId);
				this._progressHandlers.delete(messageId);
				this._cleanupTimeout(messageId);
				(_a$1 = this._transport) === null || _a$1 === void 0 || _a$1.send({
					jsonrpc: "2.0",
					method: "notifications/cancelled",
					params: {
						requestId: messageId,
						reason: String(reason)
					}
				}, {
					relatedRequestId,
					resumptionToken,
					onresumptiontoken
				}).catch((error$1) => this._onerror(/* @__PURE__ */ new Error(`Failed to send cancellation: ${error$1}`)));
				reject(reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason)));
			};
			this._responseHandlers.set(messageId, (response) => {
				var _a$1;
				if ((_a$1 = options === null || options === void 0 ? void 0 : options.signal) === null || _a$1 === void 0 ? void 0 : _a$1.aborted) return;
				if (response instanceof Error) return reject(response);
				try {
					const parseResult = safeParse(resultSchema, response.result);
					if (!parseResult.success) reject(parseResult.error);
					else resolve$2(parseResult.data);
				} catch (error$1) {
					reject(error$1);
				}
			});
			(_e = options === null || options === void 0 ? void 0 : options.signal) === null || _e === void 0 || _e.addEventListener("abort", () => {
				var _a$1;
				cancel((_a$1 = options === null || options === void 0 ? void 0 : options.signal) === null || _a$1 === void 0 ? void 0 : _a$1.reason);
			});
			const timeout = (_f = options === null || options === void 0 ? void 0 : options.timeout) !== null && _f !== void 0 ? _f : DEFAULT_REQUEST_TIMEOUT_MSEC;
			const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
			this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_g = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _g !== void 0 ? _g : false);
			const relatedTaskId = relatedTask === null || relatedTask === void 0 ? void 0 : relatedTask.taskId;
			if (relatedTaskId) {
				const responseResolver = (response) => {
					const handler = this._responseHandlers.get(messageId);
					if (handler) handler(response);
					else this._onerror(/* @__PURE__ */ new Error(`Response handler missing for side-channeled request ${messageId}`));
				};
				this._requestResolvers.set(messageId, responseResolver);
				this._enqueueTaskMessage(relatedTaskId, {
					type: "request",
					message: jsonrpcRequest,
					timestamp: Date.now()
				}).catch((error$1) => {
					this._cleanupTimeout(messageId);
					reject(error$1);
				});
			} else this._transport.send(jsonrpcRequest, {
				relatedRequestId,
				resumptionToken,
				onresumptiontoken
			}).catch((error$1) => {
				this._cleanupTimeout(messageId);
				reject(error$1);
			});
		});
	}
	/**
	* Gets the current status of a task.
	*
	* @experimental Use `client.experimental.tasks.getTask()` to access this method.
	*/
	async getTask(params, options) {
		return this.request({
			method: "tasks/get",
			params
		}, GetTaskResultSchema, options);
	}
	/**
	* Retrieves the result of a completed task.
	*
	* @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
	*/
	async getTaskResult(params, resultSchema, options) {
		return this.request({
			method: "tasks/result",
			params
		}, resultSchema, options);
	}
	/**
	* Lists tasks, optionally starting from a pagination cursor.
	*
	* @experimental Use `client.experimental.tasks.listTasks()` to access this method.
	*/
	async listTasks(params, options) {
		return this.request({
			method: "tasks/list",
			params
		}, ListTasksResultSchema, options);
	}
	/**
	* Cancels a specific task.
	*
	* @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
	*/
	async cancelTask(params, options) {
		return this.request({
			method: "tasks/cancel",
			params
		}, CancelTaskResultSchema, options);
	}
	/**
	* Emits a notification, which is a one-way message that does not expect a response.
	*/
	async notification(notification, options) {
		var _a, _b, _c, _d, _e;
		if (!this._transport) throw new Error("Not connected");
		this.assertNotificationCapability(notification.method);
		const relatedTaskId = (_a = options === null || options === void 0 ? void 0 : options.relatedTask) === null || _a === void 0 ? void 0 : _a.taskId;
		if (relatedTaskId) {
			const jsonrpcNotification$1 = {
				...notification,
				jsonrpc: "2.0",
				params: {
					...notification.params,
					_meta: {
						...((_b = notification.params) === null || _b === void 0 ? void 0 : _b._meta) || {},
						[RELATED_TASK_META_KEY]: options.relatedTask
					}
				}
			};
			await this._enqueueTaskMessage(relatedTaskId, {
				type: "notification",
				message: jsonrpcNotification$1,
				timestamp: Date.now()
			});
			return;
		}
		if (((_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.debouncedNotificationMethods) !== null && _d !== void 0 ? _d : []).includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId) && !(options === null || options === void 0 ? void 0 : options.relatedTask)) {
			if (this._pendingDebouncedNotifications.has(notification.method)) return;
			this._pendingDebouncedNotifications.add(notification.method);
			Promise.resolve().then(() => {
				var _a$1, _b$1;
				this._pendingDebouncedNotifications.delete(notification.method);
				if (!this._transport) return;
				let jsonrpcNotification$1 = {
					...notification,
					jsonrpc: "2.0"
				};
				if (options === null || options === void 0 ? void 0 : options.relatedTask) jsonrpcNotification$1 = {
					...jsonrpcNotification$1,
					params: {
						...jsonrpcNotification$1.params,
						_meta: {
							...((_a$1 = jsonrpcNotification$1.params) === null || _a$1 === void 0 ? void 0 : _a$1._meta) || {},
							[RELATED_TASK_META_KEY]: options.relatedTask
						}
					}
				};
				(_b$1 = this._transport) === null || _b$1 === void 0 || _b$1.send(jsonrpcNotification$1, options).catch((error$1) => this._onerror(error$1));
			});
			return;
		}
		let jsonrpcNotification = {
			...notification,
			jsonrpc: "2.0"
		};
		if (options === null || options === void 0 ? void 0 : options.relatedTask) jsonrpcNotification = {
			...jsonrpcNotification,
			params: {
				...jsonrpcNotification.params,
				_meta: {
					...((_e = jsonrpcNotification.params) === null || _e === void 0 ? void 0 : _e._meta) || {},
					[RELATED_TASK_META_KEY]: options.relatedTask
				}
			}
		};
		await this._transport.send(jsonrpcNotification, options);
	}
	/**
	* Registers a handler to invoke when this protocol object receives a request with the given method.
	*
	* Note that this will replace any previous request handler for the same method.
	*/
	setRequestHandler(requestSchema, handler) {
		const method = getMethodLiteral(requestSchema);
		this.assertRequestHandlerCapability(method);
		this._requestHandlers.set(method, (request, extra) => {
			const parsed = parseWithCompat(requestSchema, request);
			return Promise.resolve(handler(parsed, extra));
		});
	}
	/**
	* Removes the request handler for the given method.
	*/
	removeRequestHandler(method) {
		this._requestHandlers.delete(method);
	}
	/**
	* Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
	*/
	assertCanSetRequestHandler(method) {
		if (this._requestHandlers.has(method)) throw new Error(`A request handler for ${method} already exists, which would be overridden`);
	}
	/**
	* Registers a handler to invoke when this protocol object receives a notification with the given method.
	*
	* Note that this will replace any previous notification handler for the same method.
	*/
	setNotificationHandler(notificationSchema, handler) {
		const method = getMethodLiteral(notificationSchema);
		this._notificationHandlers.set(method, (notification) => {
			const parsed = parseWithCompat(notificationSchema, notification);
			return Promise.resolve(handler(parsed));
		});
	}
	/**
	* Removes the notification handler for the given method.
	*/
	removeNotificationHandler(method) {
		this._notificationHandlers.delete(method);
	}
	/**
	* Cleans up the progress handler associated with a task.
	* This should be called when a task reaches a terminal status.
	*/
	_cleanupTaskProgressHandler(taskId) {
		const progressToken = this._taskProgressTokens.get(taskId);
		if (progressToken !== void 0) {
			this._progressHandlers.delete(progressToken);
			this._taskProgressTokens.delete(taskId);
		}
	}
	/**
	* Enqueues a task-related message for side-channel delivery via tasks/result.
	* @param taskId The task ID to associate the message with
	* @param message The message to enqueue
	* @param sessionId Optional session ID for binding the operation to a specific session
	* @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
	*
	* Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
	* the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
	* simply propagates the error.
	*/
	async _enqueueTaskMessage(taskId, message, sessionId) {
		var _a;
		if (!this._taskStore || !this._taskMessageQueue) throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
		const maxQueueSize = (_a = this._options) === null || _a === void 0 ? void 0 : _a.maxTaskQueueSize;
		await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
	}
	/**
	* Clears the message queue for a task and rejects any pending request resolvers.
	* @param taskId The task ID whose queue should be cleared
	* @param sessionId Optional session ID for binding the operation to a specific session
	*/
	async _clearTaskQueue(taskId, sessionId) {
		if (this._taskMessageQueue) {
			const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
			for (const message of messages) if (message.type === "request" && isJSONRPCRequest(message.message)) {
				const requestId = message.message.id;
				const resolver = this._requestResolvers.get(requestId);
				if (resolver) {
					resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
					this._requestResolvers.delete(requestId);
				} else this._onerror(/* @__PURE__ */ new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
			}
		}
	}
	/**
	* Waits for a task update (new messages or status change) with abort signal support.
	* Uses polling to check for updates at the task's configured poll interval.
	* @param taskId The task ID to wait for
	* @param signal Abort signal to cancel the wait
	* @returns Promise that resolves when an update occurs or rejects if aborted
	*/
	async _waitForTaskUpdate(taskId, signal) {
		var _a, _b, _c;
		let interval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.defaultTaskPollInterval) !== null && _b !== void 0 ? _b : 1e3;
		try {
			const task = await ((_c = this._taskStore) === null || _c === void 0 ? void 0 : _c.getTask(taskId));
			if (task === null || task === void 0 ? void 0 : task.pollInterval) interval = task.pollInterval;
		} catch (_d) {}
		return new Promise((resolve$2, reject) => {
			if (signal.aborted) {
				reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
				return;
			}
			const timeoutId = setTimeout(resolve$2, interval);
			signal.addEventListener("abort", () => {
				clearTimeout(timeoutId);
				reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
			}, { once: true });
		});
	}
	requestTaskStore(request, sessionId) {
		const taskStore = this._taskStore;
		if (!taskStore) throw new Error("No task store configured");
		return {
			createTask: async (taskParams) => {
				if (!request) throw new Error("No request provided");
				return await taskStore.createTask(taskParams, request.id, {
					method: request.method,
					params: request.params
				}, sessionId);
			},
			getTask: async (taskId) => {
				const task = await taskStore.getTask(taskId, sessionId);
				if (!task) throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
				return task;
			},
			storeTaskResult: async (taskId, status$1, result) => {
				await taskStore.storeTaskResult(taskId, status$1, result, sessionId);
				const task = await taskStore.getTask(taskId, sessionId);
				if (task) {
					const notification = TaskStatusNotificationSchema.parse({
						method: "notifications/tasks/status",
						params: task
					});
					await this.notification(notification);
					if (isTerminal(task.status)) this._cleanupTaskProgressHandler(taskId);
				}
			},
			getTaskResult: (taskId) => {
				return taskStore.getTaskResult(taskId, sessionId);
			},
			updateTaskStatus: async (taskId, status$1, statusMessage) => {
				const task = await taskStore.getTask(taskId, sessionId);
				if (!task) throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
				if (isTerminal(task.status)) throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status$1}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
				await taskStore.updateTaskStatus(taskId, status$1, statusMessage, sessionId);
				const updatedTask = await taskStore.getTask(taskId, sessionId);
				if (updatedTask) {
					const notification = TaskStatusNotificationSchema.parse({
						method: "notifications/tasks/status",
						params: updatedTask
					});
					await this.notification(notification);
					if (isTerminal(updatedTask.status)) this._cleanupTaskProgressHandler(taskId);
				}
			},
			listTasks: (cursor) => {
				return taskStore.listTasks(cursor, sessionId);
			}
		};
	}
};
function isPlainObject(value) {
	return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
	const result = { ...base };
	for (const key$1 in additional) {
		const k = key$1;
		const addValue = additional[k];
		if (addValue === void 0) continue;
		const baseValue = result[k];
		if (isPlainObject(baseValue) && isPlainObject(addValue)) result[k] = {
			...baseValue,
			...addValue
		};
		else result[k] = addValue;
	}
	return result;
}

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js
var require_code$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	var _CodeOrName = class {};
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var Name = class extends _CodeOrName {
		constructor(s) {
			super();
			if (!exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
			this.str = s;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			return false;
		}
		get names() {
			return { [this.str]: 1 };
		}
	};
	exports.Name = Name;
	var _Code = class extends _CodeOrName {
		constructor(code) {
			super();
			this._items = typeof code === "string" ? [code] : code;
		}
		toString() {
			return this.str;
		}
		emptyStr() {
			if (this._items.length > 1) return false;
			const item = this._items[0];
			return item === "" || item === "\"\"";
		}
		get str() {
			var _a;
			return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
		}
		get names() {
			var _a;
			return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names$1, c) => {
				if (c instanceof Name) names$1[c.str] = (names$1[c.str] || 0) + 1;
				return names$1;
			}, {});
		}
	};
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
		const code = [strs[0]];
		let i$3 = 0;
		while (i$3 < args.length) {
			addCodeArg(code, args[i$3]);
			code.push(strs[++i$3]);
		}
		return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
		const expr = [safeStringify(strs[0])];
		let i$3 = 0;
		while (i$3 < args.length) {
			expr.push(plus);
			addCodeArg(expr, args[i$3]);
			expr.push(plus, safeStringify(strs[++i$3]));
		}
		optimize(expr);
		return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
		if (arg instanceof _Code) code.push(...arg._items);
		else if (arg instanceof Name) code.push(arg);
		else code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
		let i$3 = 1;
		while (i$3 < expr.length - 1) {
			if (expr[i$3] === plus) {
				const res = mergeExprItems(expr[i$3 - 1], expr[i$3 + 1]);
				if (res !== void 0) {
					expr.splice(i$3 - 1, 3, res);
					continue;
				}
				expr[i$3++] = "+";
			}
			i$3++;
		}
	}
	function mergeExprItems(a, b) {
		if (b === "\"\"") return a;
		if (a === "\"\"") return b;
		if (typeof a == "string") {
			if (b instanceof Name || a[a.length - 1] !== "\"") return;
			if (typeof b != "string") return `${a.slice(0, -1)}${b}"`;
			if (b[0] === "\"") return a.slice(0, -1) + b.slice(1);
			return;
		}
		if (typeof b == "string" && b[0] === "\"" && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
	}
	function strConcat(c1, c2) {
		return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	function interpolate(x) {
		return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
		return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
		return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key$1) {
		return typeof key$1 == "string" && exports.IDENTIFIER.test(key$1) ? new _Code(`.${key$1}`) : _`[${key$1}]`;
	}
	exports.getProperty = getProperty;
	function getEsmExportName(key$1) {
		if (typeof key$1 == "string" && exports.IDENTIFIER.test(key$1)) return new _Code(`${key$1}`);
		throw new Error(`CodeGen: invalid export name: ${key$1}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
		return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1$12 = require_code$1();
	var ValueError = class extends Error {
		constructor(name) {
			super(`CodeGen: "code" for ${name} not defined`);
			this.value = name.value;
		}
	};
	var UsedValueState;
	(function(UsedValueState$1) {
		UsedValueState$1[UsedValueState$1["Started"] = 0] = "Started";
		UsedValueState$1[UsedValueState$1["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
		const: new code_1$12.Name("const"),
		let: new code_1$12.Name("let"),
		var: new code_1$12.Name("var")
	};
	var Scope = class {
		constructor({ prefixes, parent } = {}) {
			this._names = {};
			this._prefixes = prefixes;
			this._parent = parent;
		}
		toName(nameOrPrefix) {
			return nameOrPrefix instanceof code_1$12.Name ? nameOrPrefix : this.name(nameOrPrefix);
		}
		name(prefix) {
			return new code_1$12.Name(this._newName(prefix));
		}
		_newName(prefix) {
			const ng = this._names[prefix] || this._nameGroup(prefix);
			return `${prefix}${ng.index++}`;
		}
		_nameGroup(prefix) {
			var _a, _b;
			if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
			return this._names[prefix] = {
				prefix,
				index: 0
			};
		}
	};
	exports.Scope = Scope;
	var ValueScopeName = class extends code_1$12.Name {
		constructor(prefix, nameStr) {
			super(nameStr);
			this.prefix = prefix;
		}
		setValue(value, { property, itemIndex }) {
			this.value = value;
			this.scopePath = (0, code_1$12._)`.${new code_1$12.Name(property)}[${itemIndex}]`;
		}
	};
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1$12._)`\n`;
	var ValueScope = class extends Scope {
		constructor(opts) {
			super(opts);
			this._values = {};
			this._scope = opts.scope;
			this.opts = {
				...opts,
				_n: opts.lines ? line : code_1$12.nil
			};
		}
		get() {
			return this._scope;
		}
		name(prefix) {
			return new ValueScopeName(prefix, this._newName(prefix));
		}
		value(nameOrPrefix, value) {
			var _a;
			if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
			const name = this.toName(nameOrPrefix);
			const { prefix } = name;
			const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
			let vs = this._values[prefix];
			if (vs) {
				const _name = vs.get(valueKey);
				if (_name) return _name;
			} else vs = this._values[prefix] = /* @__PURE__ */ new Map();
			vs.set(valueKey, name);
			const s = this._scope[prefix] || (this._scope[prefix] = []);
			const itemIndex = s.length;
			s[itemIndex] = value.ref;
			name.setValue(value, {
				property: prefix,
				itemIndex
			});
			return name;
		}
		getValue(prefix, keyOrRef) {
			const vs = this._values[prefix];
			if (!vs) return;
			return vs.get(keyOrRef);
		}
		scopeRefs(scopeName, values = this._values) {
			return this._reduceValues(values, (name) => {
				if (name.scopePath === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return (0, code_1$12._)`${scopeName}${name.scopePath}`;
			});
		}
		scopeCode(values = this._values, usedValues, getCode) {
			return this._reduceValues(values, (name) => {
				if (name.value === void 0) throw new Error(`CodeGen: name "${name}" has no value`);
				return name.value.code;
			}, usedValues, getCode);
		}
		_reduceValues(values, valueCode, usedValues = {}, getCode) {
			let code = code_1$12.nil;
			for (const prefix in values) {
				const vs = values[prefix];
				if (!vs) continue;
				const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
				vs.forEach((name) => {
					if (nameSet.has(name)) return;
					nameSet.set(name, UsedValueState.Started);
					let c = valueCode(name);
					if (c) {
						const def$30 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
						code = (0, code_1$12._)`${code}${def$30} ${name} = ${c};${this.opts._n}`;
					} else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) code = (0, code_1$12._)`${code}${c}${this.opts._n}`;
					else throw new ValueError(name);
					nameSet.set(name, UsedValueState.Completed);
				});
			}
			return code;
		}
	};
	exports.ValueScope = ValueScope;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1$11 = require_code$1();
	const scope_1 = require_scope();
	var code_2 = require_code$1();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return code_2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return code_2.str;
		}
	});
	Object.defineProperty(exports, "strConcat", {
		enumerable: true,
		get: function() {
			return code_2.strConcat;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return code_2.nil;
		}
	});
	Object.defineProperty(exports, "getProperty", {
		enumerable: true,
		get: function() {
			return code_2.getProperty;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return code_2.stringify;
		}
	});
	Object.defineProperty(exports, "regexpCode", {
		enumerable: true,
		get: function() {
			return code_2.regexpCode;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return code_2.Name;
		}
	});
	var scope_2 = require_scope();
	Object.defineProperty(exports, "Scope", {
		enumerable: true,
		get: function() {
			return scope_2.Scope;
		}
	});
	Object.defineProperty(exports, "ValueScope", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScope;
		}
	});
	Object.defineProperty(exports, "ValueScopeName", {
		enumerable: true,
		get: function() {
			return scope_2.ValueScopeName;
		}
	});
	Object.defineProperty(exports, "varKinds", {
		enumerable: true,
		get: function() {
			return scope_2.varKinds;
		}
	});
	exports.operators = {
		GT: new code_1$11._Code(">"),
		GTE: new code_1$11._Code(">="),
		LT: new code_1$11._Code("<"),
		LTE: new code_1$11._Code("<="),
		EQ: new code_1$11._Code("==="),
		NEQ: new code_1$11._Code("!=="),
		NOT: new code_1$11._Code("!"),
		OR: new code_1$11._Code("||"),
		AND: new code_1$11._Code("&&"),
		ADD: new code_1$11._Code("+")
	};
	var Node = class {
		optimizeNodes() {
			return this;
		}
		optimizeNames(_names, _constants) {
			return this;
		}
	};
	var Def = class extends Node {
		constructor(varKind, name, rhs) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.rhs = rhs;
		}
		render({ es5, _n }) {
			const varKind = es5 ? scope_1.varKinds.var : this.varKind;
			const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
			return `${varKind} ${this.name}${rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (!names$1[this.name.str]) return;
			if (this.rhs) this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return this.rhs instanceof code_1$11._CodeOrName ? this.rhs.names : {};
		}
	};
	var Assign = class extends Node {
		constructor(lhs, rhs, sideEffects) {
			super();
			this.lhs = lhs;
			this.rhs = rhs;
			this.sideEffects = sideEffects;
		}
		render({ _n }) {
			return `${this.lhs} = ${this.rhs};` + _n;
		}
		optimizeNames(names$1, constants) {
			if (this.lhs instanceof code_1$11.Name && !names$1[this.lhs.str] && !this.sideEffects) return;
			this.rhs = optimizeExpr(this.rhs, names$1, constants);
			return this;
		}
		get names() {
			return addExprNames(this.lhs instanceof code_1$11.Name ? {} : { ...this.lhs.names }, this.rhs);
		}
	};
	var AssignOp = class extends Assign {
		constructor(lhs, op, rhs, sideEffects) {
			super(lhs, rhs, sideEffects);
			this.op = op;
		}
		render({ _n }) {
			return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		}
	};
	var Label = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `${this.label}:` + _n;
		}
	};
	var Break = class extends Node {
		constructor(label) {
			super();
			this.label = label;
			this.names = {};
		}
		render({ _n }) {
			return `break${this.label ? ` ${this.label}` : ""};` + _n;
		}
	};
	var Throw = class extends Node {
		constructor(error$1) {
			super();
			this.error = error$1;
		}
		render({ _n }) {
			return `throw ${this.error};` + _n;
		}
		get names() {
			return this.error.names;
		}
	};
	var AnyCode = class extends Node {
		constructor(code) {
			super();
			this.code = code;
		}
		render({ _n }) {
			return `${this.code};` + _n;
		}
		optimizeNodes() {
			return `${this.code}` ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			this.code = optimizeExpr(this.code, names$1, constants);
			return this;
		}
		get names() {
			return this.code instanceof code_1$11._CodeOrName ? this.code.names : {};
		}
	};
	var ParentNode = class extends Node {
		constructor(nodes = []) {
			super();
			this.nodes = nodes;
		}
		render(opts) {
			return this.nodes.reduce((code, n) => code + n.render(opts), "");
		}
		optimizeNodes() {
			const { nodes } = this;
			let i$3 = nodes.length;
			while (i$3--) {
				const n = nodes[i$3].optimizeNodes();
				if (Array.isArray(n)) nodes.splice(i$3, 1, ...n);
				else if (n) nodes[i$3] = n;
				else nodes.splice(i$3, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		optimizeNames(names$1, constants) {
			const { nodes } = this;
			let i$3 = nodes.length;
			while (i$3--) {
				const n = nodes[i$3];
				if (n.optimizeNames(names$1, constants)) continue;
				subtractNames(names$1, n.names);
				nodes.splice(i$3, 1);
			}
			return nodes.length > 0 ? this : void 0;
		}
		get names() {
			return this.nodes.reduce((names$1, n) => addNames(names$1, n.names), {});
		}
	};
	var BlockNode = class extends ParentNode {
		render(opts) {
			return "{" + opts._n + super.render(opts) + "}" + opts._n;
		}
	};
	var Root = class extends ParentNode {};
	var Else = class extends BlockNode {};
	Else.kind = "else";
	var If = class If extends BlockNode {
		constructor(condition, nodes) {
			super(nodes);
			this.condition = condition;
		}
		render(opts) {
			let code = `if(${this.condition})` + super.render(opts);
			if (this.else) code += "else " + this.else.render(opts);
			return code;
		}
		optimizeNodes() {
			super.optimizeNodes();
			const cond = this.condition;
			if (cond === true) return this.nodes;
			let e = this.else;
			if (e) {
				const ns = e.optimizeNodes();
				e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
			}
			if (e) {
				if (cond === false) return e instanceof If ? e : e.nodes;
				if (this.nodes.length) return this;
				return new If(not(cond), e instanceof If ? [e] : e.nodes);
			}
			if (cond === false || !this.nodes.length) return void 0;
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a;
			this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names$1, constants);
			if (!(super.optimizeNames(names$1, constants) || this.else)) return;
			this.condition = optimizeExpr(this.condition, names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			addExprNames(names$1, this.condition);
			if (this.else) addNames(names$1, this.else.names);
			return names$1;
		}
	};
	If.kind = "if";
	var For = class extends BlockNode {};
	For.kind = "for";
	var ForLoop = class extends For {
		constructor(iteration) {
			super();
			this.iteration = iteration;
		}
		render(opts) {
			return `for(${this.iteration})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iteration = optimizeExpr(this.iteration, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iteration.names);
		}
	};
	var ForRange = class extends For {
		constructor(varKind, name, from, to) {
			super();
			this.varKind = varKind;
			this.name = name;
			this.from = from;
			this.to = to;
		}
		render(opts) {
			const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
			const { name, from, to } = this;
			return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		}
		get names() {
			return addExprNames(addExprNames(super.names, this.from), this.to);
		}
	};
	var ForIter = class extends For {
		constructor(loop, varKind, name, iterable) {
			super();
			this.loop = loop;
			this.varKind = varKind;
			this.name = name;
			this.iterable = iterable;
		}
		render(opts) {
			return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		}
		optimizeNames(names$1, constants) {
			if (!super.optimizeNames(names$1, constants)) return;
			this.iterable = optimizeExpr(this.iterable, names$1, constants);
			return this;
		}
		get names() {
			return addNames(super.names, this.iterable.names);
		}
	};
	var Func = class extends BlockNode {
		constructor(name, args, async) {
			super();
			this.name = name;
			this.args = args;
			this.async = async;
		}
		render(opts) {
			return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
		}
	};
	Func.kind = "func";
	var Return = class extends ParentNode {
		render(opts) {
			return "return " + super.render(opts);
		}
	};
	Return.kind = "return";
	var Try = class extends BlockNode {
		render(opts) {
			let code = "try" + super.render(opts);
			if (this.catch) code += this.catch.render(opts);
			if (this.finally) code += this.finally.render(opts);
			return code;
		}
		optimizeNodes() {
			var _a, _b;
			super.optimizeNodes();
			(_a = this.catch) === null || _a === void 0 || _a.optimizeNodes();
			(_b = this.finally) === null || _b === void 0 || _b.optimizeNodes();
			return this;
		}
		optimizeNames(names$1, constants) {
			var _a, _b;
			super.optimizeNames(names$1, constants);
			(_a = this.catch) === null || _a === void 0 || _a.optimizeNames(names$1, constants);
			(_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names$1, constants);
			return this;
		}
		get names() {
			const names$1 = super.names;
			if (this.catch) addNames(names$1, this.catch.names);
			if (this.finally) addNames(names$1, this.finally.names);
			return names$1;
		}
	};
	var Catch = class extends BlockNode {
		constructor(error$1) {
			super();
			this.error = error$1;
		}
		render(opts) {
			return `catch(${this.error})` + super.render(opts);
		}
	};
	Catch.kind = "catch";
	var Finally = class extends BlockNode {
		render(opts) {
			return "finally" + super.render(opts);
		}
	};
	Finally.kind = "finally";
	var CodeGen = class {
		constructor(extScope, opts = {}) {
			this._values = {};
			this._blockStarts = [];
			this._constants = {};
			this.opts = {
				...opts,
				_n: opts.lines ? "\n" : ""
			};
			this._extScope = extScope;
			this._scope = new scope_1.Scope({ parent: extScope });
			this._nodes = [new Root()];
		}
		toString() {
			return this._root.render(this.opts);
		}
		name(prefix) {
			return this._scope.name(prefix);
		}
		scopeName(prefix) {
			return this._extScope.name(prefix);
		}
		scopeValue(prefixOrName, value) {
			const name = this._extScope.value(prefixOrName, value);
			(this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name);
			return name;
		}
		getScopeValue(prefix, keyOrRef) {
			return this._extScope.getValue(prefix, keyOrRef);
		}
		scopeRefs(scopeName) {
			return this._extScope.scopeRefs(scopeName, this._values);
		}
		scopeCode() {
			return this._extScope.scopeCode(this._values);
		}
		_def(varKind, nameOrPrefix, rhs, constant) {
			const name = this._scope.toName(nameOrPrefix);
			if (rhs !== void 0 && constant) this._constants[name.str] = rhs;
			this._leafNode(new Def(varKind, name, rhs));
			return name;
		}
		const(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		}
		let(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		}
		var(nameOrPrefix, rhs, _constant) {
			return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		}
		assign(lhs, rhs, sideEffects) {
			return this._leafNode(new Assign(lhs, rhs, sideEffects));
		}
		add(lhs, rhs) {
			return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		}
		code(c) {
			if (typeof c == "function") c();
			else if (c !== code_1$11.nil) this._leafNode(new AnyCode(c));
			return this;
		}
		object(...keyValues) {
			const code = ["{"];
			for (const [key$1, value] of keyValues) {
				if (code.length > 1) code.push(",");
				code.push(key$1);
				if (key$1 !== value || this.opts.es5) {
					code.push(":");
					(0, code_1$11.addCodeArg)(code, value);
				}
			}
			code.push("}");
			return new code_1$11._Code(code);
		}
		if(condition, thenBody, elseBody) {
			this._blockNode(new If(condition));
			if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();
			else if (thenBody) this.code(thenBody).endIf();
			else if (elseBody) throw new Error("CodeGen: \"else\" body without \"then\" body");
			return this;
		}
		elseIf(condition) {
			return this._elseNode(new If(condition));
		}
		else() {
			return this._elseNode(new Else());
		}
		endIf() {
			return this._endBlockNode(If, Else);
		}
		_for(node, forBody) {
			this._blockNode(node);
			if (forBody) this.code(forBody).endFor();
			return this;
		}
		for(iteration, forBody) {
			return this._for(new ForLoop(iteration), forBody);
		}
		forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		}
		forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
			const name = this._scope.toName(nameOrPrefix);
			if (this.opts.es5) {
				const arr = iterable instanceof code_1$11.Name ? iterable : this.var("_arr", iterable);
				return this.forRange("_i", 0, (0, code_1$11._)`${arr}.length`, (i$3) => {
					this.var(name, (0, code_1$11._)`${arr}[${i$3}]`);
					forBody(name);
				});
			}
			return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		}
		forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
			if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, code_1$11._)`Object.keys(${obj})`, forBody);
			const name = this._scope.toName(nameOrPrefix);
			return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		}
		endFor() {
			return this._endBlockNode(For);
		}
		label(label) {
			return this._leafNode(new Label(label));
		}
		break(label) {
			return this._leafNode(new Break(label));
		}
		return(value) {
			const node = new Return();
			this._blockNode(node);
			this.code(value);
			if (node.nodes.length !== 1) throw new Error("CodeGen: \"return\" should have one node");
			return this._endBlockNode(Return);
		}
		try(tryBody, catchCode, finallyCode) {
			if (!catchCode && !finallyCode) throw new Error("CodeGen: \"try\" without \"catch\" and \"finally\"");
			const node = new Try();
			this._blockNode(node);
			this.code(tryBody);
			if (catchCode) {
				const error$1 = this.name("e");
				this._currNode = node.catch = new Catch(error$1);
				catchCode(error$1);
			}
			if (finallyCode) {
				this._currNode = node.finally = new Finally();
				this.code(finallyCode);
			}
			return this._endBlockNode(Catch, Finally);
		}
		throw(error$1) {
			return this._leafNode(new Throw(error$1));
		}
		block(body, nodeCount) {
			this._blockStarts.push(this._nodes.length);
			if (body) this.code(body).endBlock(nodeCount);
			return this;
		}
		endBlock(nodeCount) {
			const len = this._blockStarts.pop();
			if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
			const toClose = this._nodes.length - len;
			if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
			this._nodes.length = len;
			return this;
		}
		func(name, args = code_1$11.nil, async, funcBody) {
			this._blockNode(new Func(name, args, async));
			if (funcBody) this.code(funcBody).endFunc();
			return this;
		}
		endFunc() {
			return this._endBlockNode(Func);
		}
		optimize(n = 1) {
			while (n-- > 0) {
				this._root.optimizeNodes();
				this._root.optimizeNames(this._root.names, this._constants);
			}
		}
		_leafNode(node) {
			this._currNode.nodes.push(node);
			return this;
		}
		_blockNode(node) {
			this._currNode.nodes.push(node);
			this._nodes.push(node);
		}
		_endBlockNode(N1, N2) {
			const n = this._currNode;
			if (n instanceof N1 || N2 && n instanceof N2) {
				this._nodes.pop();
				return this;
			}
			throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		}
		_elseNode(node) {
			const n = this._currNode;
			if (!(n instanceof If)) throw new Error("CodeGen: \"else\" without \"if\"");
			this._currNode = n.else = node;
			return this;
		}
		get _root() {
			return this._nodes[0];
		}
		get _currNode() {
			const ns = this._nodes;
			return ns[ns.length - 1];
		}
		set _currNode(node) {
			const ns = this._nodes;
			ns[ns.length - 1] = node;
		}
	};
	exports.CodeGen = CodeGen;
	function addNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) + (from[n] || 0);
		return names$1;
	}
	function addExprNames(names$1, from) {
		return from instanceof code_1$11._CodeOrName ? addNames(names$1, from.names) : names$1;
	}
	function optimizeExpr(expr, names$1, constants) {
		if (expr instanceof code_1$11.Name) return replaceName(expr);
		if (!canOptimize(expr)) return expr;
		return new code_1$11._Code(expr._items.reduce((items, c) => {
			if (c instanceof code_1$11.Name) c = replaceName(c);
			if (c instanceof code_1$11._Code) items.push(...c._items);
			else items.push(c);
			return items;
		}, []));
		function replaceName(n) {
			const c = constants[n.str];
			if (c === void 0 || names$1[n.str] !== 1) return n;
			delete names$1[n.str];
			return c;
		}
		function canOptimize(e) {
			return e instanceof code_1$11._Code && e._items.some((c) => c instanceof code_1$11.Name && names$1[c.str] === 1 && constants[c.str] !== void 0);
		}
	}
	function subtractNames(names$1, from) {
		for (const n in from) names$1[n] = (names$1[n] || 0) - (from[n] || 0);
	}
	function not(x) {
		return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1$11._)`!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	function and(...args) {
		return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	function or(...args) {
		return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
		return (x, y) => x === code_1$11.nil ? y : y === code_1$11.nil ? x : (0, code_1$11._)`${par(x)} ${op} ${par(y)}`;
	}
	function par(x) {
		return x instanceof code_1$11.Name ? x : (0, code_1$11._)`(${x})`;
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js
var require_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
	const codegen_1$37 = require_codegen();
	const code_1$10 = require_code$1();
	function toHash(arr) {
		const hash = {};
		for (const item of arr) hash[item] = true;
		return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema) {
		if (typeof schema == "boolean") return schema;
		if (Object.keys(schema).length === 0) return true;
		checkUnknownRules(it, schema);
		return !schemaHasRules(schema, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
		const { opts, self } = it;
		if (!opts.strictSchema) return;
		if (typeof schema === "boolean") return;
		const rules = self.RULES.keywords;
		for (const key$1 in schema) if (!rules[key$1]) checkStrictMode(it, `unknown keyword: "${key$1}"`);
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
		if (typeof schema == "boolean") return !schema;
		for (const key$1 in schema) if (rules[key$1]) return true;
		return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
		if (typeof schema == "boolean") return !schema;
		for (const key$1 in schema) if (key$1 !== "$ref" && RULES.all[key$1]) return true;
		return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
		if (!$data) {
			if (typeof schema == "number" || typeof schema == "boolean") return schema;
			if (typeof schema == "string") return (0, codegen_1$37._)`${schema}`;
		}
		return (0, codegen_1$37._)`${topSchemaRef}${schemaPath}${(0, codegen_1$37.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str$1) {
		return unescapeJsonPointer(decodeURIComponent(str$1));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str$1) {
		return encodeURIComponent(escapeJsonPointer(str$1));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str$1) {
		if (typeof str$1 == "number") return `${str$1}`;
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str$1) {
		return str$1.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
		if (Array.isArray(xs)) for (const x of xs) f(x);
		else f(xs);
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues$1, resultToName }) {
		return (gen, from, to, toName) => {
			const res = to === void 0 ? from : to instanceof codegen_1$37.Name ? (from instanceof codegen_1$37.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$37.Name ? (mergeToName(gen, to, from), from) : mergeValues$1(from, to);
			return toName === codegen_1$37.Name && !(res instanceof codegen_1$37.Name) ? resultToName(gen, res) : res;
		};
	}
	exports.mergeEvaluated = {
		props: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$37._)`${to} !== true && ${from} !== undefined`, () => {
				gen.if((0, codegen_1$37._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$37._)`${to} || {}`).code((0, codegen_1$37._)`Object.assign(${to}, ${from})`));
			}),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$37._)`${to} !== true`, () => {
				if (from === true) gen.assign(to, true);
				else {
					gen.assign(to, (0, codegen_1$37._)`${to} || {}`);
					setEvaluated(gen, to, from);
				}
			}),
			mergeValues: (from, to) => from === true ? true : {
				...from,
				...to
			},
			resultToName: evaluatedPropsToName
		}),
		items: makeMergeEvaluated({
			mergeNames: (gen, from, to) => gen.if((0, codegen_1$37._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$37._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
			mergeToName: (gen, from, to) => gen.if((0, codegen_1$37._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$37._)`${to} > ${from} ? ${to} : ${from}`)),
			mergeValues: (from, to) => from === true ? true : Math.max(from, to),
			resultToName: (gen, items) => gen.var("items", items)
		})
	};
	function evaluatedPropsToName(gen, ps) {
		if (ps === true) return gen.var("props", true);
		const props = gen.var("props", (0, codegen_1$37._)`{}`);
		if (ps !== void 0) setEvaluated(gen, props, ps);
		return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
		Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$37._)`${props}${(0, codegen_1$37.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
		return gen.scopeValue("func", {
			ref: f,
			code: snippets[f.code] || (snippets[f.code] = new code_1$10._Code(f.code))
		});
	}
	exports.useFunc = useFunc;
	var Type;
	(function(Type$1) {
		Type$1[Type$1["Num"] = 0] = "Num";
		Type$1[Type$1["Str"] = 1] = "Str";
	})(Type || (exports.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
		if (dataProp instanceof codegen_1$37.Name) {
			const isNumber = dataPropType === Type.Num;
			return jsPropertySyntax ? isNumber ? (0, codegen_1$37._)`"[" + ${dataProp} + "]"` : (0, codegen_1$37._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$37._)`"/" + ${dataProp}` : (0, codegen_1$37._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
		}
		return jsPropertySyntax ? (0, codegen_1$37.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
		if (!mode) return;
		msg = `strict mode: ${msg}`;
		if (mode === true) throw new Error(msg);
		it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js
var require_names = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$36 = require_codegen();
	const names = {
		data: new codegen_1$36.Name("data"),
		valCxt: new codegen_1$36.Name("valCxt"),
		instancePath: new codegen_1$36.Name("instancePath"),
		parentData: new codegen_1$36.Name("parentData"),
		parentDataProperty: new codegen_1$36.Name("parentDataProperty"),
		rootData: new codegen_1$36.Name("rootData"),
		dynamicAnchors: new codegen_1$36.Name("dynamicAnchors"),
		vErrors: new codegen_1$36.Name("vErrors"),
		errors: new codegen_1$36.Name("errors"),
		this: new codegen_1$36.Name("this"),
		self: new codegen_1$36.Name("self"),
		scope: new codegen_1$36.Name("scope"),
		json: new codegen_1$36.Name("json"),
		jsonPos: new codegen_1$36.Name("jsonPos"),
		jsonLen: new codegen_1$36.Name("jsonLen"),
		jsonPart: new codegen_1$36.Name("jsonPart")
	};
	exports.default = names;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js
var require_errors = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1$35 = require_codegen();
	const util_1$29 = require_util();
	const names_1$7 = require_names();
	exports.keywordError = { message: ({ keyword }) => (0, codegen_1$35.str)`must pass "${keyword}" keyword validation` };
	exports.keyword$DataError = { message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1$35.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1$35.str)`"${keyword}" keyword is invalid ($data)` };
	function reportError(cxt, error$1 = exports.keywordError, errorPaths, overrideAllErrors) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		const errObj = errorObjectCode(cxt, error$1, errorPaths);
		if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) addError(gen, errObj);
		else returnErrors(it, (0, codegen_1$35._)`[${errObj}]`);
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error$1 = exports.keywordError, errorPaths) {
		const { it } = cxt;
		const { gen, compositeRule, allErrors } = it;
		addError(gen, errorObjectCode(cxt, error$1, errorPaths));
		if (!(compositeRule || allErrors)) returnErrors(it, names_1$7.default.vErrors);
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
		gen.assign(names_1$7.default.errors, errsCount);
		gen.if((0, codegen_1$35._)`${names_1$7.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1$35._)`${names_1$7.default.vErrors}.length`, errsCount), () => gen.assign(names_1$7.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
		/* istanbul ignore if */
		if (errsCount === void 0) throw new Error("ajv implementation error");
		const err = gen.name("err");
		gen.forRange("i", errsCount, names_1$7.default.errors, (i$3) => {
			gen.const(err, (0, codegen_1$35._)`${names_1$7.default.vErrors}[${i$3}]`);
			gen.if((0, codegen_1$35._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1$35._)`${err}.instancePath`, (0, codegen_1$35.strConcat)(names_1$7.default.instancePath, it.errorPath)));
			gen.assign((0, codegen_1$35._)`${err}.schemaPath`, (0, codegen_1$35.str)`${it.errSchemaPath}/${keyword}`);
			if (it.opts.verbose) {
				gen.assign((0, codegen_1$35._)`${err}.schema`, schemaValue);
				gen.assign((0, codegen_1$35._)`${err}.data`, data);
			}
		});
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
		const err = gen.const("err", errObj);
		gen.if((0, codegen_1$35._)`${names_1$7.default.vErrors} === null`, () => gen.assign(names_1$7.default.vErrors, (0, codegen_1$35._)`[${err}]`), (0, codegen_1$35._)`${names_1$7.default.vErrors}.push(${err})`);
		gen.code((0, codegen_1$35._)`${names_1$7.default.errors}++`);
	}
	function returnErrors(it, errs) {
		const { gen, validateName, schemaEnv } = it;
		if (schemaEnv.$async) gen.throw((0, codegen_1$35._)`new ${it.ValidationError}(${errs})`);
		else {
			gen.assign((0, codegen_1$35._)`${validateName}.errors`, errs);
			gen.return(false);
		}
	}
	const E = {
		keyword: new codegen_1$35.Name("keyword"),
		schemaPath: new codegen_1$35.Name("schemaPath"),
		params: new codegen_1$35.Name("params"),
		propertyName: new codegen_1$35.Name("propertyName"),
		message: new codegen_1$35.Name("message"),
		schema: new codegen_1$35.Name("schema"),
		parentSchema: new codegen_1$35.Name("parentSchema")
	};
	function errorObjectCode(cxt, error$1, errorPaths) {
		const { createErrors } = cxt.it;
		if (createErrors === false) return (0, codegen_1$35._)`{}`;
		return errorObject(cxt, error$1, errorPaths);
	}
	function errorObject(cxt, error$1, errorPaths = {}) {
		const { gen, it } = cxt;
		const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];
		extraErrorProps(cxt, error$1, keyValues);
		return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
		const instPath = instancePath ? (0, codegen_1$35.str)`${errorPath}${(0, util_1$29.getErrorPath)(instancePath, util_1$29.Type.Str)}` : errorPath;
		return [names_1$7.default.instancePath, (0, codegen_1$35.strConcat)(names_1$7.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		let schPath = parentSchema ? errSchemaPath : (0, codegen_1$35.str)`${errSchemaPath}/${keyword}`;
		if (schemaPath) schPath = (0, codegen_1$35.str)`${schPath}${(0, util_1$29.getErrorPath)(schemaPath, util_1$29.Type.Str)}`;
		return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
		const { keyword, data, schemaValue, it } = cxt;
		const { opts, propertyName, topSchemaRef, schemaPath } = it;
		keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1$35._)`{}`]);
		if (opts.messages) keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		if (opts.verbose) keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1$35._)`${topSchemaRef}${schemaPath}`], [names_1$7.default.data, data]);
		if (propertyName) keyValues.push([E.propertyName, propertyName]);
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
	const errors_1$3 = require_errors();
	const codegen_1$34 = require_codegen();
	const names_1$6 = require_names();
	const boolError = { message: "boolean schema is false" };
	function topBoolOrEmptySchema(it) {
		const { gen, schema, validateName } = it;
		if (schema === false) falseSchemaError(it, false);
		else if (typeof schema == "object" && schema.$async === true) gen.return(names_1$6.default.data);
		else {
			gen.assign((0, codegen_1$34._)`${validateName}.errors`, null);
			gen.return(true);
		}
	}
	exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
		const { gen, schema } = it;
		if (schema === false) {
			gen.var(valid, false);
			falseSchemaError(it);
		} else gen.var(valid, true);
	}
	exports.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
		const { gen, data } = it;
		const cxt = {
			gen,
			keyword: "false schema",
			data,
			schema: false,
			schemaCode: false,
			schemaValue: false,
			params: {},
			it
		};
		(0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRules = exports.isJSONType = void 0;
	const jsonTypes = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null",
		"object",
		"array"
	]);
	function isJSONType(x) {
		return typeof x == "string" && jsonTypes.has(x);
	}
	exports.isJSONType = isJSONType;
	function getRules() {
		const groups = {
			number: {
				type: "number",
				rules: []
			},
			string: {
				type: "string",
				rules: []
			},
			array: {
				type: "array",
				rules: []
			},
			object: {
				type: "object",
				rules: []
			}
		};
		return {
			types: {
				...groups,
				integer: true,
				boolean: true,
				null: true
			},
			rules: [
				{ rules: [] },
				groups.number,
				groups.string,
				groups.array,
				groups.object
			],
			post: { rules: [] },
			all: {},
			keywords: {}
		};
	}
	exports.getRules = getRules;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
		const group = self.RULES.types[type];
		return group && group !== true && shouldUseGroup(schema, group);
	}
	exports.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
		return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	exports.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
		var _a;
		return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
	}
	exports.shouldUseRule = shouldUseRule;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
	const rules_1$1 = require_rules();
	const applicability_1$1 = require_applicability();
	const errors_1$2 = require_errors();
	const codegen_1$33 = require_codegen();
	const util_1$28 = require_util();
	var DataType;
	(function(DataType$1) {
		DataType$1[DataType$1["Correct"] = 0] = "Correct";
		DataType$1[DataType$1["Wrong"] = 1] = "Wrong";
	})(DataType || (exports.DataType = DataType = {}));
	function getSchemaTypes(schema) {
		const types = getJSONTypes(schema.type);
		if (types.includes("null")) {
			if (schema.nullable === false) throw new Error("type: null contradicts nullable: false");
		} else {
			if (!types.length && schema.nullable !== void 0) throw new Error("\"nullable\" cannot be used without \"type\"");
			if (schema.nullable === true) types.push("null");
		}
		return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
		const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
		if (types.every(rules_1$1.isJSONType)) return types;
		throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
		const { gen, data, opts } = it;
		const coerceTo = coerceToTypes(types, opts.coerceTypes);
		const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types[0]));
		if (checkTypes) {
			const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
			gen.if(wrongType, () => {
				if (coerceTo.length) coerceData(it, types, coerceTo);
				else reportTypeError(it);
			});
		}
		return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(types, coerceTypes) {
		return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
	}
	function coerceData(it, types, coerceTo) {
		const { gen, data, opts } = it;
		const dataType = gen.let("dataType", (0, codegen_1$33._)`typeof ${data}`);
		const coerced = gen.let("coerced", (0, codegen_1$33._)`undefined`);
		if (opts.coerceTypes === "array") gen.if((0, codegen_1$33._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$33._)`${data}[0]`).assign(dataType, (0, codegen_1$33._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
		gen.if((0, codegen_1$33._)`${coerced} !== undefined`);
		for (const t of coerceTo) if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") coerceSpecificType(t);
		gen.else();
		reportTypeError(it);
		gen.endIf();
		gen.if((0, codegen_1$33._)`${coerced} !== undefined`, () => {
			gen.assign(data, coerced);
			assignParentData(it, coerced);
		});
		function coerceSpecificType(t) {
			switch (t) {
				case "string":
					gen.elseIf((0, codegen_1$33._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1$33._)`"" + ${data}`).elseIf((0, codegen_1$33._)`${data} === null`).assign(coerced, (0, codegen_1$33._)`""`);
					return;
				case "number":
					gen.elseIf((0, codegen_1$33._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$33._)`+${data}`);
					return;
				case "integer":
					gen.elseIf((0, codegen_1$33._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$33._)`+${data}`);
					return;
				case "boolean":
					gen.elseIf((0, codegen_1$33._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$33._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
					return;
				case "null":
					gen.elseIf((0, codegen_1$33._)`${data} === "" || ${data} === 0 || ${data} === false`);
					gen.assign(coerced, null);
					return;
				case "array": gen.elseIf((0, codegen_1$33._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$33._)`[${data}]`);
			}
		}
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
		gen.if((0, codegen_1$33._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$33._)`${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
		const EQ = correct === DataType.Correct ? codegen_1$33.operators.EQ : codegen_1$33.operators.NEQ;
		let cond;
		switch (dataType) {
			case "null": return (0, codegen_1$33._)`${data} ${EQ} null`;
			case "array":
				cond = (0, codegen_1$33._)`Array.isArray(${data})`;
				break;
			case "object":
				cond = (0, codegen_1$33._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
				break;
			case "integer":
				cond = numCond((0, codegen_1$33._)`!(${data} % 1) && !isNaN(${data})`);
				break;
			case "number":
				cond = numCond();
				break;
			default: return (0, codegen_1$33._)`typeof ${data} ${EQ} ${dataType}`;
		}
		return correct === DataType.Correct ? cond : (0, codegen_1$33.not)(cond);
		function numCond(_cond = codegen_1$33.nil) {
			return (0, codegen_1$33.and)((0, codegen_1$33._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$33._)`isFinite(${data})` : codegen_1$33.nil);
		}
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
		if (dataTypes.length === 1) return checkDataType(dataTypes[0], data, strictNums, correct);
		let cond;
		const types = (0, util_1$28.toHash)(dataTypes);
		if (types.array && types.object) {
			const notObj = (0, codegen_1$33._)`typeof ${data} != "object"`;
			cond = types.null ? notObj : (0, codegen_1$33._)`!${data} || ${notObj}`;
			delete types.null;
			delete types.array;
			delete types.object;
		} else cond = codegen_1$33.nil;
		if (types.number) delete types.integer;
		for (const t in types) cond = (0, codegen_1$33.and)(cond, checkDataType(t, data, strictNums, correct));
		return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
		message: ({ schema }) => `must be ${schema}`,
		params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$33._)`{type: ${schema}}` : (0, codegen_1$33._)`{type: ${schemaValue}}`
	};
	function reportTypeError(it) {
		const cxt = getTypeErrorContext(it);
		(0, errors_1$2.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
		const { gen, data, schema } = it;
		const schemaCode = (0, util_1$28.schemaRefOrVal)(it, schema, "type");
		return {
			gen,
			keyword: "type",
			data,
			schema: schema.type,
			schemaCode,
			schemaValue: schemaCode,
			parentSchema: schema,
			params: {},
			it
		};
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.assignDefaults = void 0;
	const codegen_1$32 = require_codegen();
	const util_1$27 = require_util();
	function assignDefaults(it, ty) {
		const { properties, items } = it.schema;
		if (ty === "object" && properties) for (const key$1 in properties) assignDefault(it, key$1, properties[key$1].default);
		else if (ty === "array" && Array.isArray(items)) items.forEach((sch, i$3) => assignDefault(it, i$3, sch.default));
	}
	exports.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
		const { gen, compositeRule, data, opts } = it;
		if (defaultValue === void 0) return;
		const childData = (0, codegen_1$32._)`${data}${(0, codegen_1$32.getProperty)(prop)}`;
		if (compositeRule) {
			(0, util_1$27.checkStrictMode)(it, `default is ignored for: ${childData}`);
			return;
		}
		let condition = (0, codegen_1$32._)`${childData} === undefined`;
		if (opts.useDefaults === "empty") condition = (0, codegen_1$32._)`${condition} || ${childData} === null || ${childData} === ""`;
		gen.if(condition, (0, codegen_1$32._)`${childData} = ${(0, codegen_1$32.stringify)(defaultValue)}`);
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js
var require_code = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
	const codegen_1$31 = require_codegen();
	const util_1$26 = require_util();
	const names_1$5 = require_names();
	const util_2$1 = require_util();
	function checkReportMissingProp(cxt, prop) {
		const { gen, data, it } = cxt;
		gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
			cxt.setParams({ missingProperty: (0, codegen_1$31._)`${prop}` }, true);
			cxt.error();
		});
	}
	exports.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
		return (0, codegen_1$31.or)(...properties.map((prop) => (0, codegen_1$31.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$31._)`${missing} = ${prop}`)));
	}
	exports.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
		cxt.setParams({ missingProperty: missing }, true);
		cxt.error();
	}
	exports.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
		return gen.scopeValue("func", {
			ref: Object.prototype.hasOwnProperty,
			code: (0, codegen_1$31._)`Object.prototype.hasOwnProperty`
		});
	}
	exports.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
		return (0, codegen_1$31._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	exports.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$31._)`${data}${(0, codegen_1$31.getProperty)(property)} !== undefined`;
		return ownProperties ? (0, codegen_1$31._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	exports.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
		const cond = (0, codegen_1$31._)`${data}${(0, codegen_1$31.getProperty)(property)} === undefined`;
		return ownProperties ? (0, codegen_1$31.or)(cond, (0, codegen_1$31.not)(isOwnProperty(gen, data, property))) : cond;
	}
	exports.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
		return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	exports.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
		return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$26.alwaysValidSchema)(it, schemaMap[p]));
	}
	exports.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
		const dataAndSchema = passSchema ? (0, codegen_1$31._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
		const valCxt = [
			[names_1$5.default.instancePath, (0, codegen_1$31.strConcat)(names_1$5.default.instancePath, errorPath)],
			[names_1$5.default.parentData, it.parentData],
			[names_1$5.default.parentDataProperty, it.parentDataProperty],
			[names_1$5.default.rootData, names_1$5.default.rootData]
		];
		if (it.opts.dynamicRef) valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
		const args = (0, codegen_1$31._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
		return context !== codegen_1$31.nil ? (0, codegen_1$31._)`${func}.call(${context}, ${args})` : (0, codegen_1$31._)`${func}(${args})`;
	}
	exports.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1$31._)`new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
		const u = opts.unicodeRegExp ? "u" : "";
		const { regExp } = opts.code;
		const rx = regExp(pattern, u);
		return gen.scopeValue("pattern", {
			key: rx.toString(),
			ref: rx,
			code: (0, codegen_1$31._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`
		});
	}
	exports.usePattern = usePattern;
	function validateArray(cxt) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		if (it.allErrors) {
			const validArr = gen.let("valid", true);
			validateItems(() => gen.assign(validArr, false));
			return validArr;
		}
		gen.var(valid, true);
		validateItems(() => gen.break());
		return valid;
		function validateItems(notValid) {
			const len = gen.const("len", (0, codegen_1$31._)`${data}.length`);
			gen.forRange("i", 0, len, (i$3) => {
				cxt.subschema({
					keyword,
					dataProp: i$3,
					dataPropType: util_1$26.Type.Num
				}, valid);
				gen.if((0, codegen_1$31.not)(valid), notValid);
			});
		}
	}
	exports.validateArray = validateArray;
	function validateUnion(cxt) {
		const { gen, schema, keyword, it } = cxt;
		/* istanbul ignore if */
		if (!Array.isArray(schema)) throw new Error("ajv implementation error");
		if (schema.some((sch) => (0, util_1$26.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated) return;
		const valid = gen.let("valid", false);
		const schValid = gen.name("_valid");
		gen.block(() => schema.forEach((_sch, i$3) => {
			const schCxt = cxt.subschema({
				keyword,
				schemaProp: i$3,
				compositeRule: true
			}, schValid);
			gen.assign(valid, (0, codegen_1$31._)`${valid} || ${schValid}`);
			if (!cxt.mergeValidEvaluated(schCxt, schValid)) gen.if((0, codegen_1$31.not)(valid));
		}));
		cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	exports.validateUnion = validateUnion;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
	const codegen_1$30 = require_codegen();
	const names_1$4 = require_names();
	const code_1$9 = require_code();
	const errors_1$1 = require_errors();
	function macroKeywordCode(cxt, def$30) {
		const { gen, keyword, schema, parentSchema, it } = cxt;
		const macroSchema = def$30.macro.call(it.self, schema, parentSchema, it);
		const schemaRef = useKeyword(gen, keyword, macroSchema);
		if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);
		const valid = gen.name("valid");
		cxt.subschema({
			schema: macroSchema,
			schemaPath: codegen_1$30.nil,
			errSchemaPath: `${it.errSchemaPath}/${keyword}`,
			topSchemaRef: schemaRef,
			compositeRule: true
		}, valid);
		cxt.pass(valid, () => cxt.error(true));
	}
	exports.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def$30) {
		var _a;
		const { gen, keyword, schema, parentSchema, $data, it } = cxt;
		checkAsyncKeyword(it, def$30);
		const validateRef = useKeyword(gen, keyword, !$data && def$30.compile ? def$30.compile.call(it.self, schema, parentSchema, it) : def$30.validate);
		const valid = gen.let("valid");
		cxt.block$data(valid, validateKeyword);
		cxt.ok((_a = def$30.valid) !== null && _a !== void 0 ? _a : valid);
		function validateKeyword() {
			if (def$30.errors === false) {
				assignValid();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => cxt.error());
			} else {
				const ruleErrs = def$30.async ? validateAsync() : validateSync();
				if (def$30.modifying) modifyData(cxt);
				reportErrs(() => addErrs(cxt, ruleErrs));
			}
		}
		function validateAsync() {
			const ruleErrs = gen.let("ruleErrs", null);
			gen.try(() => assignValid((0, codegen_1$30._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1$30._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$30._)`${e}.errors`), () => gen.throw(e)));
			return ruleErrs;
		}
		function validateSync() {
			const validateErrs = (0, codegen_1$30._)`${validateRef}.errors`;
			gen.assign(validateErrs, null);
			assignValid(codegen_1$30.nil);
			return validateErrs;
		}
		function assignValid(_await = def$30.async ? (0, codegen_1$30._)`await ` : codegen_1$30.nil) {
			const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
			const passSchema = !("compile" in def$30 && !$data || def$30.schema === false);
			gen.assign(valid, (0, codegen_1$30._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def$30.modifying);
		}
		function reportErrs(errors) {
			var _a$1;
			gen.if((0, codegen_1$30.not)((_a$1 = def$30.valid) !== null && _a$1 !== void 0 ? _a$1 : valid), errors);
		}
	}
	exports.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
		const { gen, data, it } = cxt;
		gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$30._)`${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
		const { gen } = cxt;
		gen.if((0, codegen_1$30._)`Array.isArray(${errs})`, () => {
			gen.assign(names_1$4.default.vErrors, (0, codegen_1$30._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$30._)`${names_1$4.default.vErrors}.length`);
			(0, errors_1$1.extendErrors)(cxt);
		}, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def$30) {
		if (def$30.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
		if (result === void 0) throw new Error(`keyword "${keyword}" failed to compile`);
		return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : {
			ref: result,
			code: (0, codegen_1$30.stringify)(result)
		});
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
		return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
	}
	exports.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def$30, keyword) {
		/* istanbul ignore if */
		if (Array.isArray(def$30.keyword) ? !def$30.keyword.includes(keyword) : def$30.keyword !== keyword) throw new Error("ajv implementation error");
		const deps = def$30.dependencies;
		if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
		if (def$30.validateSchema) {
			if (!def$30.validateSchema(schema[keyword])) {
				const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def$30.validateSchema.errors);
				if (opts.validateSchema === "log") self.logger.error(msg);
				else throw new Error(msg);
			}
		}
	}
	exports.validateKeywordUsage = validateKeywordUsage;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
	const codegen_1$29 = require_codegen();
	const util_1$25 = require_util();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
		if (keyword !== void 0 && schema !== void 0) throw new Error("both \"keyword\" and \"schema\" passed, only one allowed");
		if (keyword !== void 0) {
			const sch = it.schema[keyword];
			return schemaProp === void 0 ? {
				schema: sch,
				schemaPath: (0, codegen_1$29._)`${it.schemaPath}${(0, codegen_1$29.getProperty)(keyword)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}`
			} : {
				schema: sch[schemaProp],
				schemaPath: (0, codegen_1$29._)`${it.schemaPath}${(0, codegen_1$29.getProperty)(keyword)}${(0, codegen_1$29.getProperty)(schemaProp)}`,
				errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1$25.escapeFragment)(schemaProp)}`
			};
		}
		if (schema !== void 0) {
			if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) throw new Error("\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"");
			return {
				schema,
				schemaPath,
				topSchemaRef,
				errSchemaPath
			};
		}
		throw new Error("either \"keyword\" or \"schema\" must be passed");
	}
	exports.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
		if (data !== void 0 && dataProp !== void 0) throw new Error("both \"data\" and \"dataProp\" passed, only one allowed");
		const { gen } = it;
		if (dataProp !== void 0) {
			const { errorPath, dataPathArr, opts } = it;
			dataContextProps(gen.let("data", (0, codegen_1$29._)`${it.data}${(0, codegen_1$29.getProperty)(dataProp)}`, true));
			subschema.errorPath = (0, codegen_1$29.str)`${errorPath}${(0, util_1$25.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
			subschema.parentDataProperty = (0, codegen_1$29._)`${dataProp}`;
			subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
		}
		if (data !== void 0) {
			dataContextProps(data instanceof codegen_1$29.Name ? data : gen.let("data", data, true));
			if (propertyName !== void 0) subschema.propertyName = propertyName;
		}
		if (dataTypes) subschema.dataTypes = dataTypes;
		function dataContextProps(_nextData) {
			subschema.data = _nextData;
			subschema.dataLevel = it.dataLevel + 1;
			subschema.dataTypes = [];
			it.definedProperties = /* @__PURE__ */ new Set();
			subschema.parentData = it.data;
			subschema.dataNames = [...it.dataNames, _nextData];
		}
	}
	exports.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
		if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
		if (createErrors !== void 0) subschema.createErrors = createErrors;
		if (allErrors !== void 0) subschema.allErrors = allErrors;
		subschema.jtdDiscriminator = jtdDiscriminator;
		subschema.jtdMetadata = jtdMetadata;
	}
	exports.extendSubschemaMode = extendSubschemaMode;
}));

//#endregion
//#region node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function equal$3(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i$3, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i$3 = length; i$3-- !== 0;) if (!equal$3(a[i$3], b[i$3])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i$3 = length; i$3-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i$3])) return false;
			for (i$3 = length; i$3-- !== 0;) {
				var key$1 = keys[i$3];
				if (!equal$3(a[key$1], b[key$1])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}));

//#endregion
//#region node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var traverse$1 = module.exports = function(schema, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema, "", schema);
	};
	traverse$1.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true,
		if: true,
		then: true,
		else: true
	};
	traverse$1.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse$1.propsKeywords = {
		$defs: true,
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse$1.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema && typeof schema == "object" && !Array.isArray(schema)) {
			pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key$1 in schema) {
				var sch = schema[key$1];
				if (Array.isArray(sch)) {
					if (key$1 in traverse$1.arrayKeywords) for (var i$3 = 0; i$3 < sch.length; i$3++) _traverse(opts, pre, post, sch[i$3], jsonPtr + "/" + key$1 + "/" + i$3, rootSchema, jsonPtr, key$1, schema, i$3);
				} else if (key$1 in traverse$1.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key$1 + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key$1, schema, prop);
				} else if (key$1 in traverse$1.keywords || opts.allKeys && !(key$1 in traverse$1.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key$1, rootSchema, jsonPtr, key$1, schema);
			}
			post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str$1) {
		return str$1.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
	const util_1$24 = require_util();
	const equal$2 = require_fast_deep_equal();
	const traverse = require_json_schema_traverse();
	const SIMPLE_INLINED = new Set([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum",
		"const"
	]);
	function inlineRef(schema, limit = true) {
		if (typeof schema == "boolean") return true;
		if (limit === true) return !hasRef(schema);
		if (!limit) return false;
		return countKeys(schema) <= limit;
	}
	exports.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
		"$ref",
		"$recursiveRef",
		"$recursiveAnchor",
		"$dynamicRef",
		"$dynamicAnchor"
	]);
	function hasRef(schema) {
		for (const key$1 in schema) {
			if (REF_KEYWORDS.has(key$1)) return true;
			const sch = schema[key$1];
			if (Array.isArray(sch) && sch.some(hasRef)) return true;
			if (typeof sch == "object" && hasRef(sch)) return true;
		}
		return false;
	}
	function countKeys(schema) {
		let count = 0;
		for (const key$1 in schema) {
			if (key$1 === "$ref") return Infinity;
			count++;
			if (SIMPLE_INLINED.has(key$1)) continue;
			if (typeof schema[key$1] == "object") (0, util_1$24.eachItem)(schema[key$1], (sch) => count += countKeys(sch));
			if (count === Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(resolver, id = "", normalize$1) {
		if (normalize$1 !== false) id = normalizeId(id);
		return _getFullPath(resolver, resolver.parse(id));
	}
	exports.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
		return resolver.serialize(p).split("#")[0] + "#";
	}
	exports._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	exports.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
		id = normalizeId(id);
		return resolver.resolve(baseId, id);
	}
	exports.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
		if (typeof schema == "boolean") return {};
		const { schemaId, uriResolver } = this.opts;
		const schId = normalizeId(schema[schemaId] || baseId);
		const baseIds = { "": schId };
		const pathPrefix = getFullPath(uriResolver, schId, false);
		const localRefs = {};
		const schemaRefs = /* @__PURE__ */ new Set();
		traverse(schema, { allKeys: true }, (sch, jsonPtr, _$1, parentJsonPtr) => {
			if (parentJsonPtr === void 0) return;
			const fullPath = pathPrefix + jsonPtr;
			let innerBaseId = baseIds[parentJsonPtr];
			if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
			addAnchor.call(this, sch.$anchor);
			addAnchor.call(this, sch.$dynamicAnchor);
			baseIds[jsonPtr] = innerBaseId;
			function addRef(ref) {
				const _resolve = this.opts.uriResolver.resolve;
				ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
				if (schemaRefs.has(ref)) throw ambiguos(ref);
				schemaRefs.add(ref);
				let schOrRef = this.refs[ref];
				if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
				if (typeof schOrRef == "object") checkAmbiguosRef(sch, schOrRef.schema, ref);
				else if (ref !== normalizeId(fullPath)) if (ref[0] === "#") {
					checkAmbiguosRef(sch, localRefs[ref], ref);
					localRefs[ref] = sch;
				} else this.refs[ref] = fullPath;
				return ref;
			}
			function addAnchor(anchor) {
				if (typeof anchor == "string") {
					if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
					addRef.call(this, `#${anchor}`);
				}
			}
		});
		return localRefs;
		function checkAmbiguosRef(sch1, sch2, ref) {
			if (sch2 !== void 0 && !equal$2(sch1, sch2)) throw ambiguos(ref);
		}
		function ambiguos(ref) {
			return /* @__PURE__ */ new Error(`reference "${ref}" resolves to more than one schema`);
		}
	}
	exports.getSchemaRefs = getSchemaRefs;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js
var require_validate = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
	const boolSchema_1 = require_boolSchema();
	const dataType_1$2 = require_dataType();
	const applicability_1 = require_applicability();
	const dataType_2 = require_dataType();
	const defaults_1 = require_defaults();
	const keyword_1 = require_keyword();
	const subschema_1 = require_subschema();
	const codegen_1$28 = require_codegen();
	const names_1$3 = require_names();
	const resolve_1$3 = require_resolve();
	const util_1$23 = require_util();
	const errors_1 = require_errors();
	function validateFunctionCode(it) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				topSchemaObjCode(it);
				return;
			}
		}
		validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	exports.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
		if (opts.code.es5) gen.func(validateName, (0, codegen_1$28._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
			gen.code((0, codegen_1$28._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
			destructureValCxtES5(gen, opts);
			gen.code(body);
		});
		else gen.func(validateName, (0, codegen_1$28._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	}
	function destructureValCxt(opts) {
		return (0, codegen_1$28._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$28._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$28.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
		gen.if(names_1$3.default.valCxt, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$28._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$28._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$28._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
			gen.var(names_1$3.default.rootData, (0, codegen_1$28._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$28._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
		}, () => {
			gen.var(names_1$3.default.instancePath, (0, codegen_1$28._)`""`);
			gen.var(names_1$3.default.parentData, (0, codegen_1$28._)`undefined`);
			gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$28._)`undefined`);
			gen.var(names_1$3.default.rootData, names_1$3.default.data);
			if (opts.dynamicRef) gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$28._)`{}`);
		});
	}
	function topSchemaObjCode(it) {
		const { schema, opts, gen } = it;
		validateFunction(it, () => {
			if (opts.$comment && schema.$comment) commentKeyword(it);
			checkNoDefault(it);
			gen.let(names_1$3.default.vErrors, null);
			gen.let(names_1$3.default.errors, 0);
			if (opts.unevaluated) resetEvaluated(it);
			typeAndKeywords(it);
			returnResults(it);
		});
	}
	function resetEvaluated(it) {
		const { gen, validateName } = it;
		it.evaluated = gen.const("evaluated", (0, codegen_1$28._)`${validateName}.evaluated`);
		gen.if((0, codegen_1$28._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$28._)`${it.evaluated}.props`, (0, codegen_1$28._)`undefined`));
		gen.if((0, codegen_1$28._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$28._)`${it.evaluated}.items`, (0, codegen_1$28._)`undefined`));
	}
	function funcSourceUrl(schema, opts) {
		const schId = typeof schema == "object" && schema[opts.schemaId];
		return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$28._)`/*# sourceURL=${schId} */` : codegen_1$28.nil;
	}
	function subschemaCode(it, valid) {
		if (isSchemaObj(it)) {
			checkKeywords(it);
			if (schemaCxtHasRules(it)) {
				subSchemaObjCode(it, valid);
				return;
			}
		}
		(0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
		if (typeof schema == "boolean") return !schema;
		for (const key$1 in schema) if (self.RULES.all[key$1]) return true;
		return false;
	}
	function isSchemaObj(it) {
		return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
		const { schema, gen, opts } = it;
		if (opts.$comment && schema.$comment) commentKeyword(it);
		updateContext(it);
		checkAsyncSchema(it);
		const errsCount = gen.const("_errs", names_1$3.default.errors);
		typeAndKeywords(it, errsCount);
		gen.var(valid, (0, codegen_1$28._)`${errsCount} === ${names_1$3.default.errors}`);
	}
	function checkKeywords(it) {
		(0, util_1$23.checkUnknownRules)(it);
		checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
		if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
		const types = (0, dataType_1$2.getSchemaTypes)(it.schema);
		schemaKeywords(it, types, !(0, dataType_1$2.coerceAndCheckDataType)(it, types), errsCount);
	}
	function checkRefsAndKeywords(it) {
		const { schema, errSchemaPath, opts, self } = it;
		if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$23.schemaHasRulesButRef)(schema, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	}
	function checkNoDefault(it) {
		const { schema, opts } = it;
		if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) (0, util_1$23.checkStrictMode)(it, "default is ignored in the schema root");
	}
	function updateContext(it) {
		const schId = it.schema[it.opts.schemaId];
		if (schId) it.baseId = (0, resolve_1$3.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
		if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
		const msg = schema.$comment;
		if (opts.$comment === true) gen.code((0, codegen_1$28._)`${names_1$3.default.self}.logger.log(${msg})`);
		else if (typeof opts.$comment == "function") {
			const schemaPath = (0, codegen_1$28.str)`${errSchemaPath}/$comment`;
			const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
			gen.code((0, codegen_1$28._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
		}
	}
	function returnResults(it) {
		const { gen, schemaEnv, validateName, ValidationError: ValidationError$1, opts } = it;
		if (schemaEnv.$async) gen.if((0, codegen_1$28._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$28._)`new ${ValidationError$1}(${names_1$3.default.vErrors})`));
		else {
			gen.assign((0, codegen_1$28._)`${validateName}.errors`, names_1$3.default.vErrors);
			if (opts.unevaluated) assignEvaluated(it);
			gen.return((0, codegen_1$28._)`${names_1$3.default.errors} === 0`);
		}
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
		if (props instanceof codegen_1$28.Name) gen.assign((0, codegen_1$28._)`${evaluated}.props`, props);
		if (items instanceof codegen_1$28.Name) gen.assign((0, codegen_1$28._)`${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
		const { gen, schema, data, allErrors, opts, self } = it;
		const { RULES } = self;
		if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$23.schemaHasRulesButRef)(schema, RULES))) {
			gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
			return;
		}
		if (!opts.jtd) checkStrictTypes(it, types);
		gen.block(() => {
			for (const group of RULES.rules) groupKeywords(group);
			groupKeywords(RULES.post);
		});
		function groupKeywords(group) {
			if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
			if (group.type) {
				gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
				iterateKeywords(it, group);
				if (types.length === 1 && types[0] === group.type && typeErrors) {
					gen.else();
					(0, dataType_2.reportTypeError)(it);
				}
				gen.endIf();
			} else iterateKeywords(it, group);
			if (!allErrors) gen.if((0, codegen_1$28._)`${names_1$3.default.errors} === ${errsCount || 0}`);
		}
	}
	function iterateKeywords(it, group) {
		const { gen, schema, opts: { useDefaults } } = it;
		if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
		gen.block(() => {
			for (const rule of group.rules) if ((0, applicability_1.shouldUseRule)(schema, rule)) keywordCode(it, rule.keyword, rule.definition, group.type);
		});
	}
	function checkStrictTypes(it, types) {
		if (it.schemaEnv.meta || !it.opts.strictTypes) return;
		checkContextTypes(it, types);
		if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
		checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
		if (!types.length) return;
		if (!it.dataTypes.length) {
			it.dataTypes = types;
			return;
		}
		types.forEach((t) => {
			if (!includesType(it.dataTypes, t)) strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
		});
		narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
		if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	}
	function checkKeywordTypes(it, ts) {
		const rules = it.self.RULES.all;
		for (const keyword in rules) {
			const rule = rules[keyword];
			if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
				const { type } = rule.definition;
				if (type.length && !type.some((t) => hasApplicableType(ts, t))) strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
			}
		}
	}
	function hasApplicableType(schTs, kwdT) {
		return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
	}
	function includesType(ts, t) {
		return ts.includes(t) || t === "integer" && ts.includes("number");
	}
	function narrowSchemaTypes(it, withTypes) {
		const ts = [];
		for (const t of it.dataTypes) if (includesType(withTypes, t)) ts.push(t);
		else if (withTypes.includes("integer") && t === "number") ts.push("integer");
		it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
		const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
		msg += ` at "${schemaPath}" (strictTypes)`;
		(0, util_1$23.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	var KeywordCxt = class {
		constructor(it, def$30, keyword) {
			(0, keyword_1.validateKeywordUsage)(it, def$30, keyword);
			this.gen = it.gen;
			this.allErrors = it.allErrors;
			this.keyword = keyword;
			this.data = it.data;
			this.schema = it.schema[keyword];
			this.$data = def$30.$data && it.opts.$data && this.schema && this.schema.$data;
			this.schemaValue = (0, util_1$23.schemaRefOrVal)(it, this.schema, keyword, this.$data);
			this.schemaType = def$30.schemaType;
			this.parentSchema = it.schema;
			this.params = {};
			this.it = it;
			this.def = def$30;
			if (this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
			else {
				this.schemaCode = this.schemaValue;
				if (!(0, keyword_1.validSchemaType)(this.schema, def$30.schemaType, def$30.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def$30.schemaType)}`);
			}
			if ("code" in def$30 ? def$30.trackErrors : def$30.errors !== false) this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
		}
		result(condition, successAction, failAction) {
			this.failResult((0, codegen_1$28.not)(condition), successAction, failAction);
		}
		failResult(condition, successAction, failAction) {
			this.gen.if(condition);
			if (failAction) failAction();
			else this.error();
			if (successAction) {
				this.gen.else();
				successAction();
				if (this.allErrors) this.gen.endIf();
			} else if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		pass(condition, failAction) {
			this.failResult((0, codegen_1$28.not)(condition), void 0, failAction);
		}
		fail(condition) {
			if (condition === void 0) {
				this.error();
				if (!this.allErrors) this.gen.if(false);
				return;
			}
			this.gen.if(condition);
			this.error();
			if (this.allErrors) this.gen.endIf();
			else this.gen.else();
		}
		fail$data(condition) {
			if (!this.$data) return this.fail(condition);
			const { schemaCode } = this;
			this.fail((0, codegen_1$28._)`${schemaCode} !== undefined && (${(0, codegen_1$28.or)(this.invalid$data(), condition)})`);
		}
		error(append, errorParams, errorPaths) {
			if (errorParams) {
				this.setParams(errorParams);
				this._error(append, errorPaths);
				this.setParams({});
				return;
			}
			this._error(append, errorPaths);
		}
		_error(append, errorPaths) {
			(append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
		}
		$dataError() {
			(0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
		}
		reset() {
			if (this.errsCount === void 0) throw new Error("add \"trackErrors\" to keyword definition");
			(0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
		}
		ok(cond) {
			if (!this.allErrors) this.gen.if(cond);
		}
		setParams(obj, assign) {
			if (assign) Object.assign(this.params, obj);
			else this.params = obj;
		}
		block$data(valid, codeBlock, $dataValid = codegen_1$28.nil) {
			this.gen.block(() => {
				this.check$data(valid, $dataValid);
				codeBlock();
			});
		}
		check$data(valid = codegen_1$28.nil, $dataValid = codegen_1$28.nil) {
			if (!this.$data) return;
			const { gen, schemaCode, schemaType, def: def$30 } = this;
			gen.if((0, codegen_1$28.or)((0, codegen_1$28._)`${schemaCode} === undefined`, $dataValid));
			if (valid !== codegen_1$28.nil) gen.assign(valid, true);
			if (schemaType.length || def$30.validateSchema) {
				gen.elseIf(this.invalid$data());
				this.$dataError();
				if (valid !== codegen_1$28.nil) gen.assign(valid, false);
			}
			gen.else();
		}
		invalid$data() {
			const { gen, schemaCode, schemaType, def: def$30, it } = this;
			return (0, codegen_1$28.or)(wrong$DataType(), invalid$DataSchema());
			function wrong$DataType() {
				if (schemaType.length) {
					/* istanbul ignore if */
					if (!(schemaCode instanceof codegen_1$28.Name)) throw new Error("ajv implementation error");
					const st = Array.isArray(schemaType) ? schemaType : [schemaType];
					return (0, codegen_1$28._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
				}
				return codegen_1$28.nil;
			}
			function invalid$DataSchema() {
				if (def$30.validateSchema) {
					const validateSchemaRef = gen.scopeValue("validate$data", { ref: def$30.validateSchema });
					return (0, codegen_1$28._)`!${validateSchemaRef}(${schemaCode})`;
				}
				return codegen_1$28.nil;
			}
		}
		subschema(appl, valid) {
			const subschema = (0, subschema_1.getSubschema)(this.it, appl);
			(0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
			(0, subschema_1.extendSubschemaMode)(subschema, appl);
			const nextContext = {
				...this.it,
				...subschema,
				items: void 0,
				props: void 0
			};
			subschemaCode(nextContext, valid);
			return nextContext;
		}
		mergeEvaluated(schemaCxt, toName) {
			const { it, gen } = this;
			if (!it.opts.unevaluated) return;
			if (it.props !== true && schemaCxt.props !== void 0) it.props = util_1$23.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
			if (it.items !== true && schemaCxt.items !== void 0) it.items = util_1$23.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
		}
		mergeValidEvaluated(schemaCxt, valid) {
			const { it, gen } = this;
			if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
				gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$28.Name));
				return true;
			}
		}
	};
	exports.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def$30, ruleType) {
		const cxt = new KeywordCxt(it, def$30, keyword);
		if ("code" in def$30) def$30.code(cxt, ruleType);
		else if (cxt.$data && def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
		else if ("macro" in def$30) (0, keyword_1.macroKeywordCode)(cxt, def$30);
		else if (def$30.compile || def$30.validate) (0, keyword_1.funcKeywordCode)(cxt, def$30);
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
		let jsonPointer;
		let data;
		if ($data === "") return names_1$3.default.rootData;
		if ($data[0] === "/") {
			if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
			jsonPointer = $data;
			data = names_1$3.default.rootData;
		} else {
			const matches = RELATIVE_JSON_POINTER.exec($data);
			if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
			const up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer === "#") {
				if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
				return dataPathArr[dataLevel - up];
			}
			if (up > dataLevel) throw new Error(errorMsg("data", up));
			data = dataNames[dataLevel - up];
			if (!jsonPointer) return data;
		}
		let expr = data;
		const segments = jsonPointer.split("/");
		for (const segment of segments) if (segment) {
			data = (0, codegen_1$28._)`${data}${(0, codegen_1$28.getProperty)((0, util_1$23.unescapeJsonPointer)(segment))}`;
			expr = (0, codegen_1$28._)`${expr} && ${data}`;
		}
		return expr;
		function errorMsg(pointerType, up) {
			return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
		}
	}
	exports.getData = getData;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError = class extends Error {
		constructor(errors) {
			super("validation failed");
			this.errors = errors;
			this.ajv = this.validation = true;
		}
	};
	exports.default = ValidationError;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const resolve_1$2 = require_resolve();
	var MissingRefError = class extends Error {
		constructor(resolver, baseId, ref, msg) {
			super(msg || `can't resolve reference ${ref} from id ${baseId}`);
			this.missingRef = (0, resolve_1$2.resolveUrl)(resolver, baseId, ref);
			this.missingSchema = (0, resolve_1$2.normalizeId)((0, resolve_1$2.getFullPath)(resolver, this.missingRef));
		}
	};
	exports.default = MissingRefError;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js
var require_compile = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
	const codegen_1$27 = require_codegen();
	const validation_error_1$2 = require_validation_error();
	const names_1$2 = require_names();
	const resolve_1$1 = require_resolve();
	const util_1$22 = require_util();
	const validate_1$3 = require_validate();
	var SchemaEnv = class {
		constructor(env) {
			var _a;
			this.refs = {};
			this.dynamicAnchors = {};
			let schema;
			if (typeof env.schema == "object") schema = env.schema;
			this.schema = env.schema;
			this.schemaId = env.schemaId;
			this.root = env.root || this;
			this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1$1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
			this.schemaPath = env.schemaPath;
			this.localRefs = env.localRefs;
			this.meta = env.meta;
			this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
			this.refs = {};
		}
	};
	exports.SchemaEnv = SchemaEnv;
	function compileSchema(sch) {
		const _sch = getCompilingSchema.call(this, sch);
		if (_sch) return _sch;
		const rootId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
		const { es5, lines } = this.opts.code;
		const { ownProperties } = this.opts;
		const gen = new codegen_1$27.CodeGen(this.scope, {
			es5,
			lines,
			ownProperties
		});
		let _ValidationError;
		if (sch.$async) _ValidationError = gen.scopeValue("Error", {
			ref: validation_error_1$2.default,
			code: (0, codegen_1$27._)`require("ajv/dist/runtime/validation_error").default`
		});
		const validateName = gen.scopeName("validate");
		sch.validateName = validateName;
		const schemaCxt = {
			gen,
			allErrors: this.opts.allErrors,
			data: names_1$2.default.data,
			parentData: names_1$2.default.parentData,
			parentDataProperty: names_1$2.default.parentDataProperty,
			dataNames: [names_1$2.default.data],
			dataPathArr: [codegen_1$27.nil],
			dataLevel: 0,
			dataTypes: [],
			definedProperties: /* @__PURE__ */ new Set(),
			topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
				ref: sch.schema,
				code: (0, codegen_1$27.stringify)(sch.schema)
			} : { ref: sch.schema }),
			validateName,
			ValidationError: _ValidationError,
			schema: sch.schema,
			schemaEnv: sch,
			rootId,
			baseId: sch.baseId || rootId,
			schemaPath: codegen_1$27.nil,
			errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
			errorPath: (0, codegen_1$27._)`""`,
			opts: this.opts,
			self: this
		};
		let sourceCode;
		try {
			this._compilations.add(sch);
			(0, validate_1$3.validateFunctionCode)(schemaCxt);
			gen.optimize(this.opts.code.optimize);
			const validateCode = gen.toString();
			sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
			if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
			const validate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode)(this, this.scope.get());
			this.scope.value(validateName, { ref: validate });
			validate.errors = null;
			validate.schema = sch.schema;
			validate.schemaEnv = sch;
			if (sch.$async) validate.$async = true;
			if (this.opts.code.source === true) validate.source = {
				validateName,
				validateCode,
				scopeValues: gen._values
			};
			if (this.opts.unevaluated) {
				const { props, items } = schemaCxt;
				validate.evaluated = {
					props: props instanceof codegen_1$27.Name ? void 0 : props,
					items: items instanceof codegen_1$27.Name ? void 0 : items,
					dynamicProps: props instanceof codegen_1$27.Name,
					dynamicItems: items instanceof codegen_1$27.Name
				};
				if (validate.source) validate.source.evaluated = (0, codegen_1$27.stringify)(validate.evaluated);
			}
			sch.validate = validate;
			return sch;
		} catch (e) {
			delete sch.validate;
			delete sch.validateName;
			if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
			throw e;
		} finally {
			this._compilations.delete(sch);
		}
	}
	exports.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
		var _a;
		ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, ref);
		const schOrFunc = root.refs[ref];
		if (schOrFunc) return schOrFunc;
		let _sch = resolve$1.call(this, root, ref);
		if (_sch === void 0) {
			const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
			const { schemaId } = this.opts;
			if (schema) _sch = new SchemaEnv({
				schema,
				schemaId,
				root,
				baseId
			});
		}
		if (_sch === void 0) return;
		return root.refs[ref] = inlineOrCompile.call(this, _sch);
	}
	exports.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
		if ((0, resolve_1$1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
		return sch.validate ? sch : compileSchema.call(this, sch);
	}
	function getCompilingSchema(schEnv) {
		for (const sch of this._compilations) if (sameSchemaEnv(sch, schEnv)) return sch;
	}
	exports.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
		return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	function resolve$1(root, ref) {
		let sch;
		while (typeof (sch = this.refs[ref]) == "string") ref = sch;
		return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	function resolveSchema(root, ref) {
		const p = this.opts.uriResolver.parse(ref);
		const refPath = (0, resolve_1$1._getFullPath)(this.opts.uriResolver, p);
		let baseId = (0, resolve_1$1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
		if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
		const id = (0, resolve_1$1.normalizeId)(refPath);
		const schOrRef = this.refs[id] || this.schemas[id];
		if (typeof schOrRef == "string") {
			const sch = resolveSchema.call(this, root, schOrRef);
			if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
			return getJsonPointer.call(this, p, sch);
		}
		if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
		if (!schOrRef.validate) compileSchema.call(this, schOrRef);
		if (id === (0, resolve_1$1.normalizeId)(ref)) {
			const { schema } = schOrRef;
			const { schemaId } = this.opts;
			const schId = schema[schemaId];
			if (schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
			return new SchemaEnv({
				schema,
				schemaId,
				root,
				baseId
			});
		}
		return getJsonPointer.call(this, p, schOrRef);
	}
	exports.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
		var _a;
		if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/") return;
		for (const part of parsedRef.fragment.slice(1).split("/")) {
			if (typeof schema === "boolean") return;
			const partSchema = schema[(0, util_1$22.unescapeFragment)(part)];
			if (partSchema === void 0) return;
			schema = partSchema;
			const schId = typeof schema === "object" && schema[this.opts.schemaId];
			if (!PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schId);
		}
		let env;
		if (typeof schema != "boolean" && schema.$ref && !(0, util_1$22.schemaHasRulesButRef)(schema, this.RULES)) {
			const $ref = (0, resolve_1$1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
			env = resolveSchema.call(this, root, $ref);
		}
		const { schemaId } = this.opts;
		env = env || new SchemaEnv({
			schema,
			schemaId,
			root,
			baseId
		});
		if (env.schema !== env.root.schema) return env;
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json
var require_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON AnySchema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}));

//#endregion
//#region node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {(value: string) => boolean} */
	const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
	/** @type {(value: string) => boolean} */
	const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
	/**
	* @param {Array<string>} input
	* @returns {string}
	*/
	function stringArrayToHexStripped(input) {
		let acc = "";
		let code = 0;
		let i$3 = 0;
		for (i$3 = 0; i$3 < input.length; i$3++) {
			code = input[i$3].charCodeAt(0);
			if (code === 48) continue;
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i$3];
			break;
		}
		for (i$3 += 1; i$3 < input.length; i$3++) {
			code = input[i$3].charCodeAt(0);
			if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) return "";
			acc += input[i$3];
		}
		return acc;
	}
	/**
	* @typedef {Object} GetIPV6Result
	* @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	* @property {string} address - The parsed IPv6 address.
	* @property {string} [zone] - The zone identifier, if present.
	*/
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
	/**
	* @param {Array<string>} buffer
	* @returns {boolean}
	*/
	function consumeIsZone(buffer$1) {
		buffer$1.length = 0;
		return true;
	}
	/**
	* @param {Array<string>} buffer
	* @param {Array<string>} address
	* @param {GetIPV6Result} output
	* @returns {boolean}
	*/
	function consumeHextets(buffer$1, address, output) {
		if (buffer$1.length) {
			const hex = stringArrayToHexStripped(buffer$1);
			if (hex !== "") address.push(hex);
			else {
				output.error = true;
				return false;
			}
			buffer$1.length = 0;
		}
		return true;
	}
	/**
	* @param {string} input
	* @returns {GetIPV6Result}
	*/
	function getIPV6(input) {
		let tokenCount = 0;
		const output = {
			error: false,
			address: "",
			zone: ""
		};
		/** @type {Array<string>} */
		const address = [];
		/** @type {Array<string>} */
		const buffer$1 = [];
		let endipv6Encountered = false;
		let endIpv6 = false;
		let consume = consumeHextets;
		for (let i$3 = 0; i$3 < input.length; i$3++) {
			const cursor = input[i$3];
			if (cursor === "[" || cursor === "]") continue;
			if (cursor === ":") {
				if (endipv6Encountered === true) endIpv6 = true;
				if (!consume(buffer$1, address, output)) break;
				if (++tokenCount > 7) {
					output.error = true;
					break;
				}
				if (i$3 > 0 && input[i$3 - 1] === ":") endipv6Encountered = true;
				address.push(":");
				continue;
			} else if (cursor === "%") {
				if (!consume(buffer$1, address, output)) break;
				consume = consumeIsZone;
			} else {
				buffer$1.push(cursor);
				continue;
			}
		}
		if (buffer$1.length) if (consume === consumeIsZone) output.zone = buffer$1.join("");
		else if (endIpv6) address.push(buffer$1.join(""));
		else address.push(stringArrayToHexStripped(buffer$1));
		output.address = address.join("");
		return output;
	}
	/**
	* @typedef {Object} NormalizeIPv6Result
	* @property {string} host - The normalized host.
	* @property {string} [escapedHost] - The escaped host.
	* @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	*/
	/**
	* @param {string} host
	* @returns {NormalizeIPv6Result}
	*/
	function normalizeIPv6$1(host) {
		if (findToken(host, ":") < 2) return {
			host,
			isIPV6: false
		};
		const ipv6$1 = getIPV6(host);
		if (!ipv6$1.error) {
			let newHost = ipv6$1.address;
			let escapedHost = ipv6$1.address;
			if (ipv6$1.zone) {
				newHost += "%" + ipv6$1.zone;
				escapedHost += "%25" + ipv6$1.zone;
			}
			return {
				host: newHost,
				isIPV6: true,
				escapedHost
			};
		} else return {
			host,
			isIPV6: false
		};
	}
	/**
	* @param {string} str
	* @param {string} token
	* @returns {number}
	*/
	function findToken(str$1, token) {
		let ind = 0;
		for (let i$3 = 0; i$3 < str$1.length; i$3++) if (str$1[i$3] === token) ind++;
		return ind;
	}
	/**
	* @param {string} path
	* @returns {string}
	*
	* @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	*/
	function removeDotSegments$1(path) {
		let input = path;
		const output = [];
		let nextSlash = -1;
		let len = 0;
		while (len = input.length) {
			if (len === 1) if (input === ".") break;
			else if (input === "/") {
				output.push("/");
				break;
			} else {
				output.push(input);
				break;
			}
			else if (len === 2) {
				if (input[0] === ".") {
					if (input[1] === ".") break;
					else if (input[1] === "/") {
						input = input.slice(2);
						continue;
					}
				} else if (input[0] === "/") {
					if (input[1] === "." || input[1] === "/") {
						output.push("/");
						break;
					}
				}
			} else if (len === 3) {
				if (input === "/..") {
					if (output.length !== 0) output.pop();
					output.push("/");
					break;
				}
			}
			if (input[0] === ".") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(3);
						continue;
					}
				} else if (input[1] === "/") {
					input = input.slice(2);
					continue;
				}
			} else if (input[0] === "/") {
				if (input[1] === ".") {
					if (input[2] === "/") {
						input = input.slice(2);
						continue;
					} else if (input[2] === ".") {
						if (input[3] === "/") {
							input = input.slice(3);
							if (output.length !== 0) output.pop();
							continue;
						}
					}
				}
			}
			if ((nextSlash = input.indexOf("/", 1)) === -1) {
				output.push(input);
				break;
			} else {
				output.push(input.slice(0, nextSlash));
				input = input.slice(nextSlash);
			}
		}
		return output.join("");
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @param {boolean} esc
	* @returns {import('../types/index').URIComponent}
	*/
	function normalizeComponentEncoding$1(component, esc$1) {
		const func = esc$1 !== true ? escape : unescape;
		if (component.scheme !== void 0) component.scheme = func(component.scheme);
		if (component.userinfo !== void 0) component.userinfo = func(component.userinfo);
		if (component.host !== void 0) component.host = func(component.host);
		if (component.path !== void 0) component.path = func(component.path);
		if (component.query !== void 0) component.query = func(component.query);
		if (component.fragment !== void 0) component.fragment = func(component.fragment);
		return component;
	}
	/**
	* @param {import('../types/index').URIComponent} component
	* @returns {string|undefined}
	*/
	function recomposeAuthority$1(component) {
		const uriTokens = [];
		if (component.userinfo !== void 0) {
			uriTokens.push(component.userinfo);
			uriTokens.push("@");
		}
		if (component.host !== void 0) {
			let host = unescape(component.host);
			if (!isIPv4$1(host)) {
				const ipV6res = normalizeIPv6$1(host);
				if (ipV6res.isIPV6 === true) host = `[${ipV6res.escapedHost}]`;
				else host = component.host;
			}
			uriTokens.push(host);
		}
		if (typeof component.port === "number" || typeof component.port === "string") {
			uriTokens.push(":");
			uriTokens.push(String(component.port));
		}
		return uriTokens.length ? uriTokens.join("") : void 0;
	}
	module.exports = {
		nonSimpleDomain: nonSimpleDomain$1,
		recomposeAuthority: recomposeAuthority$1,
		normalizeComponentEncoding: normalizeComponentEncoding$1,
		removeDotSegments: removeDotSegments$1,
		isIPv4: isIPv4$1,
		isUUID: isUUID$1,
		normalizeIPv6: normalizeIPv6$1,
		stringArrayToHexStripped
	};
}));

//#endregion
//#region node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js
var require_schemes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isUUID } = require_utils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
	const supportedSchemeNames = [
		"http",
		"https",
		"ws",
		"wss",
		"urn",
		"urn:uuid"
	];
	/** @typedef {supportedSchemeNames[number]} SchemeName */
	/**
	* @param {string} name
	* @returns {name is SchemeName}
	*/
	function isValidSchemeName(name) {
		return supportedSchemeNames.indexOf(name) !== -1;
	}
	/**
	* @callback SchemeFn
	* @param {import('../types/index').URIComponent} component
	* @param {import('../types/index').Options} options
	* @returns {import('../types/index').URIComponent}
	*/
	/**
	* @typedef {Object} SchemeHandler
	* @property {SchemeName} scheme - The scheme name.
	* @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	* @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	* @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	* @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	* @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	* @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	*/
	/**
	* @param {import('../types/index').URIComponent} wsComponent
	* @returns {boolean}
	*/
	function wsIsSecure(wsComponent) {
		if (wsComponent.secure === true) return true;
		else if (wsComponent.secure === false) return false;
		else if (wsComponent.scheme) return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
		else return false;
	}
	/** @type {SchemeFn} */
	function httpParse(component) {
		if (!component.host) component.error = component.error || "HTTP URIs must have a host.";
		return component;
	}
	/** @type {SchemeFn} */
	function httpSerialize(component) {
		const secure = String(component.scheme).toLowerCase() === "https";
		if (component.port === (secure ? 443 : 80) || component.port === "") component.port = void 0;
		if (!component.path) component.path = "/";
		return component;
	}
	/** @type {SchemeFn} */
	function wsParse(wsComponent) {
		wsComponent.secure = wsIsSecure(wsComponent);
		wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
		wsComponent.path = void 0;
		wsComponent.query = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function wsSerialize(wsComponent) {
		if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") wsComponent.port = void 0;
		if (typeof wsComponent.secure === "boolean") {
			wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
			wsComponent.secure = void 0;
		}
		if (wsComponent.resourceName) {
			const [path, query] = wsComponent.resourceName.split("?");
			wsComponent.path = path && path !== "/" ? path : void 0;
			wsComponent.query = query;
			wsComponent.resourceName = void 0;
		}
		wsComponent.fragment = void 0;
		return wsComponent;
	}
	/** @type {SchemeFn} */
	function urnParse(urnComponent, options) {
		if (!urnComponent.path) {
			urnComponent.error = "URN can not be parsed";
			return urnComponent;
		}
		const matches = urnComponent.path.match(URN_REG);
		if (matches) {
			const scheme = options.scheme || urnComponent.scheme || "urn";
			urnComponent.nid = matches[1].toLowerCase();
			urnComponent.nss = matches[2];
			const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || urnComponent.nid}`);
			urnComponent.path = void 0;
			if (schemeHandler) urnComponent = schemeHandler.parse(urnComponent, options);
		} else urnComponent.error = urnComponent.error || "URN can not be parsed.";
		return urnComponent;
	}
	/** @type {SchemeFn} */
	function urnSerialize(urnComponent, options) {
		if (urnComponent.nid === void 0) throw new Error("URN without nid cannot be serialized");
		const scheme = options.scheme || urnComponent.scheme || "urn";
		const nid = urnComponent.nid.toLowerCase();
		const schemeHandler = getSchemeHandler$1(`${scheme}:${options.nid || nid}`);
		if (schemeHandler) urnComponent = schemeHandler.serialize(urnComponent, options);
		const uriComponent = urnComponent;
		const nss = urnComponent.nss;
		uriComponent.path = `${nid || options.nid}:${nss}`;
		options.skipEscape = true;
		return uriComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidParse(urnComponent, options) {
		const uuidComponent = urnComponent;
		uuidComponent.uuid = uuidComponent.nss;
		uuidComponent.nss = void 0;
		if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) uuidComponent.error = uuidComponent.error || "UUID is not valid.";
		return uuidComponent;
	}
	/** @type {SchemeFn} */
	function urnuuidSerialize(uuidComponent) {
		const urnComponent = uuidComponent;
		urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
		return urnComponent;
	}
	const http$1 = {
		scheme: "http",
		domainHost: true,
		parse: httpParse,
		serialize: httpSerialize
	};
	const https = {
		scheme: "https",
		domainHost: http$1.domainHost,
		parse: httpParse,
		serialize: httpSerialize
	};
	const ws = {
		scheme: "ws",
		domainHost: true,
		parse: wsParse,
		serialize: wsSerialize
	};
	const wss = {
		scheme: "wss",
		domainHost: ws.domainHost,
		parse: ws.parse,
		serialize: ws.serialize
	};
	const urn = {
		scheme: "urn",
		parse: urnParse,
		serialize: urnSerialize,
		skipNormalize: true
	};
	const urnuuid = {
		scheme: "urn:uuid",
		parse: urnuuidParse,
		serialize: urnuuidSerialize,
		skipNormalize: true
	};
	const SCHEMES$1 = {
		http: http$1,
		https,
		ws,
		wss,
		urn,
		"urn:uuid": urnuuid
	};
	Object.setPrototypeOf(SCHEMES$1, null);
	/**
	* @param {string|undefined} scheme
	* @returns {SchemeHandler|undefined}
	*/
	function getSchemeHandler$1(scheme) {
		return scheme && (SCHEMES$1[scheme] || SCHEMES$1[scheme.toLowerCase()]) || void 0;
	}
	module.exports = {
		wsIsSecure,
		SCHEMES: SCHEMES$1,
		isValidSchemeName,
		getSchemeHandler: getSchemeHandler$1
	};
}));

//#endregion
//#region node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/index.js
var require_fast_uri = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
	const { SCHEMES, getSchemeHandler } = require_schemes();
	/**
	* @template {import('./types/index').URIComponent|string} T
	* @param {T} uri
	* @param {import('./types/index').Options} [options]
	* @returns {T}
	*/
	function normalize(uri$2, options) {
		if (typeof uri$2 === "string") uri$2 = serialize(parse(uri$2, options), options);
		else if (typeof uri$2 === "object") uri$2 = parse(serialize(uri$2, options), options);
		return uri$2;
	}
	/**
	* @param {string} baseURI
	* @param {string} relativeURI
	* @param {import('./types/index').Options} [options]
	* @returns {string}
	*/
	function resolve(baseURI, relativeURI, options) {
		const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
		const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
		schemelessOptions.skipEscape = true;
		return serialize(resolved, schemelessOptions);
	}
	/**
	* @param {import ('./types/index').URIComponent} base
	* @param {import ('./types/index').URIComponent} relative
	* @param {import('./types/index').Options} [options]
	* @param {boolean} [skipNormalization=false]
	* @returns {import ('./types/index').URIComponent}
	*/
	function resolveComponent(base, relative$1, options, skipNormalization) {
		/** @type {import('./types/index').URIComponent} */
		const target = {};
		if (!skipNormalization) {
			base = parse(serialize(base, options), options);
			relative$1 = parse(serialize(relative$1, options), options);
		}
		options = options || {};
		if (!options.tolerant && relative$1.scheme) {
			target.scheme = relative$1.scheme;
			target.userinfo = relative$1.userinfo;
			target.host = relative$1.host;
			target.port = relative$1.port;
			target.path = removeDotSegments(relative$1.path || "");
			target.query = relative$1.query;
		} else {
			if (relative$1.userinfo !== void 0 || relative$1.host !== void 0 || relative$1.port !== void 0) {
				target.userinfo = relative$1.userinfo;
				target.host = relative$1.host;
				target.port = relative$1.port;
				target.path = removeDotSegments(relative$1.path || "");
				target.query = relative$1.query;
			} else {
				if (!relative$1.path) {
					target.path = base.path;
					if (relative$1.query !== void 0) target.query = relative$1.query;
					else target.query = base.query;
				} else {
					if (relative$1.path[0] === "/") target.path = removeDotSegments(relative$1.path);
					else {
						if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) target.path = "/" + relative$1.path;
						else if (!base.path) target.path = relative$1.path;
						else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative$1.path;
						target.path = removeDotSegments(target.path);
					}
					target.query = relative$1.query;
				}
				target.userinfo = base.userinfo;
				target.host = base.host;
				target.port = base.port;
			}
			target.scheme = base.scheme;
		}
		target.fragment = relative$1.fragment;
		return target;
	}
	/**
	* @param {import ('./types/index').URIComponent|string} uriA
	* @param {import ('./types/index').URIComponent|string} uriB
	* @param {import ('./types/index').Options} options
	* @returns {boolean}
	*/
	function equal$1(uriA, uriB, options) {
		if (typeof uriA === "string") {
			uriA = unescape(uriA);
			uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriA === "object") uriA = serialize(normalizeComponentEncoding(uriA, true), {
			...options,
			skipEscape: true
		});
		if (typeof uriB === "string") {
			uriB = unescape(uriB);
			uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
				...options,
				skipEscape: true
			});
		} else if (typeof uriB === "object") uriB = serialize(normalizeComponentEncoding(uriB, true), {
			...options,
			skipEscape: true
		});
		return uriA.toLowerCase() === uriB.toLowerCase();
	}
	/**
	* @param {Readonly<import('./types/index').URIComponent>} cmpts
	* @param {import('./types/index').Options} [opts]
	* @returns {string}
	*/
	function serialize(cmpts, opts) {
		const component = {
			host: cmpts.host,
			scheme: cmpts.scheme,
			userinfo: cmpts.userinfo,
			port: cmpts.port,
			path: cmpts.path,
			query: cmpts.query,
			nid: cmpts.nid,
			nss: cmpts.nss,
			uuid: cmpts.uuid,
			fragment: cmpts.fragment,
			reference: cmpts.reference,
			resourceName: cmpts.resourceName,
			secure: cmpts.secure,
			error: ""
		};
		const options = Object.assign({}, opts);
		const uriTokens = [];
		const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
		if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
		if (component.path !== void 0) if (!options.skipEscape) {
			component.path = escape(component.path);
			if (component.scheme !== void 0) component.path = component.path.split("%3A").join(":");
		} else component.path = unescape(component.path);
		if (options.reference !== "suffix" && component.scheme) uriTokens.push(component.scheme, ":");
		const authority = recomposeAuthority(component);
		if (authority !== void 0) {
			if (options.reference !== "suffix") uriTokens.push("//");
			uriTokens.push(authority);
			if (component.path && component.path[0] !== "/") uriTokens.push("/");
		}
		if (component.path !== void 0) {
			let s = component.path;
			if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
			if (authority === void 0 && s[0] === "/" && s[1] === "/") s = "/%2F" + s.slice(2);
			uriTokens.push(s);
		}
		if (component.query !== void 0) uriTokens.push("?", component.query);
		if (component.fragment !== void 0) uriTokens.push("#", component.fragment);
		return uriTokens.join("");
	}
	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
	/**
	* @param {string} uri
	* @param {import('./types/index').Options} [opts]
	* @returns
	*/
	function parse(uri$2, opts) {
		const options = Object.assign({}, opts);
		/** @type {import('./types/index').URIComponent} */
		const parsed = {
			scheme: void 0,
			userinfo: void 0,
			host: "",
			port: void 0,
			path: "",
			query: void 0,
			fragment: void 0
		};
		let isIP = false;
		if (options.reference === "suffix") if (options.scheme) uri$2 = options.scheme + ":" + uri$2;
		else uri$2 = "//" + uri$2;
		const matches = uri$2.match(URI_PARSE);
		if (matches) {
			parsed.scheme = matches[1];
			parsed.userinfo = matches[3];
			parsed.host = matches[4];
			parsed.port = parseInt(matches[5], 10);
			parsed.path = matches[6] || "";
			parsed.query = matches[7];
			parsed.fragment = matches[8];
			if (isNaN(parsed.port)) parsed.port = matches[5];
			if (parsed.host) if (isIPv4(parsed.host) === false) {
				const ipv6result = normalizeIPv6(parsed.host);
				parsed.host = ipv6result.host.toLowerCase();
				isIP = ipv6result.isIPV6;
			} else isIP = true;
			if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) parsed.reference = "same-document";
			else if (parsed.scheme === void 0) parsed.reference = "relative";
			else if (parsed.fragment === void 0) parsed.reference = "absolute";
			else parsed.reference = "uri";
			if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
			const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
			if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
				if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) try {
					parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
				} catch (e) {
					parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
				}
			}
			if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
				if (uri$2.indexOf("%") !== -1) {
					if (parsed.scheme !== void 0) parsed.scheme = unescape(parsed.scheme);
					if (parsed.host !== void 0) parsed.host = unescape(parsed.host);
				}
				if (parsed.path) parsed.path = escape(unescape(parsed.path));
				if (parsed.fragment) parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
			}
			if (schemeHandler && schemeHandler.parse) schemeHandler.parse(parsed, options);
		} else parsed.error = parsed.error || "URI can not be parsed.";
		return parsed;
	}
	const fastUri = {
		SCHEMES,
		normalize,
		resolve,
		resolveComponent,
		equal: equal$1,
		serialize,
		parse
	};
	module.exports = fastUri;
	module.exports.default = fastUri;
	module.exports.fastUri = fastUri;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js
var require_uri = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const uri$1 = require_fast_uri();
	uri$1.code = "require(\"ajv/dist/runtime/uri\").default";
	exports.default = uri$1;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js
var require_core$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1$2 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1$2.KeywordCxt;
		}
	});
	var codegen_1$26 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1$26._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1$26.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1$26.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1$26.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1$26.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1$26.CodeGen;
		}
	});
	const validation_error_1$1 = require_validation_error();
	const ref_error_1$3 = require_ref_error();
	const rules_1 = require_rules();
	const compile_1$2 = require_compile();
	const codegen_2 = require_codegen();
	const resolve_1 = require_resolve();
	const dataType_1$1 = require_dataType();
	const util_1$21 = require_util();
	const $dataRefSchema = require_data();
	const uri_1 = require_uri();
	const defaultRegExp = (str$1, flags) => new RegExp(str$1, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes"
	];
	const EXT_SCOPE_NAMES = new Set([
		"validate",
		"serialize",
		"parse",
		"wrapper",
		"root",
		"schema",
		"keyword",
		"pattern",
		"formats",
		"validate$data",
		"func",
		"obj",
		"Error"
	]);
	const removedOptions = {
		errorDataPath: "",
		format: "`validateFormats: false` can be used instead.",
		nullable: "\"nullable\" keyword is supported by default.",
		jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		sourceCode: "Use option `code: {source: true}`",
		strictDefaults: "It is default now, see option `strict`.",
		strictKeywords: "It is default now, see option `strict`.",
		uniqueItems: "\"uniqueItems\" keyword is always validated.",
		unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		cache: "Map is used as cache, schema object as key.",
		serialize: "Map is used as cache, schema object as key.",
		ajvErrors: "It is default now."
	};
	const deprecatedOptions = {
		ignoreKeywordsWithRef: "",
		jsPropertySyntax: "",
		unicode: "\"minLength\"/\"maxLength\" account for unicode characters by default."
	};
	const MAX_EXPRESSION = 200;
	function requiredOptions(o) {
		var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		const s = o.strict;
		const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		const optimize$1 = _optz === true || _optz === void 0 ? 1 : _optz || 0;
		const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		return {
			strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
			strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
			strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
			strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
			strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
			code: o.code ? {
				...o.code,
				optimize: optimize$1,
				regExp
			} : {
				optimize: optimize$1,
				regExp
			},
			loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
			loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
			meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
			messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
			inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
			schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
			addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
			validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
			validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
			unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
			int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
			uriResolver
		};
	}
	var Ajv$2 = class {
		constructor(opts = {}) {
			this.schemas = {};
			this.refs = {};
			this.formats = {};
			this._compilations = /* @__PURE__ */ new Set();
			this._loading = {};
			this._cache = /* @__PURE__ */ new Map();
			opts = this.opts = {
				...opts,
				...requiredOptions(opts)
			};
			const { es5, lines } = this.opts.code;
			this.scope = new codegen_2.ValueScope({
				scope: {},
				prefixes: EXT_SCOPE_NAMES,
				es5,
				lines
			});
			this.logger = getLogger(opts.logger);
			const formatOpt = opts.validateFormats;
			opts.validateFormats = false;
			this.RULES = (0, rules_1.getRules)();
			checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
			checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
			this._metaOpts = getMetaSchemaOptions.call(this);
			if (opts.formats) addInitialFormats.call(this);
			this._addVocabularies();
			this._addDefaultMetaSchema();
			if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
			if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
			addInitialSchemas.call(this);
			opts.validateFormats = formatOpt;
		}
		_addVocabularies() {
			this.addKeyword("$async");
		}
		_addDefaultMetaSchema() {
			const { $data, meta, schemaId } = this.opts;
			let _dataRefSchema = $dataRefSchema;
			if (schemaId === "id") {
				_dataRefSchema = { ...$dataRefSchema };
				_dataRefSchema.id = _dataRefSchema.$id;
				delete _dataRefSchema.$id;
			}
			if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		}
		defaultMeta() {
			const { meta, schemaId } = this.opts;
			return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
		}
		validate(schemaKeyRef, data) {
			let v;
			if (typeof schemaKeyRef == "string") {
				v = this.getSchema(schemaKeyRef);
				if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
			} else v = this.compile(schemaKeyRef);
			const valid = v(data);
			if (!("$async" in v)) this.errors = v.errors;
			return valid;
		}
		compile(schema, _meta) {
			const sch = this._addSchema(schema, _meta);
			return sch.validate || this._compileSchemaEnv(sch);
		}
		compileAsync(schema, meta) {
			if (typeof this.opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
			const { loadSchema } = this.opts;
			return runCompileAsync.call(this, schema, meta);
			async function runCompileAsync(_schema, _meta) {
				await loadMetaSchema.call(this, _schema.$schema);
				const sch = this._addSchema(_schema, _meta);
				return sch.validate || _compileAsync.call(this, sch);
			}
			async function loadMetaSchema($ref) {
				if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, { $ref }, true);
			}
			async function _compileAsync(sch) {
				try {
					return this._compileSchemaEnv(sch);
				} catch (e) {
					if (!(e instanceof ref_error_1$3.default)) throw e;
					checkLoaded.call(this, e);
					await loadMissingSchema.call(this, e.missingSchema);
					return _compileAsync.call(this, sch);
				}
			}
			function checkLoaded({ missingSchema: ref, missingRef }) {
				if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
			}
			async function loadMissingSchema(ref) {
				const _schema = await _loadSchema.call(this, ref);
				if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
				if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
			}
			async function _loadSchema(ref) {
				const p = this._loading[ref];
				if (p) return p;
				try {
					return await (this._loading[ref] = loadSchema(ref));
				} finally {
					delete this._loading[ref];
				}
			}
		}
		addSchema(schema, key$1, _meta, _validateSchema = this.opts.validateSchema) {
			if (Array.isArray(schema)) {
				for (const sch of schema) this.addSchema(sch, void 0, _meta, _validateSchema);
				return this;
			}
			let id;
			if (typeof schema === "object") {
				const { schemaId } = this.opts;
				id = schema[schemaId];
				if (id !== void 0 && typeof id != "string") throw new Error(`schema ${schemaId} must be string`);
			}
			key$1 = (0, resolve_1.normalizeId)(key$1 || id);
			this._checkUnique(key$1);
			this.schemas[key$1] = this._addSchema(schema, _meta, key$1, _validateSchema, true);
			return this;
		}
		addMetaSchema(schema, key$1, _validateSchema = this.opts.validateSchema) {
			this.addSchema(schema, key$1, true, _validateSchema);
			return this;
		}
		validateSchema(schema, throwOrLogError) {
			if (typeof schema == "boolean") return true;
			let $schema;
			$schema = schema.$schema;
			if ($schema !== void 0 && typeof $schema != "string") throw new Error("$schema must be a string");
			$schema = $schema || this.opts.defaultMeta || this.defaultMeta();
			if (!$schema) {
				this.logger.warn("meta-schema not available");
				this.errors = null;
				return true;
			}
			const valid = this.validate($schema, schema);
			if (!valid && throwOrLogError) {
				const message = "schema is invalid: " + this.errorsText();
				if (this.opts.validateSchema === "log") this.logger.error(message);
				else throw new Error(message);
			}
			return valid;
		}
		getSchema(keyRef) {
			let sch;
			while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
			if (sch === void 0) {
				const { schemaId } = this.opts;
				const root = new compile_1$2.SchemaEnv({
					schema: {},
					schemaId
				});
				sch = compile_1$2.resolveSchema.call(this, root, keyRef);
				if (!sch) return;
				this.refs[keyRef] = sch;
			}
			return sch.validate || this._compileSchemaEnv(sch);
		}
		removeSchema(schemaKeyRef) {
			if (schemaKeyRef instanceof RegExp) {
				this._removeAllSchemas(this.schemas, schemaKeyRef);
				this._removeAllSchemas(this.refs, schemaKeyRef);
				return this;
			}
			switch (typeof schemaKeyRef) {
				case "undefined":
					this._removeAllSchemas(this.schemas);
					this._removeAllSchemas(this.refs);
					this._cache.clear();
					return this;
				case "string": {
					const sch = getSchEnv.call(this, schemaKeyRef);
					if (typeof sch == "object") this._cache.delete(sch.schema);
					delete this.schemas[schemaKeyRef];
					delete this.refs[schemaKeyRef];
					return this;
				}
				case "object": {
					const cacheKey = schemaKeyRef;
					this._cache.delete(cacheKey);
					let id = schemaKeyRef[this.opts.schemaId];
					if (id) {
						id = (0, resolve_1.normalizeId)(id);
						delete this.schemas[id];
						delete this.refs[id];
					}
					return this;
				}
				default: throw new Error("ajv.removeSchema: invalid parameter");
			}
		}
		addVocabulary(definitions) {
			for (const def$30 of definitions) this.addKeyword(def$30);
			return this;
		}
		addKeyword(kwdOrDef, def$30) {
			let keyword;
			if (typeof kwdOrDef == "string") {
				keyword = kwdOrDef;
				if (typeof def$30 == "object") {
					this.logger.warn("these parameters are deprecated, see docs for addKeyword");
					def$30.keyword = keyword;
				}
			} else if (typeof kwdOrDef == "object" && def$30 === void 0) {
				def$30 = kwdOrDef;
				keyword = def$30.keyword;
				if (Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
			} else throw new Error("invalid addKeywords parameters");
			checkKeyword.call(this, keyword, def$30);
			if (!def$30) {
				(0, util_1$21.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
				return this;
			}
			keywordMetaschema.call(this, def$30);
			const definition = {
				...def$30,
				type: (0, dataType_1$1.getJSONTypes)(def$30.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(def$30.schemaType)
			};
			(0, util_1$21.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
			return this;
		}
		getKeyword(keyword) {
			const rule = this.RULES.all[keyword];
			return typeof rule == "object" ? rule.definition : !!rule;
		}
		removeKeyword(keyword) {
			const { RULES } = this;
			delete RULES.keywords[keyword];
			delete RULES.all[keyword];
			for (const group of RULES.rules) {
				const i$3 = group.rules.findIndex((rule) => rule.keyword === keyword);
				if (i$3 >= 0) group.rules.splice(i$3, 1);
			}
			return this;
		}
		addFormat(name, format$2) {
			if (typeof format$2 == "string") format$2 = new RegExp(format$2);
			this.formats[name] = format$2;
			return this;
		}
		errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
			if (!errors || errors.length === 0) return "No errors";
			return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
		}
		$dataMetaSchema(metaSchema, keywordsJsonPointers) {
			const rules = this.RULES.all;
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			for (const jsonPointer of keywordsJsonPointers) {
				const segments = jsonPointer.split("/").slice(1);
				let keywords = metaSchema;
				for (const seg of segments) keywords = keywords[seg];
				for (const key$1 in rules) {
					const rule = rules[key$1];
					if (typeof rule != "object") continue;
					const { $data } = rule.definition;
					const schema = keywords[key$1];
					if ($data && schema) keywords[key$1] = schemaOrData(schema);
				}
			}
			return metaSchema;
		}
		_removeAllSchemas(schemas, regex$1) {
			for (const keyRef in schemas) {
				const sch = schemas[keyRef];
				if (!regex$1 || regex$1.test(keyRef)) {
					if (typeof sch == "string") delete schemas[keyRef];
					else if (sch && !sch.meta) {
						this._cache.delete(sch.schema);
						delete schemas[keyRef];
					}
				}
			}
		}
		_addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
			let id;
			const { schemaId } = this.opts;
			if (typeof schema == "object") id = schema[schemaId];
			else if (this.opts.jtd) throw new Error("schema must be object");
			else if (typeof schema != "boolean") throw new Error("schema must be object or boolean");
			let sch = this._cache.get(schema);
			if (sch !== void 0) return sch;
			baseId = (0, resolve_1.normalizeId)(id || baseId);
			const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
			sch = new compile_1$2.SchemaEnv({
				schema,
				schemaId,
				meta,
				baseId,
				localRefs
			});
			this._cache.set(sch.schema, sch);
			if (addSchema && !baseId.startsWith("#")) {
				if (baseId) this._checkUnique(baseId);
				this.refs[baseId] = sch;
			}
			if (validateSchema) this.validateSchema(schema, true);
			return sch;
		}
		_checkUnique(id) {
			if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
		}
		_compileSchemaEnv(sch) {
			if (sch.meta) this._compileMetaSchema(sch);
			else compile_1$2.compileSchema.call(this, sch);
			/* istanbul ignore if */
			if (!sch.validate) throw new Error("ajv implementation error");
			return sch.validate;
		}
		_compileMetaSchema(sch) {
			const currentOpts = this.opts;
			this.opts = this._metaOpts;
			try {
				compile_1$2.compileSchema.call(this, sch);
			} finally {
				this.opts = currentOpts;
			}
		}
	};
	Ajv$2.ValidationError = validation_error_1$1.default;
	Ajv$2.MissingRefError = ref_error_1$3.default;
	exports.default = Ajv$2;
	function checkOptions(checkOpts, options, msg, log$1 = "error") {
		for (const key$1 in checkOpts) {
			const opt = key$1;
			if (opt in options) this.logger[log$1](`${msg}: option ${key$1}. ${checkOpts[opt]}`);
		}
	}
	function getSchEnv(keyRef) {
		keyRef = (0, resolve_1.normalizeId)(keyRef);
		return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
		const optsSchemas = this.opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
		else for (const key$1 in optsSchemas) this.addSchema(optsSchemas[key$1], key$1);
	}
	function addInitialFormats() {
		for (const name in this.opts.formats) {
			const format$2 = this.opts.formats[name];
			if (format$2) this.addFormat(name, format$2);
		}
	}
	function addInitialKeywords(defs) {
		if (Array.isArray(defs)) {
			this.addVocabulary(defs);
			return;
		}
		this.logger.warn("keywords option as map is deprecated, pass array");
		for (const keyword in defs) {
			const def$30 = defs[keyword];
			if (!def$30.keyword) def$30.keyword = keyword;
			this.addKeyword(def$30);
		}
	}
	function getMetaSchemaOptions() {
		const metaOpts = { ...this.opts };
		for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
		return metaOpts;
	}
	const noLogs = {
		log() {},
		warn() {},
		error() {}
	};
	function getLogger(logger) {
		if (logger === false) return noLogs;
		if (logger === void 0) return console;
		if (logger.log && logger.warn && logger.error) return logger;
		throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def$30) {
		const { RULES } = this;
		(0, util_1$21.eachItem)(keyword, (kwd) => {
			if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
			if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
		});
		if (!def$30) return;
		if (def$30.$data && !("code" in def$30 || "validate" in def$30)) throw new Error("$data keyword must have \"code\" or \"validate\" function");
	}
	function addRule(keyword, definition, dataType) {
		var _a;
		const post = definition === null || definition === void 0 ? void 0 : definition.post;
		if (dataType && post) throw new Error("keyword with \"post\" flag cannot have \"type\"");
		const { RULES } = this;
		let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		if (!ruleGroup) {
			ruleGroup = {
				type: dataType,
				rules: []
			};
			RULES.rules.push(ruleGroup);
		}
		RULES.keywords[keyword] = true;
		if (!definition) return;
		const rule = {
			keyword,
			definition: {
				...definition,
				type: (0, dataType_1$1.getJSONTypes)(definition.type),
				schemaType: (0, dataType_1$1.getJSONTypes)(definition.schemaType)
			}
		};
		if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
		else ruleGroup.rules.push(rule);
		RULES.all[keyword] = rule;
		(_a = definition.implements) === null || _a === void 0 || _a.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
		const i$3 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		if (i$3 >= 0) ruleGroup.rules.splice(i$3, 0, rule);
		else {
			ruleGroup.rules.push(rule);
			this.logger.warn(`rule ${before} is not defined`);
		}
	}
	function keywordMetaschema(def$30) {
		let { metaSchema } = def$30;
		if (metaSchema === void 0) return;
		if (def$30.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
		def$30.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
	function schemaOrData(schema) {
		return { anyOf: [schema, $dataRef] };
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$29 = {
		keyword: "id",
		code() {
			throw new Error("NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID");
		}
	};
	exports.default = def$29;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.callRef = exports.getValidate = void 0;
	const ref_error_1$2 = require_ref_error();
	const code_1$8 = require_code();
	const codegen_1$25 = require_codegen();
	const names_1$1 = require_names();
	const compile_1$1 = require_compile();
	const util_1$20 = require_util();
	const def$28 = {
		keyword: "$ref",
		schemaType: "string",
		code(cxt) {
			const { gen, schema: $ref, it } = cxt;
			const { baseId, schemaEnv: env, validateName, opts, self } = it;
			const { root } = env;
			if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef();
			const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
			if (schOrEnv === void 0) throw new ref_error_1$2.default(it.opts.uriResolver, baseId, $ref);
			if (schOrEnv instanceof compile_1$1.SchemaEnv) return callValidate(schOrEnv);
			return inlineRefSchema(schOrEnv);
			function callRootRef() {
				if (env === root) return callRef(cxt, validateName, env, env.$async);
				const rootName = gen.scopeValue("root", { ref: root });
				return callRef(cxt, (0, codegen_1$25._)`${rootName}.validate`, root, root.$async);
			}
			function callValidate(sch) {
				callRef(cxt, getValidate(cxt, sch), sch, sch.$async);
			}
			function inlineRefSchema(sch) {
				const schName = gen.scopeValue("schema", opts.code.source === true ? {
					ref: sch,
					code: (0, codegen_1$25.stringify)(sch)
				} : { ref: sch });
				const valid = gen.name("valid");
				const schCxt = cxt.subschema({
					schema: sch,
					dataTypes: [],
					schemaPath: codegen_1$25.nil,
					topSchemaRef: schName,
					errSchemaPath: $ref
				}, valid);
				cxt.mergeEvaluated(schCxt);
				cxt.ok(valid);
			}
		}
	};
	function getValidate(cxt, sch) {
		const { gen } = cxt;
		return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$25._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	exports.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
		const { gen, it } = cxt;
		const { allErrors, schemaEnv: env, opts } = it;
		const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$25.nil;
		if ($async) callAsyncRef();
		else callSyncRef();
		function callAsyncRef() {
			if (!env.$async) throw new Error("async schema referenced by sync schema");
			const valid = gen.let("valid");
			gen.try(() => {
				gen.code((0, codegen_1$25._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
				addEvaluatedFrom(v);
				if (!allErrors) gen.assign(valid, true);
			}, (e) => {
				gen.if((0, codegen_1$25._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
				addErrorsFrom(e);
				if (!allErrors) gen.assign(valid, false);
			});
			cxt.ok(valid);
		}
		function callSyncRef() {
			cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
		}
		function addErrorsFrom(source) {
			const errs = (0, codegen_1$25._)`${source}.errors`;
			gen.assign(names_1$1.default.vErrors, (0, codegen_1$25._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
			gen.assign(names_1$1.default.errors, (0, codegen_1$25._)`${names_1$1.default.vErrors}.length`);
		}
		function addEvaluatedFrom(source) {
			var _a;
			if (!it.opts.unevaluated) return;
			const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
			if (it.props !== true) if (schEvaluated && !schEvaluated.dynamicProps) {
				if (schEvaluated.props !== void 0) it.props = util_1$20.mergeEvaluated.props(gen, schEvaluated.props, it.props);
			} else {
				const props = gen.var("props", (0, codegen_1$25._)`${source}.evaluated.props`);
				it.props = util_1$20.mergeEvaluated.props(gen, props, it.props, codegen_1$25.Name);
			}
			if (it.items !== true) if (schEvaluated && !schEvaluated.dynamicItems) {
				if (schEvaluated.items !== void 0) it.items = util_1$20.mergeEvaluated.items(gen, schEvaluated.items, it.items);
			} else {
				const items = gen.var("items", (0, codegen_1$25._)`${source}.evaluated.items`);
				it.items = util_1$20.mergeEvaluated.items(gen, items, it.items, codegen_1$25.Name);
			}
		}
	}
	exports.callRef = callRef;
	exports.default = def$28;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js
var require_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const id_1 = require_id();
	const ref_1 = require_ref();
	const core = [
		"$schema",
		"$id",
		"$defs",
		"$vocabulary",
		{ keyword: "$comment" },
		"definitions",
		id_1.default,
		ref_1.default
	];
	exports.default = core;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$24 = require_codegen();
	const ops$1 = codegen_1$24.operators;
	const KWDs$1 = {
		maximum: {
			okStr: "<=",
			ok: ops$1.LTE,
			fail: ops$1.GT
		},
		minimum: {
			okStr: ">=",
			ok: ops$1.GTE,
			fail: ops$1.LT
		},
		exclusiveMaximum: {
			okStr: "<",
			ok: ops$1.LT,
			fail: ops$1.GTE
		},
		exclusiveMinimum: {
			okStr: ">",
			ok: ops$1.GT,
			fail: ops$1.LTE
		}
	};
	const def$27 = {
		keyword: Object.keys(KWDs$1),
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ keyword, schemaCode }) => (0, codegen_1$24.str)`must be ${KWDs$1[keyword].okStr} ${schemaCode}`,
			params: ({ keyword, schemaCode }) => (0, codegen_1$24._)`{comparison: ${KWDs$1[keyword].okStr}, limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			cxt.fail$data((0, codegen_1$24._)`${data} ${KWDs$1[keyword].fail} ${schemaCode} || isNaN(${data})`);
		}
	};
	exports.default = def$27;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$23 = require_codegen();
	const def$26 = {
		keyword: "multipleOf",
		type: "number",
		schemaType: "number",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$23.str)`must be multiple of ${schemaCode}`,
			params: ({ schemaCode }) => (0, codegen_1$23._)`{multipleOf: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, schemaCode, it } = cxt;
			const prec = it.opts.multipleOfPrecision;
			const res = gen.let("res");
			const invalid = prec ? (0, codegen_1$23._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$23._)`${res} !== parseInt(${res})`;
			cxt.fail$data((0, codegen_1$23._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
		}
	};
	exports.default = def$26;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function ucs2length(str$1) {
		const len = str$1.length;
		let length = 0;
		let pos = 0;
		let value;
		while (pos < len) {
			length++;
			value = str$1.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str$1.charCodeAt(pos);
				if ((value & 64512) === 56320) pos++;
			}
		}
		return length;
	}
	exports.default = ucs2length;
	ucs2length.code = "require(\"ajv/dist/runtime/ucs2length\").default";
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$22 = require_codegen();
	const util_1$19 = require_util();
	const ucs2length_1 = require_ucs2length();
	const def$25 = {
		keyword: ["maxLength", "minLength"],
		type: "string",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxLength" ? "more" : "fewer";
				return (0, codegen_1$22.str)`must NOT have ${comp} than ${schemaCode} characters`;
			},
			params: ({ schemaCode }) => (0, codegen_1$22._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode, it } = cxt;
			const op = keyword === "maxLength" ? codegen_1$22.operators.GT : codegen_1$22.operators.LT;
			const len = it.opts.unicode === false ? (0, codegen_1$22._)`${data}.length` : (0, codegen_1$22._)`${(0, util_1$19.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
			cxt.fail$data((0, codegen_1$22._)`${len} ${op} ${schemaCode}`);
		}
	};
	exports.default = def$25;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$7 = require_code();
	const codegen_1$21 = require_codegen();
	const def$24 = {
		keyword: "pattern",
		type: "string",
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$21.str)`must match pattern "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$21._)`{pattern: ${schemaCode}}`
		},
		code(cxt) {
			const { data, $data, schema, schemaCode, it } = cxt;
			const u = it.opts.unicodeRegExp ? "u" : "";
			const regExp = $data ? (0, codegen_1$21._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
			cxt.fail$data((0, codegen_1$21._)`!${regExp}.test(${data})`);
		}
	};
	exports.default = def$24;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$20 = require_codegen();
	const def$23 = {
		keyword: ["maxProperties", "minProperties"],
		type: "object",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxProperties" ? "more" : "fewer";
				return (0, codegen_1$20.str)`must NOT have ${comp} than ${schemaCode} properties`;
			},
			params: ({ schemaCode }) => (0, codegen_1$20._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxProperties" ? codegen_1$20.operators.GT : codegen_1$20.operators.LT;
			cxt.fail$data((0, codegen_1$20._)`Object.keys(${data}).length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$23;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$6 = require_code();
	const codegen_1$19 = require_codegen();
	const util_1$18 = require_util();
	const def$22 = {
		keyword: "required",
		type: "object",
		schemaType: "array",
		$data: true,
		error: {
			message: ({ params: { missingProperty } }) => (0, codegen_1$19.str)`must have required property '${missingProperty}'`,
			params: ({ params: { missingProperty } }) => (0, codegen_1$19._)`{missingProperty: ${missingProperty}}`
		},
		code(cxt) {
			const { gen, schema, schemaCode, data, $data, it } = cxt;
			const { opts } = it;
			if (!$data && schema.length === 0) return;
			const useLoop = schema.length >= opts.loopRequired;
			if (it.allErrors) allErrorsMode();
			else exitOnErrorMode();
			if (opts.strictRequired) {
				const props = cxt.parentSchema.properties;
				const { definedProperties } = cxt.it;
				for (const requiredKey of schema) if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
					const msg = `required property "${requiredKey}" is not defined at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictRequired)`;
					(0, util_1$18.checkStrictMode)(it, msg, it.opts.strictRequired);
				}
			}
			function allErrorsMode() {
				if (useLoop || $data) cxt.block$data(codegen_1$19.nil, loopAllRequired);
				else for (const prop of schema) (0, code_1$6.checkReportMissingProp)(cxt, prop);
			}
			function exitOnErrorMode() {
				const missing = gen.let("missing");
				if (useLoop || $data) {
					const valid = gen.let("valid", true);
					cxt.block$data(valid, () => loopUntilMissing(missing, valid));
					cxt.ok(valid);
				} else {
					gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
					(0, code_1$6.reportMissingProp)(cxt, missing);
					gen.else();
				}
			}
			function loopAllRequired() {
				gen.forOf("prop", schemaCode, (prop) => {
					cxt.setParams({ missingProperty: prop });
					gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
				});
			}
			function loopUntilMissing(missing, valid) {
				cxt.setParams({ missingProperty: missing });
				gen.forOf(missing, schemaCode, () => {
					gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
					gen.if((0, codegen_1$19.not)(valid), () => {
						cxt.error();
						gen.break();
					});
				}, codegen_1$19.nil);
			}
		}
	};
	exports.default = def$22;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$18 = require_codegen();
	const def$21 = {
		keyword: ["maxItems", "minItems"],
		type: "array",
		schemaType: "number",
		$data: true,
		error: {
			message({ keyword, schemaCode }) {
				const comp = keyword === "maxItems" ? "more" : "fewer";
				return (0, codegen_1$18.str)`must NOT have ${comp} than ${schemaCode} items`;
			},
			params: ({ schemaCode }) => (0, codegen_1$18._)`{limit: ${schemaCode}}`
		},
		code(cxt) {
			const { keyword, data, schemaCode } = cxt;
			const op = keyword === "maxItems" ? codegen_1$18.operators.GT : codegen_1$18.operators.LT;
			cxt.fail$data((0, codegen_1$18._)`${data}.length ${op} ${schemaCode}`);
		}
	};
	exports.default = def$21;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js
var require_equal = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const equal = require_fast_deep_equal();
	equal.code = "require(\"ajv/dist/runtime/equal\").default";
	exports.default = equal;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const dataType_1 = require_dataType();
	const codegen_1$17 = require_codegen();
	const util_1$17 = require_util();
	const equal_1$2 = require_equal();
	const def$20 = {
		keyword: "uniqueItems",
		type: "array",
		schemaType: "boolean",
		$data: true,
		error: {
			message: ({ params: { i: i$3, j } }) => (0, codegen_1$17.str)`must NOT have duplicate items (items ## ${j} and ${i$3} are identical)`,
			params: ({ params: { i: i$3, j } }) => (0, codegen_1$17._)`{i: ${i$3}, j: ${j}}`
		},
		code(cxt) {
			const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
			if (!$data && !schema) return;
			const valid = gen.let("valid");
			const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
			cxt.block$data(valid, validateUniqueItems, (0, codegen_1$17._)`${schemaCode} === false`);
			cxt.ok(valid);
			function validateUniqueItems() {
				const i$3 = gen.let("i", (0, codegen_1$17._)`${data}.length`);
				const j = gen.let("j");
				cxt.setParams({
					i: i$3,
					j
				});
				gen.assign(valid, true);
				gen.if((0, codegen_1$17._)`${i$3} > 1`, () => (canOptimize() ? loopN : loopN2)(i$3, j));
			}
			function canOptimize() {
				return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
			}
			function loopN(i$3, j) {
				const item = gen.name("item");
				const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
				const indices = gen.const("indices", (0, codegen_1$17._)`{}`);
				gen.for((0, codegen_1$17._)`;${i$3}--;`, () => {
					gen.let(item, (0, codegen_1$17._)`${data}[${i$3}]`);
					gen.if(wrongType, (0, codegen_1$17._)`continue`);
					if (itemTypes.length > 1) gen.if((0, codegen_1$17._)`typeof ${item} == "string"`, (0, codegen_1$17._)`${item} += "_"`);
					gen.if((0, codegen_1$17._)`typeof ${indices}[${item}] == "number"`, () => {
						gen.assign(j, (0, codegen_1$17._)`${indices}[${item}]`);
						cxt.error();
						gen.assign(valid, false).break();
					}).code((0, codegen_1$17._)`${indices}[${item}] = ${i$3}`);
				});
			}
			function loopN2(i$3, j) {
				const eql = (0, util_1$17.useFunc)(gen, equal_1$2.default);
				const outer = gen.name("outer");
				gen.label(outer).for((0, codegen_1$17._)`;${i$3}--;`, () => gen.for((0, codegen_1$17._)`${j} = ${i$3}; ${j}--;`, () => gen.if((0, codegen_1$17._)`${eql}(${data}[${i$3}], ${data}[${j}])`, () => {
					cxt.error();
					gen.assign(valid, false).break(outer);
				})));
			}
		}
	};
	exports.default = def$20;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$16 = require_codegen();
	const util_1$16 = require_util();
	const equal_1$1 = require_equal();
	const def$19 = {
		keyword: "const",
		$data: true,
		error: {
			message: "must be equal to constant",
			params: ({ schemaCode }) => (0, codegen_1$16._)`{allowedValue: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schemaCode, schema } = cxt;
			if ($data || schema && typeof schema == "object") cxt.fail$data((0, codegen_1$16._)`!${(0, util_1$16.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
			else cxt.fail((0, codegen_1$16._)`${schema} !== ${data}`);
		}
	};
	exports.default = def$19;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$15 = require_codegen();
	const util_1$15 = require_util();
	const equal_1 = require_equal();
	const def$18 = {
		keyword: "enum",
		schemaType: "array",
		$data: true,
		error: {
			message: "must be equal to one of the allowed values",
			params: ({ schemaCode }) => (0, codegen_1$15._)`{allowedValues: ${schemaCode}}`
		},
		code(cxt) {
			const { gen, data, $data, schema, schemaCode, it } = cxt;
			if (!$data && schema.length === 0) throw new Error("enum must have non-empty array");
			const useLoop = schema.length >= it.opts.loopEnum;
			let eql;
			const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$15.useFunc)(gen, equal_1.default);
			let valid;
			if (useLoop || $data) {
				valid = gen.let("valid");
				cxt.block$data(valid, loopEnum);
			} else {
				/* istanbul ignore if */
				if (!Array.isArray(schema)) throw new Error("ajv implementation error");
				const vSchema = gen.const("vSchema", schemaCode);
				valid = (0, codegen_1$15.or)(...schema.map((_x, i$3) => equalCode(vSchema, i$3)));
			}
			cxt.pass(valid);
			function loopEnum() {
				gen.assign(valid, false);
				gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$15._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
			}
			function equalCode(vSchema, i$3) {
				const sch = schema[i$3];
				return typeof sch === "object" && sch !== null ? (0, codegen_1$15._)`${getEql()}(${data}, ${vSchema}[${i$3}])` : (0, codegen_1$15._)`${data} === ${sch}`;
			}
		}
	};
	exports.default = def$18;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const limitNumber_1 = require_limitNumber();
	const multipleOf_1 = require_multipleOf();
	const limitLength_1 = require_limitLength();
	const pattern_1 = require_pattern();
	const limitProperties_1 = require_limitProperties();
	const required_1 = require_required();
	const limitItems_1 = require_limitItems();
	const uniqueItems_1 = require_uniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation = [
		limitNumber_1.default,
		multipleOf_1.default,
		limitLength_1.default,
		pattern_1.default,
		limitProperties_1.default,
		required_1.default,
		limitItems_1.default,
		uniqueItems_1.default,
		{
			keyword: "type",
			schemaType: ["string", "array"]
		},
		{
			keyword: "nullable",
			schemaType: "boolean"
		},
		const_1.default,
		enum_1.default
	];
	exports.default = validation;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateAdditionalItems = void 0;
	const codegen_1$14 = require_codegen();
	const util_1$14 = require_util();
	const def$17 = {
		keyword: "additionalItems",
		type: "array",
		schemaType: ["boolean", "object"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$14.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$14._)`{limit: ${len}}`
		},
		code(cxt) {
			const { parentSchema, it } = cxt;
			const { items } = parentSchema;
			if (!Array.isArray(items)) {
				(0, util_1$14.checkStrictMode)(it, "\"additionalItems\" is ignored when \"items\" is not an array of schemas");
				return;
			}
			validateAdditionalItems(cxt, items);
		}
	};
	function validateAdditionalItems(cxt, items) {
		const { gen, schema, data, keyword, it } = cxt;
		it.items = true;
		const len = gen.const("len", (0, codegen_1$14._)`${data}.length`);
		if (schema === false) {
			cxt.setParams({ len: items.length });
			cxt.pass((0, codegen_1$14._)`${len} <= ${items.length}`);
		} else if (typeof schema == "object" && !(0, util_1$14.alwaysValidSchema)(it, schema)) {
			const valid = gen.var("valid", (0, codegen_1$14._)`${len} <= ${items.length}`);
			gen.if((0, codegen_1$14.not)(valid), () => validateItems(valid));
			cxt.ok(valid);
		}
		function validateItems(valid) {
			gen.forRange("i", items.length, len, (i$3) => {
				cxt.subschema({
					keyword,
					dataProp: i$3,
					dataPropType: util_1$14.Type.Num
				}, valid);
				if (!it.allErrors) gen.if((0, codegen_1$14.not)(valid), () => gen.break());
			});
		}
	}
	exports.validateAdditionalItems = validateAdditionalItems;
	exports.default = def$17;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateTuple = void 0;
	const codegen_1$13 = require_codegen();
	const util_1$13 = require_util();
	const code_1$5 = require_code();
	const def$16 = {
		keyword: "items",
		type: "array",
		schemaType: [
			"object",
			"array",
			"boolean"
		],
		before: "uniqueItems",
		code(cxt) {
			const { schema, it } = cxt;
			if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
			it.items = true;
			if ((0, util_1$13.alwaysValidSchema)(it, schema)) return;
			cxt.ok((0, code_1$5.validateArray)(cxt));
		}
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
		const { gen, parentSchema, data, keyword, it } = cxt;
		checkStrictTuple(parentSchema);
		if (it.opts.unevaluated && schArr.length && it.items !== true) it.items = util_1$13.mergeEvaluated.items(gen, schArr.length, it.items);
		const valid = gen.name("valid");
		const len = gen.const("len", (0, codegen_1$13._)`${data}.length`);
		schArr.forEach((sch, i$3) => {
			if ((0, util_1$13.alwaysValidSchema)(it, sch)) return;
			gen.if((0, codegen_1$13._)`${len} > ${i$3}`, () => cxt.subschema({
				keyword,
				schemaProp: i$3,
				dataProp: i$3
			}, valid));
			cxt.ok(valid);
		});
		function checkStrictTuple(sch) {
			const { opts, errSchemaPath } = it;
			const l = schArr.length;
			const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
			if (opts.strictTuples && !fullTuple) {
				const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
				(0, util_1$13.checkStrictMode)(it, msg, opts.strictTuples);
			}
		}
	}
	exports.validateTuple = validateTuple;
	exports.default = def$16;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const items_1$1 = require_items();
	const def$15 = {
		keyword: "prefixItems",
		type: "array",
		schemaType: ["array"],
		before: "uniqueItems",
		code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
	};
	exports.default = def$15;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$12 = require_codegen();
	const util_1$12 = require_util();
	const code_1$4 = require_code();
	const additionalItems_1$1 = require_additionalItems();
	const def$14 = {
		keyword: "items",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		error: {
			message: ({ params: { len } }) => (0, codegen_1$12.str)`must NOT have more than ${len} items`,
			params: ({ params: { len } }) => (0, codegen_1$12._)`{limit: ${len}}`
		},
		code(cxt) {
			const { schema, parentSchema, it } = cxt;
			const { prefixItems } = parentSchema;
			it.items = true;
			if ((0, util_1$12.alwaysValidSchema)(it, schema)) return;
			if (prefixItems) (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
			else cxt.ok((0, code_1$4.validateArray)(cxt));
		}
	};
	exports.default = def$14;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$11 = require_codegen();
	const util_1$11 = require_util();
	const def$13 = {
		keyword: "contains",
		type: "array",
		schemaType: ["object", "boolean"],
		before: "uniqueItems",
		trackErrors: true,
		error: {
			message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$11.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$11.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
			params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$11._)`{minContains: ${min}}` : (0, codegen_1$11._)`{minContains: ${min}, maxContains: ${max}}`
		},
		code(cxt) {
			const { gen, schema, parentSchema, data, it } = cxt;
			let min;
			let max;
			const { minContains, maxContains } = parentSchema;
			if (it.opts.next) {
				min = minContains === void 0 ? 1 : minContains;
				max = maxContains;
			} else min = 1;
			const len = gen.const("len", (0, codegen_1$11._)`${data}.length`);
			cxt.setParams({
				min,
				max
			});
			if (max === void 0 && min === 0) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
				return;
			}
			if (max !== void 0 && min > max) {
				(0, util_1$11.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
				cxt.fail();
				return;
			}
			if ((0, util_1$11.alwaysValidSchema)(it, schema)) {
				let cond = (0, codegen_1$11._)`${len} >= ${min}`;
				if (max !== void 0) cond = (0, codegen_1$11._)`${cond} && ${len} <= ${max}`;
				cxt.pass(cond);
				return;
			}
			it.items = true;
			const valid = gen.name("valid");
			if (max === void 0 && min === 1) validateItems(valid, () => gen.if(valid, () => gen.break()));
			else if (min === 0) {
				gen.let(valid, true);
				if (max !== void 0) gen.if((0, codegen_1$11._)`${data}.length > 0`, validateItemsWithCount);
			} else {
				gen.let(valid, false);
				validateItemsWithCount();
			}
			cxt.result(valid, () => cxt.reset());
			function validateItemsWithCount() {
				const schValid = gen.name("_valid");
				const count = gen.let("count", 0);
				validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
			}
			function validateItems(_valid, block) {
				gen.forRange("i", 0, len, (i$3) => {
					cxt.subschema({
						keyword: "contains",
						dataProp: i$3,
						dataPropType: util_1$11.Type.Num,
						compositeRule: true
					}, _valid);
					block();
				});
			}
			function checkLimits(count) {
				gen.code((0, codegen_1$11._)`${count}++`);
				if (max === void 0) gen.if((0, codegen_1$11._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
				else {
					gen.if((0, codegen_1$11._)`${count} > ${max}`, () => gen.assign(valid, false).break());
					if (min === 1) gen.assign(valid, true);
					else gen.if((0, codegen_1$11._)`${count} >= ${min}`, () => gen.assign(valid, true));
				}
			}
		}
	};
	exports.default = def$13;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1$10 = require_codegen();
	const util_1$10 = require_util();
	const code_1$3 = require_code();
	exports.error = {
		message: ({ params: { property, depsCount, deps } }) => {
			const property_ies = depsCount === 1 ? "property" : "properties";
			return (0, codegen_1$10.str)`must have ${property_ies} ${deps} when property ${property} is present`;
		},
		params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1$10._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
	};
	const def$12 = {
		keyword: "dependencies",
		type: "object",
		schemaType: "object",
		error: exports.error,
		code(cxt) {
			const [propDeps, schDeps] = splitDependencies(cxt);
			validatePropertyDeps(cxt, propDeps);
			validateSchemaDeps(cxt, schDeps);
		}
	};
	function splitDependencies({ schema }) {
		const propertyDeps = {};
		const schemaDeps = {};
		for (const key$1 in schema) {
			if (key$1 === "__proto__") continue;
			const deps = Array.isArray(schema[key$1]) ? propertyDeps : schemaDeps;
			deps[key$1] = schema[key$1];
		}
		return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		const { gen, data, it } = cxt;
		if (Object.keys(propertyDeps).length === 0) return;
		const missing = gen.let("missing");
		for (const prop in propertyDeps) {
			const deps = propertyDeps[prop];
			if (deps.length === 0) continue;
			const hasProperty = (0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties);
			cxt.setParams({
				property: prop,
				depsCount: deps.length,
				deps: deps.join(", ")
			});
			if (it.allErrors) gen.if(hasProperty, () => {
				for (const depProp of deps) (0, code_1$3.checkReportMissingProp)(cxt, depProp);
			});
			else {
				gen.if((0, codegen_1$10._)`${hasProperty} && (${(0, code_1$3.checkMissingProp)(cxt, deps, missing)})`);
				(0, code_1$3.reportMissingProp)(cxt, missing);
				gen.else();
			}
		}
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		const { gen, data, keyword, it } = cxt;
		const valid = gen.name("valid");
		for (const prop in schemaDeps) {
			if ((0, util_1$10.alwaysValidSchema)(it, schemaDeps[prop])) continue;
			gen.if((0, code_1$3.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
				const schCxt = cxt.subschema({
					keyword,
					schemaProp: prop
				}, valid);
				cxt.mergeValidEvaluated(schCxt, valid);
			}, () => gen.var(valid, true));
			cxt.ok(valid);
		}
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def$12;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$9 = require_codegen();
	const util_1$9 = require_util();
	const def$11 = {
		keyword: "propertyNames",
		type: "object",
		schemaType: ["object", "boolean"],
		error: {
			message: "property name must be valid",
			params: ({ params }) => (0, codegen_1$9._)`{propertyName: ${params.propertyName}}`
		},
		code(cxt) {
			const { gen, schema, data, it } = cxt;
			if ((0, util_1$9.alwaysValidSchema)(it, schema)) return;
			const valid = gen.name("valid");
			gen.forIn("key", data, (key$1) => {
				cxt.setParams({ propertyName: key$1 });
				cxt.subschema({
					keyword: "propertyNames",
					data: key$1,
					dataTypes: ["string"],
					propertyName: key$1,
					compositeRule: true
				}, valid);
				gen.if((0, codegen_1$9.not)(valid), () => {
					cxt.error(true);
					if (!it.allErrors) gen.break();
				});
			});
			cxt.ok(valid);
		}
	};
	exports.default = def$11;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1$2 = require_code();
	const codegen_1$8 = require_codegen();
	const names_1 = require_names();
	const util_1$8 = require_util();
	const def$10 = {
		keyword: "additionalProperties",
		type: ["object"],
		schemaType: ["boolean", "object"],
		allowUndefined: true,
		trackErrors: true,
		error: {
			message: "must NOT have additional properties",
			params: ({ params }) => (0, codegen_1$8._)`{additionalProperty: ${params.additionalProperty}}`
		},
		code(cxt) {
			const { gen, schema, parentSchema, data, errsCount, it } = cxt;
			/* istanbul ignore if */
			if (!errsCount) throw new Error("ajv implementation error");
			const { allErrors, opts } = it;
			it.props = true;
			if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema)) return;
			const props = (0, code_1$2.allSchemaProperties)(parentSchema.properties);
			const patProps = (0, code_1$2.allSchemaProperties)(parentSchema.patternProperties);
			checkAdditionalProperties();
			cxt.ok((0, codegen_1$8._)`${errsCount} === ${names_1.default.errors}`);
			function checkAdditionalProperties() {
				gen.forIn("key", data, (key$1) => {
					if (!props.length && !patProps.length) additionalPropertyCode(key$1);
					else gen.if(isAdditional(key$1), () => additionalPropertyCode(key$1));
				});
			}
			function isAdditional(key$1) {
				let definedProp;
				if (props.length > 8) {
					const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
					definedProp = (0, code_1$2.isOwnProperty)(gen, propsSchema, key$1);
				} else if (props.length) definedProp = (0, codegen_1$8.or)(...props.map((p) => (0, codegen_1$8._)`${key$1} === ${p}`));
				else definedProp = codegen_1$8.nil;
				if (patProps.length) definedProp = (0, codegen_1$8.or)(definedProp, ...patProps.map((p) => (0, codegen_1$8._)`${(0, code_1$2.usePattern)(cxt, p)}.test(${key$1})`));
				return (0, codegen_1$8.not)(definedProp);
			}
			function deleteAdditional(key$1) {
				gen.code((0, codegen_1$8._)`delete ${data}[${key$1}]`);
			}
			function additionalPropertyCode(key$1) {
				if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
					deleteAdditional(key$1);
					return;
				}
				if (schema === false) {
					cxt.setParams({ additionalProperty: key$1 });
					cxt.error();
					if (!allErrors) gen.break();
					return;
				}
				if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema)) {
					const valid = gen.name("valid");
					if (opts.removeAdditional === "failing") {
						applyAdditionalSchema(key$1, valid, false);
						gen.if((0, codegen_1$8.not)(valid), () => {
							cxt.reset();
							deleteAdditional(key$1);
						});
					} else {
						applyAdditionalSchema(key$1, valid);
						if (!allErrors) gen.if((0, codegen_1$8.not)(valid), () => gen.break());
					}
				}
			}
			function applyAdditionalSchema(key$1, valid, errors) {
				const subschema = {
					keyword: "additionalProperties",
					dataProp: key$1,
					dataPropType: util_1$8.Type.Str
				};
				if (errors === false) Object.assign(subschema, {
					compositeRule: true,
					createErrors: false,
					allErrors: false
				});
				cxt.subschema(subschema, valid);
			}
		}
	};
	exports.default = def$10;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_1$1 = require_validate();
	const code_1$1 = require_code();
	const util_1$7 = require_util();
	const additionalProperties_1$1 = require_additionalProperties();
	const def$9 = {
		keyword: "properties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema, parentSchema, data, it } = cxt;
			if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) additionalProperties_1$1.default.code(new validate_1$1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
			const allProps = (0, code_1$1.allSchemaProperties)(schema);
			for (const prop of allProps) it.definedProperties.add(prop);
			if (it.opts.unevaluated && allProps.length && it.props !== true) it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
			const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema[p]));
			if (properties.length === 0) return;
			const valid = gen.name("valid");
			for (const prop of properties) {
				if (hasDefault(prop)) applyPropertySchema(prop);
				else {
					gen.if((0, code_1$1.propertyInData)(gen, data, prop, it.opts.ownProperties));
					applyPropertySchema(prop);
					if (!it.allErrors) gen.else().var(valid, true);
					gen.endIf();
				}
				cxt.it.definedProperties.add(prop);
				cxt.ok(valid);
			}
			function hasDefault(prop) {
				return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
			}
			function applyPropertySchema(prop) {
				cxt.subschema({
					keyword: "properties",
					schemaProp: prop,
					dataProp: prop
				}, valid);
			}
		}
	};
	exports.default = def$9;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const code_1 = require_code();
	const codegen_1$7 = require_codegen();
	const util_1$6 = require_util();
	const util_2 = require_util();
	const def$8 = {
		keyword: "patternProperties",
		type: "object",
		schemaType: "object",
		code(cxt) {
			const { gen, schema, data, parentSchema, it } = cxt;
			const { opts } = it;
			const patterns = (0, code_1.allSchemaProperties)(schema);
			const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema[p]));
			if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) return;
			const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
			const valid = gen.name("valid");
			if (it.props !== true && !(it.props instanceof codegen_1$7.Name)) it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
			const { props } = it;
			validatePatternProperties();
			function validatePatternProperties() {
				for (const pat of patterns) {
					if (checkProperties) checkMatchingProperties(pat);
					if (it.allErrors) validateProperties(pat);
					else {
						gen.var(valid, true);
						validateProperties(pat);
						gen.if(valid);
					}
				}
			}
			function checkMatchingProperties(pat) {
				for (const prop in checkProperties) if (new RegExp(pat).test(prop)) (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
			}
			function validateProperties(pat) {
				gen.forIn("key", data, (key$1) => {
					gen.if((0, codegen_1$7._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key$1})`, () => {
						const alwaysValid = alwaysValidPatterns.includes(pat);
						if (!alwaysValid) cxt.subschema({
							keyword: "patternProperties",
							schemaProp: pat,
							dataProp: key$1,
							dataPropType: util_2.Type.Str
						}, valid);
						if (it.opts.unevaluated && props !== true) gen.assign((0, codegen_1$7._)`${props}[${key$1}]`, true);
						else if (!alwaysValid && !it.allErrors) gen.if((0, codegen_1$7.not)(valid), () => gen.break());
					});
				});
			}
		}
	};
	exports.default = def$8;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$5 = require_util();
	const def$7 = {
		keyword: "not",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		code(cxt) {
			const { gen, schema, it } = cxt;
			if ((0, util_1$5.alwaysValidSchema)(it, schema)) {
				cxt.fail();
				return;
			}
			const valid = gen.name("valid");
			cxt.subschema({
				keyword: "not",
				compositeRule: true,
				createErrors: false,
				allErrors: false
			}, valid);
			cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
		},
		error: { message: "must NOT be valid" }
	};
	exports.default = def$7;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const def$6 = {
		keyword: "anyOf",
		schemaType: "array",
		trackErrors: true,
		code: require_code().validateUnion,
		error: { message: "must match a schema in anyOf" }
	};
	exports.default = def$6;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$6 = require_codegen();
	const util_1$4 = require_util();
	const def$5 = {
		keyword: "oneOf",
		schemaType: "array",
		trackErrors: true,
		error: {
			message: "must match exactly one schema in oneOf",
			params: ({ params }) => (0, codegen_1$6._)`{passingSchemas: ${params.passing}}`
		},
		code(cxt) {
			const { gen, schema, parentSchema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema)) throw new Error("ajv implementation error");
			if (it.opts.discriminator && parentSchema.discriminator) return;
			const schArr = schema;
			const valid = gen.let("valid", false);
			const passing = gen.let("passing", null);
			const schValid = gen.name("_valid");
			cxt.setParams({ passing });
			gen.block(validateOneOf);
			cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
			function validateOneOf() {
				schArr.forEach((sch, i$3) => {
					let schCxt;
					if ((0, util_1$4.alwaysValidSchema)(it, sch)) gen.var(schValid, true);
					else schCxt = cxt.subschema({
						keyword: "oneOf",
						schemaProp: i$3,
						compositeRule: true
					}, schValid);
					if (i$3 > 0) gen.if((0, codegen_1$6._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$6._)`[${passing}, ${i$3}]`).else();
					gen.if(schValid, () => {
						gen.assign(valid, true);
						gen.assign(passing, i$3);
						if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1$6.Name);
					});
				});
			}
		}
	};
	exports.default = def$5;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$3 = require_util();
	const def$4 = {
		keyword: "allOf",
		schemaType: "array",
		code(cxt) {
			const { gen, schema, it } = cxt;
			/* istanbul ignore if */
			if (!Array.isArray(schema)) throw new Error("ajv implementation error");
			const valid = gen.name("valid");
			schema.forEach((sch, i$3) => {
				if ((0, util_1$3.alwaysValidSchema)(it, sch)) return;
				const schCxt = cxt.subschema({
					keyword: "allOf",
					schemaProp: i$3
				}, valid);
				cxt.ok(valid);
				cxt.mergeEvaluated(schCxt);
			});
		}
	};
	exports.default = def$4;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$5 = require_codegen();
	const util_1$2 = require_util();
	const def$3 = {
		keyword: "if",
		schemaType: ["object", "boolean"],
		trackErrors: true,
		error: {
			message: ({ params }) => (0, codegen_1$5.str)`must match "${params.ifClause}" schema`,
			params: ({ params }) => (0, codegen_1$5._)`{failingKeyword: ${params.ifClause}}`
		},
		code(cxt) {
			const { gen, parentSchema, it } = cxt;
			if (parentSchema.then === void 0 && parentSchema.else === void 0) (0, util_1$2.checkStrictMode)(it, "\"if\" without \"then\" and \"else\" is ignored");
			const hasThen = hasSchema(it, "then");
			const hasElse = hasSchema(it, "else");
			if (!hasThen && !hasElse) return;
			const valid = gen.let("valid", true);
			const schValid = gen.name("_valid");
			validateIf();
			cxt.reset();
			if (hasThen && hasElse) {
				const ifClause = gen.let("ifClause");
				cxt.setParams({ ifClause });
				gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
			} else if (hasThen) gen.if(schValid, validateClause("then"));
			else gen.if((0, codegen_1$5.not)(schValid), validateClause("else"));
			cxt.pass(valid, () => cxt.error(true));
			function validateIf() {
				const schCxt = cxt.subschema({
					keyword: "if",
					compositeRule: true,
					createErrors: false,
					allErrors: false
				}, schValid);
				cxt.mergeEvaluated(schCxt);
			}
			function validateClause(keyword, ifClause) {
				return () => {
					const schCxt = cxt.subschema({ keyword }, schValid);
					gen.assign(valid, schValid);
					cxt.mergeValidEvaluated(schCxt, valid);
					if (ifClause) gen.assign(ifClause, (0, codegen_1$5._)`${keyword}`);
					else cxt.setParams({ ifClause: keyword });
				};
			}
		}
	};
	function hasSchema(it, keyword) {
		const schema = it.schema[keyword];
		return schema !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema);
	}
	exports.default = def$3;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const util_1$1 = require_util();
	const def$2 = {
		keyword: ["then", "else"],
		schemaType: ["object", "boolean"],
		code({ keyword, parentSchema, it }) {
			if (parentSchema.if === void 0) (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
		}
	};
	exports.default = def$2;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const additionalItems_1 = require_additionalItems();
	const prefixItems_1 = require_prefixItems();
	const items_1 = require_items();
	const items2020_1 = require_items2020();
	const contains_1 = require_contains();
	const dependencies_1 = require_dependencies();
	const propertyNames_1 = require_propertyNames();
	const additionalProperties_1 = require_additionalProperties();
	const properties_1 = require_properties();
	const patternProperties_1 = require_patternProperties();
	const not_1 = require_not();
	const anyOf_1 = require_anyOf();
	const oneOf_1 = require_oneOf();
	const allOf_1 = require_allOf();
	const if_1 = require_if();
	const thenElse_1 = require_thenElse();
	function getApplicator(draft2020 = false) {
		const applicator = [
			not_1.default,
			anyOf_1.default,
			oneOf_1.default,
			allOf_1.default,
			if_1.default,
			thenElse_1.default,
			propertyNames_1.default,
			additionalProperties_1.default,
			dependencies_1.default,
			properties_1.default,
			patternProperties_1.default
		];
		if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
		else applicator.push(additionalItems_1.default, items_1.default);
		applicator.push(contains_1.default);
		return applicator;
	}
	exports.default = getApplicator;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js
var require_format$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$4 = require_codegen();
	const def$1 = {
		keyword: "format",
		type: ["number", "string"],
		schemaType: "string",
		$data: true,
		error: {
			message: ({ schemaCode }) => (0, codegen_1$4.str)`must match format "${schemaCode}"`,
			params: ({ schemaCode }) => (0, codegen_1$4._)`{format: ${schemaCode}}`
		},
		code(cxt, ruleType) {
			const { gen, data, $data, schema, schemaCode, it } = cxt;
			const { opts, errSchemaPath, schemaEnv, self } = it;
			if (!opts.validateFormats) return;
			if ($data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fDef = gen.const("fDef", (0, codegen_1$4._)`${fmts}[${schemaCode}]`);
				const fType = gen.let("fType");
				const format$2 = gen.let("format");
				gen.if((0, codegen_1$4._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$4._)`${fDef}.type || "string"`).assign(format$2, (0, codegen_1$4._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$4._)`"string"`).assign(format$2, fDef));
				cxt.fail$data((0, codegen_1$4.or)(unknownFmt(), invalidFmt()));
				function unknownFmt() {
					if (opts.strictSchema === false) return codegen_1$4.nil;
					return (0, codegen_1$4._)`${schemaCode} && !${format$2}`;
				}
				function invalidFmt() {
					const callFormat = schemaEnv.$async ? (0, codegen_1$4._)`(${fDef}.async ? await ${format$2}(${data}) : ${format$2}(${data}))` : (0, codegen_1$4._)`${format$2}(${data})`;
					const validData = (0, codegen_1$4._)`(typeof ${format$2} == "function" ? ${callFormat} : ${format$2}.test(${data}))`;
					return (0, codegen_1$4._)`${format$2} && ${format$2} !== true && ${fType} === ${ruleType} && !${validData}`;
				}
			}
			function validateFormat() {
				const formatDef = self.formats[schema];
				if (!formatDef) {
					unknownFormat();
					return;
				}
				if (formatDef === true) return;
				const [fmtType, format$2, fmtRef] = getFormat(formatDef);
				if (fmtType === ruleType) cxt.pass(validCondition());
				function unknownFormat() {
					if (opts.strictSchema === false) {
						self.logger.warn(unknownMsg());
						return;
					}
					throw new Error(unknownMsg());
					function unknownMsg() {
						return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
					}
				}
				function getFormat(fmtDef$1) {
					const code = fmtDef$1 instanceof RegExp ? (0, codegen_1$4.regexpCode)(fmtDef$1) : opts.code.formats ? (0, codegen_1$4._)`${opts.code.formats}${(0, codegen_1$4.getProperty)(schema)}` : void 0;
					const fmt = gen.scopeValue("formats", {
						key: schema,
						ref: fmtDef$1,
						code
					});
					if (typeof fmtDef$1 == "object" && !(fmtDef$1 instanceof RegExp)) return [
						fmtDef$1.type || "string",
						fmtDef$1.validate,
						(0, codegen_1$4._)`${fmt}.validate`
					];
					return [
						"string",
						fmtDef$1,
						fmt
					];
				}
				function validCondition() {
					if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
						if (!schemaEnv.$async) throw new Error("async format in sync schema");
						return (0, codegen_1$4._)`await ${fmtRef}(${data})`;
					}
					return typeof format$2 == "function" ? (0, codegen_1$4._)`${fmtRef}(${data})` : (0, codegen_1$4._)`${fmtRef}.test(${data})`;
				}
			}
		}
	};
	exports.default = def$1;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js
var require_format = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const format = [require_format$1().default];
	exports.default = format;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.contentVocabulary = exports.metadataVocabulary = void 0;
	exports.metadataVocabulary = [
		"title",
		"description",
		"default",
		"deprecated",
		"readOnly",
		"writeOnly",
		"examples"
	];
	exports.contentVocabulary = [
		"contentMediaType",
		"contentEncoding",
		"contentSchema"
	];
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const core_1$1 = require_core();
	const validation_1 = require_validation();
	const applicator_1 = require_applicator();
	const format_1 = require_format();
	const metadata_1 = require_metadata();
	const draft7Vocabularies = [
		core_1$1.default,
		validation_1.default,
		(0, applicator_1.default)(),
		format_1.default,
		metadata_1.metadataVocabulary,
		metadata_1.contentVocabulary
	];
	exports.default = draft7Vocabularies;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DiscrError = void 0;
	var DiscrError;
	(function(DiscrError$1) {
		DiscrError$1["Tag"] = "tag";
		DiscrError$1["Mapping"] = "mapping";
	})(DiscrError || (exports.DiscrError = DiscrError = {}));
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const codegen_1$3 = require_codegen();
	const types_1 = require_types();
	const compile_1 = require_compile();
	const ref_error_1$1 = require_ref_error();
	const util_1 = require_util();
	const def = {
		keyword: "discriminator",
		type: "object",
		schemaType: "object",
		error: {
			message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
			params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$3._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
		},
		code(cxt) {
			const { gen, data, schema, parentSchema, it } = cxt;
			const { oneOf } = parentSchema;
			if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
			const tagName = schema.propertyName;
			if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
			if (schema.mapping) throw new Error("discriminator: mapping is not supported");
			if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
			const valid = gen.let("valid", false);
			const tag = gen.const("tag", (0, codegen_1$3._)`${data}${(0, codegen_1$3.getProperty)(tagName)}`);
			gen.if((0, codegen_1$3._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
				discrError: types_1.DiscrError.Tag,
				tag,
				tagName
			}));
			cxt.ok(valid);
			function validateMapping() {
				const mapping = getMapping();
				gen.if(false);
				for (const tagValue in mapping) {
					gen.elseIf((0, codegen_1$3._)`${tag} === ${tagValue}`);
					gen.assign(valid, applyTagSchema(mapping[tagValue]));
				}
				gen.else();
				cxt.error(false, {
					discrError: types_1.DiscrError.Mapping,
					tag,
					tagName
				});
				gen.endIf();
			}
			function applyTagSchema(schemaProp) {
				const _valid = gen.name("valid");
				const schCxt = cxt.subschema({
					keyword: "oneOf",
					schemaProp
				}, _valid);
				cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
				return _valid;
			}
			function getMapping() {
				var _a;
				const oneOfMapping = {};
				const topRequired = hasRequired(parentSchema);
				let tagRequired = true;
				for (let i$3 = 0; i$3 < oneOf.length; i$3++) {
					let sch = oneOf[i$3];
					if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
						const ref = sch.$ref;
						sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
						if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
						if (sch === void 0) throw new ref_error_1$1.default(it.opts.uriResolver, it.baseId, ref);
					}
					const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
					if (typeof propSch != "object") throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
					tagRequired = tagRequired && (topRequired || hasRequired(sch));
					addMappings(propSch, i$3);
				}
				if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
				return oneOfMapping;
				function hasRequired({ required: required$1 }) {
					return Array.isArray(required$1) && required$1.includes(tagName);
				}
				function addMappings(sch, i$3) {
					if (sch.const) addMapping(sch.const, i$3);
					else if (sch.enum) for (const tagValue of sch.enum) addMapping(tagValue, i$3);
					else throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
				}
				function addMapping(tagValue, i$3) {
					if (typeof tagValue != "string" || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
					oneOfMapping[tagValue] = i$3;
				}
			}
		}
	};
	exports.default = def;
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}));

//#endregion
//#region node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js
var require_ajv = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = require_core$1();
	const draft7_1 = require_draft7();
	const discriminator_1 = require_discriminator();
	const draft7MetaSchema = require_json_schema_draft_07();
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var Ajv$1 = class extends core_1.default {
		_addVocabularies() {
			super._addVocabularies();
			draft7_1.default.forEach((v) => this.addVocabulary(v));
			if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
		}
		_addDefaultMetaSchema() {
			super._addDefaultMetaSchema();
			if (!this.opts.meta) return;
			const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
			this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
			this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
		defaultMeta() {
			return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
		}
	};
	exports.Ajv = Ajv$1;
	module.exports = exports = Ajv$1;
	module.exports.Ajv = Ajv$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv$1;
	var validate_1 = require_validate();
	Object.defineProperty(exports, "KeywordCxt", {
		enumerable: true,
		get: function() {
			return validate_1.KeywordCxt;
		}
	});
	var codegen_1$2 = require_codegen();
	Object.defineProperty(exports, "_", {
		enumerable: true,
		get: function() {
			return codegen_1$2._;
		}
	});
	Object.defineProperty(exports, "str", {
		enumerable: true,
		get: function() {
			return codegen_1$2.str;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return codegen_1$2.stringify;
		}
	});
	Object.defineProperty(exports, "nil", {
		enumerable: true,
		get: function() {
			return codegen_1$2.nil;
		}
	});
	Object.defineProperty(exports, "Name", {
		enumerable: true,
		get: function() {
			return codegen_1$2.Name;
		}
	});
	Object.defineProperty(exports, "CodeGen", {
		enumerable: true,
		get: function() {
			return codegen_1$2.CodeGen;
		}
	});
	var validation_error_1 = require_validation_error();
	Object.defineProperty(exports, "ValidationError", {
		enumerable: true,
		get: function() {
			return validation_error_1.default;
		}
	});
	var ref_error_1 = require_ref_error();
	Object.defineProperty(exports, "MissingRefError", {
		enumerable: true,
		get: function() {
			return ref_error_1.default;
		}
	});
}));

//#endregion
//#region node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js
var require_formats = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
	function fmtDef(validate, compare) {
		return {
			validate,
			compare
		};
	}
	exports.fullFormats = {
		date: fmtDef(date, compareDate),
		time: fmtDef(getTime(true), compareTime),
		"date-time": fmtDef(getDateTime(true), compareDateTime),
		"iso-time": fmtDef(getTime(), compareIsoTime),
		"iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
		duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
		uri,
		"uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
		"uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
		url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
		email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
		ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
		ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
		regex,
		uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
		"json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
		"json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
		"relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
		byte,
		int32: {
			type: "number",
			validate: validateInt32
		},
		int64: {
			type: "number",
			validate: validateInt64
		},
		float: {
			type: "number",
			validate: validateNumber
		},
		double: {
			type: "number",
			validate: validateNumber
		},
		password: true,
		binary: true
	};
	exports.fastFormats = {
		...exports.fullFormats,
		date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
		time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
		"date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
		"iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
		"iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
		uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		"uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
	};
	exports.formatNames = Object.keys(exports.fullFormats);
	function isLeapYear(year) {
		return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
	}
	const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	const DAYS = [
		0,
		31,
		28,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31
	];
	function date(str$1) {
		const matches = DATE.exec(str$1);
		if (!matches) return false;
		const year = +matches[1];
		const month = +matches[2];
		const day = +matches[3];
		return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
	}
	function compareDate(d1, d2) {
		if (!(d1 && d2)) return void 0;
		if (d1 > d2) return 1;
		if (d1 < d2) return -1;
		return 0;
	}
	const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
	function getTime(strictTimeZone) {
		return function time$2(str$1) {
			const matches = TIME.exec(str$1);
			if (!matches) return false;
			const hr = +matches[1];
			const min = +matches[2];
			const sec = +matches[3];
			const tz = matches[4];
			const tzSign = matches[5] === "-" ? -1 : 1;
			const tzH = +(matches[6] || 0);
			const tzM = +(matches[7] || 0);
			if (tzH > 23 || tzM > 59 || strictTimeZone && !tz) return false;
			if (hr <= 23 && min <= 59 && sec < 60) return true;
			const utcMin = min - tzM * tzSign;
			const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
			return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
		};
	}
	function compareTime(s1, s2) {
		if (!(s1 && s2)) return void 0;
		const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
		const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
		if (!(t1 && t2)) return void 0;
		return t1 - t2;
	}
	function compareIsoTime(t1, t2) {
		if (!(t1 && t2)) return void 0;
		const a1 = TIME.exec(t1);
		const a2 = TIME.exec(t2);
		if (!(a1 && a2)) return void 0;
		t1 = a1[1] + a1[2] + a1[3];
		t2 = a2[1] + a2[2] + a2[3];
		if (t1 > t2) return 1;
		if (t1 < t2) return -1;
		return 0;
	}
	const DATE_TIME_SEPARATOR = /t|\s/i;
	function getDateTime(strictTimeZone) {
		const time$2 = getTime(strictTimeZone);
		return function date_time(str$1) {
			const dateTime = str$1.split(DATE_TIME_SEPARATOR);
			return dateTime.length === 2 && date(dateTime[0]) && time$2(dateTime[1]);
		};
	}
	function compareDateTime(dt1, dt2) {
		if (!(dt1 && dt2)) return void 0;
		const d1 = new Date(dt1).valueOf();
		const d2 = new Date(dt2).valueOf();
		if (!(d1 && d2)) return void 0;
		return d1 - d2;
	}
	function compareIsoDateTime(dt1, dt2) {
		if (!(dt1 && dt2)) return void 0;
		const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
		const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
		const res = compareDate(d1, d2);
		if (res === void 0) return void 0;
		return res || compareTime(t1, t2);
	}
	const NOT_URI_FRAGMENT = /\/|:/;
	const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	function uri(str$1) {
		return NOT_URI_FRAGMENT.test(str$1) && URI.test(str$1);
	}
	const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
	function byte(str$1) {
		BYTE.lastIndex = 0;
		return BYTE.test(str$1);
	}
	const MIN_INT32 = -(2 ** 31);
	const MAX_INT32 = 2 ** 31 - 1;
	function validateInt32(value) {
		return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
	}
	function validateInt64(value) {
		return Number.isInteger(value);
	}
	function validateNumber() {
		return true;
	}
	const Z_ANCHOR = /[^\\]\\Z/;
	function regex(str$1) {
		if (Z_ANCHOR.test(str$1)) return false;
		try {
			new RegExp(str$1);
			return true;
		} catch (e) {
			return false;
		}
	}
}));

//#endregion
//#region node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js
var require_limit = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formatLimitDefinition = void 0;
	const ajv_1 = require_ajv();
	const codegen_1$1 = require_codegen();
	const ops = codegen_1$1.operators;
	const KWDs = {
		formatMaximum: {
			okStr: "<=",
			ok: ops.LTE,
			fail: ops.GT
		},
		formatMinimum: {
			okStr: ">=",
			ok: ops.GTE,
			fail: ops.LT
		},
		formatExclusiveMaximum: {
			okStr: "<",
			ok: ops.LT,
			fail: ops.GTE
		},
		formatExclusiveMinimum: {
			okStr: ">",
			ok: ops.GT,
			fail: ops.LTE
		}
	};
	const error = {
		message: ({ keyword, schemaCode }) => (0, codegen_1$1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
		params: ({ keyword, schemaCode }) => (0, codegen_1$1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
	};
	exports.formatLimitDefinition = {
		keyword: Object.keys(KWDs),
		type: "string",
		schemaType: "string",
		$data: true,
		error,
		code(cxt) {
			const { gen, data, schemaCode, keyword, it } = cxt;
			const { opts, self } = it;
			if (!opts.validateFormats) return;
			const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
			if (fCxt.$data) validate$DataFormat();
			else validateFormat();
			function validate$DataFormat() {
				const fmts = gen.scopeValue("formats", {
					ref: self.formats,
					code: opts.code.formats
				});
				const fmt = gen.const("fmt", (0, codegen_1$1._)`${fmts}[${fCxt.schemaCode}]`);
				cxt.fail$data((0, codegen_1$1.or)((0, codegen_1$1._)`typeof ${fmt} != "object"`, (0, codegen_1$1._)`${fmt} instanceof RegExp`, (0, codegen_1$1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
			}
			function validateFormat() {
				const format$2 = fCxt.schema;
				const fmtDef$1 = self.formats[format$2];
				if (!fmtDef$1 || fmtDef$1 === true) return;
				if (typeof fmtDef$1 != "object" || fmtDef$1 instanceof RegExp || typeof fmtDef$1.compare != "function") throw new Error(`"${keyword}": format "${format$2}" does not define "compare" function`);
				const fmt = gen.scopeValue("formats", {
					key: format$2,
					ref: fmtDef$1,
					code: opts.code.formats ? (0, codegen_1$1._)`${opts.code.formats}${(0, codegen_1$1.getProperty)(format$2)}` : void 0
				});
				cxt.fail$data(compareCode(fmt));
			}
			function compareCode(fmt) {
				return (0, codegen_1$1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
			}
		},
		dependencies: ["format"]
	};
	const formatLimitPlugin = (ajv) => {
		ajv.addKeyword(exports.formatLimitDefinition);
		return ajv;
	};
	exports.default = formatLimitPlugin;
}));

//#endregion
//#region node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	const formats_1 = require_formats();
	const limit_1 = require_limit();
	const codegen_1 = require_codegen();
	const fullName = new codegen_1.Name("fullFormats");
	const fastName = new codegen_1.Name("fastFormats");
	const formatsPlugin = (ajv, opts = { keywords: true }) => {
		if (Array.isArray(opts)) {
			addFormats(ajv, opts, formats_1.fullFormats, fullName);
			return ajv;
		}
		const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
		addFormats(ajv, opts.formats || formats_1.formatNames, formats, exportName);
		if (opts.keywords) (0, limit_1.default)(ajv);
		return ajv;
	};
	formatsPlugin.get = (name, mode = "full") => {
		const f = (mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats)[name];
		if (!f) throw new Error(`Unknown format "${name}"`);
		return f;
	};
	function addFormats(ajv, list, fs, exportName) {
		var _a;
		var _b;
		(_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
		for (const f of list) ajv.addFormat(f, fs[f]);
	}
	module.exports = exports = formatsPlugin;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = formatsPlugin;
}));

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = require_ajv();
var import_dist = /* @__PURE__ */ __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
	const ajv = new import_ajv.Ajv({
		strict: false,
		validateFormats: true,
		validateSchema: false,
		allErrors: true
	});
	(0, import_dist.default)(ajv);
	return ajv;
}
/**
* @example
* ```typescript
* // Use with default AJV instance (recommended)
* import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
* const validator = new AjvJsonSchemaValidator();
*
* // Use with custom AJV instance
* import { Ajv } from 'ajv';
* const ajv = new Ajv({ strict: true, allErrors: true });
* const validator = new AjvJsonSchemaValidator(ajv);
* ```
*/
var AjvJsonSchemaValidator = class {
	/**
	* Create an AJV validator
	*
	* @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
	*
	* @example
	* ```typescript
	* // Use default configuration (recommended for most cases)
	* import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
	* const validator = new AjvJsonSchemaValidator();
	*
	* // Or provide custom AJV instance for advanced configuration
	* import { Ajv } from 'ajv';
	* import addFormats from 'ajv-formats';
	*
	* const ajv = new Ajv({ validateFormats: true });
	* addFormats(ajv);
	* const validator = new AjvJsonSchemaValidator(ajv);
	* ```
	*/
	constructor(ajv) {
		this._ajv = ajv !== null && ajv !== void 0 ? ajv : createDefaultAjvInstance();
	}
	/**
	* Create a validator for the given JSON Schema
	*
	* The validator is compiled once and can be reused multiple times.
	* If the schema has an $id, it will be cached by AJV automatically.
	*
	* @param schema - Standard JSON Schema object
	* @returns A validator function that validates input data
	*/
	getValidator(schema) {
		var _a;
		const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? (_a = this._ajv.getSchema(schema.$id)) !== null && _a !== void 0 ? _a : this._ajv.compile(schema) : this._ajv.compile(schema);
		return (input) => {
			if (ajvValidator(input)) return {
				valid: true,
				data: input,
				errorMessage: void 0
			};
			else return {
				valid: false,
				data: void 0,
				errorMessage: this._ajv.errorsText(ajvValidator.errors)
			};
		};
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
/**
* Experimental client task features for MCP SDK.
* WARNING: These APIs are experimental and may change without notice.
*
* @experimental
*/
/**
* Experimental task features for MCP clients.
*
* Access via `client.experimental.tasks`:
* ```typescript
* const stream = client.experimental.tasks.callToolStream({ name: 'tool', arguments: {} });
* const task = await client.experimental.tasks.getTask(taskId);
* ```
*
* @experimental
*/
var ExperimentalClientTasks = class {
	constructor(_client) {
		this._client = _client;
	}
	/**
	* Calls a tool and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* This method provides streaming access to tool execution, allowing you to
	* observe intermediate task status updates for long-running tool calls.
	* Automatically validates structured output if the tool has an outputSchema.
	*
	* @example
	* ```typescript
	* const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
	* for await (const message of stream) {
	*   switch (message.type) {
	*     case 'taskCreated':
	*       console.log('Tool execution started:', message.task.taskId);
	*       break;
	*     case 'taskStatus':
	*       console.log('Tool status:', message.task.status);
	*       break;
	*     case 'result':
	*       console.log('Tool result:', message.result);
	*       break;
	*     case 'error':
	*       console.error('Tool error:', message.error);
	*       break;
	*   }
	* }
	* ```
	*
	* @param params - Tool call parameters (name and arguments)
	* @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
	* @param options - Optional request options (timeout, signal, task creation params, etc.)
	* @returns AsyncGenerator that yields ResponseMessage objects
	*
	* @experimental
	*/
	async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
		var _a;
		const clientInternal = this._client;
		const optionsWithTask = {
			...options,
			task: (_a = options === null || options === void 0 ? void 0 : options.task) !== null && _a !== void 0 ? _a : clientInternal.isToolTask(params.name) ? {} : void 0
		};
		const stream = clientInternal.requestStream({
			method: "tools/call",
			params
		}, resultSchema, optionsWithTask);
		const validator = clientInternal.getToolOutputValidator(params.name);
		for await (const message of stream) {
			if (message.type === "result" && validator) {
				const result = message.result;
				if (!result.structuredContent && !result.isError) {
					yield {
						type: "error",
						error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
					};
					return;
				}
				if (result.structuredContent) try {
					const validationResult = validator(result.structuredContent);
					if (!validationResult.valid) {
						yield {
							type: "error",
							error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
						};
						return;
					}
				} catch (error$1) {
					if (error$1 instanceof McpError) {
						yield {
							type: "error",
							error: error$1
						};
						return;
					}
					yield {
						type: "error",
						error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error$1 instanceof Error ? error$1.message : String(error$1)}`)
					};
					return;
				}
			}
			yield message;
		}
	}
	/**
	* Gets the current status of a task.
	*
	* @param taskId - The task identifier
	* @param options - Optional request options
	* @returns The task status
	*
	* @experimental
	*/
	async getTask(taskId, options) {
		return this._client.getTask({ taskId }, options);
	}
	/**
	* Retrieves the result of a completed task.
	*
	* @param taskId - The task identifier
	* @param resultSchema - Zod schema for validating the result
	* @param options - Optional request options
	* @returns The task result
	*
	* @experimental
	*/
	async getTaskResult(taskId, resultSchema, options) {
		return this._client.getTaskResult({ taskId }, resultSchema, options);
	}
	/**
	* Lists tasks with optional pagination.
	*
	* @param cursor - Optional pagination cursor
	* @param options - Optional request options
	* @returns List of tasks with optional next cursor
	*
	* @experimental
	*/
	async listTasks(cursor, options) {
		return this._client.listTasks(cursor ? { cursor } : void 0, options);
	}
	/**
	* Cancels a running task.
	*
	* @param taskId - The task identifier
	* @param options - Optional request options
	*
	* @experimental
	*/
	async cancelTask(taskId, options) {
		return this._client.cancelTask({ taskId }, options);
	}
	/**
	* Sends a request and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* This method provides streaming access to request processing, allowing you to
	* observe intermediate task status updates for task-augmented requests.
	*
	* @param request - The request to send
	* @param resultSchema - Zod schema for validating the result
	* @param options - Optional request options (timeout, signal, task creation params, etc.)
	* @returns AsyncGenerator that yields ResponseMessage objects
	*
	* @experimental
	*/
	requestStream(request, resultSchema, options) {
		return this._client.requestStream(request, resultSchema, options);
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
/**
* Experimental task capability assertion helpers.
* WARNING: These APIs are experimental and may change without notice.
*
* @experimental
*/
/**
* Asserts that task creation is supported for tools/call.
* Used by Client.assertTaskCapability and Server.assertTaskHandlerCapability.
*
* @param requests - The task requests capability object
* @param method - The method being checked
* @param entityName - 'Server' or 'Client' for error messages
* @throws Error if the capability is not supported
*
* @experimental
*/
function assertToolsCallTaskCapability(requests, method, entityName) {
	var _a;
	if (!requests) throw new Error(`${entityName} does not support task creation (required for ${method})`);
	switch (method) {
		case "tools/call":
			if (!((_a = requests.tools) === null || _a === void 0 ? void 0 : _a.call)) throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
			break;
		default: break;
	}
}
/**
* Asserts that task creation is supported for sampling/createMessage or elicitation/create.
* Used by Server.assertTaskCapability and Client.assertTaskHandlerCapability.
*
* @param requests - The task requests capability object
* @param method - The method being checked
* @param entityName - 'Server' or 'Client' for error messages
* @throws Error if the capability is not supported
*
* @experimental
*/
function assertClientRequestTaskCapability(requests, method, entityName) {
	var _a, _b;
	if (!requests) throw new Error(`${entityName} does not support task creation (required for ${method})`);
	switch (method) {
		case "sampling/createMessage":
			if (!((_a = requests.sampling) === null || _a === void 0 ? void 0 : _a.createMessage)) throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
			break;
		case "elicitation/create":
			if (!((_b = requests.elicitation) === null || _b === void 0 ? void 0 : _b.create)) throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
			break;
		default: break;
	}
}

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
/**
* Elicitation default application helper. Applies defaults to the data based on the schema.
*
* @param schema - The schema to apply defaults to.
* @param data - The data to apply defaults to.
*/
function applyElicitationDefaults(schema, data) {
	if (!schema || data === null || typeof data !== "object") return;
	if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
		const obj = data;
		const props = schema.properties;
		for (const key$1 of Object.keys(props)) {
			const propSchema = props[key$1];
			if (obj[key$1] === void 0 && Object.prototype.hasOwnProperty.call(propSchema, "default")) obj[key$1] = propSchema.default;
			if (obj[key$1] !== void 0) applyElicitationDefaults(propSchema, obj[key$1]);
		}
	}
	if (Array.isArray(schema.anyOf)) for (const sub of schema.anyOf) applyElicitationDefaults(sub, data);
	if (Array.isArray(schema.oneOf)) for (const sub of schema.oneOf) applyElicitationDefaults(sub, data);
}
/**
* Determines which elicitation modes are supported based on declared client capabilities.
*
* According to the spec:
* - An empty elicitation capability object defaults to form mode support (backwards compatibility)
* - URL mode is only supported if explicitly declared
*
* @param capabilities - The client's elicitation capabilities
* @returns An object indicating which modes are supported
*/
function getSupportedElicitationModes(capabilities) {
	if (!capabilities) return {
		supportsFormMode: false,
		supportsUrlMode: false
	};
	const hasFormCapability = capabilities.form !== void 0;
	const hasUrlCapability = capabilities.url !== void 0;
	return {
		supportsFormMode: hasFormCapability || !hasFormCapability && !hasUrlCapability,
		supportsUrlMode: hasUrlCapability
	};
}
/**
* An MCP client on top of a pluggable transport.
*
* The client will automatically begin the initialization flow with the server when connect() is called.
*
* To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
*
* ```typescript
* // Custom schemas
* const CustomRequestSchema = RequestSchema.extend({...})
* const CustomNotificationSchema = NotificationSchema.extend({...})
* const CustomResultSchema = ResultSchema.extend({...})
*
* // Type aliases
* type CustomRequest = z.infer<typeof CustomRequestSchema>
* type CustomNotification = z.infer<typeof CustomNotificationSchema>
* type CustomResult = z.infer<typeof CustomResultSchema>
*
* // Create typed client
* const client = new Client<CustomRequest, CustomNotification, CustomResult>({
*   name: "CustomClient",
*   version: "1.0.0"
* })
* ```
*/
var Client = class extends Protocol {
	/**
	* Initializes this client with the given name and version information.
	*/
	constructor(_clientInfo, options) {
		var _a, _b;
		super(options);
		this._clientInfo = _clientInfo;
		this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
		this._cachedKnownTaskTools = /* @__PURE__ */ new Set();
		this._cachedRequiredTaskTools = /* @__PURE__ */ new Set();
		this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
		this._jsonSchemaValidator = (_b = options === null || options === void 0 ? void 0 : options.jsonSchemaValidator) !== null && _b !== void 0 ? _b : new AjvJsonSchemaValidator();
	}
	/**
	* Access experimental features.
	*
	* WARNING: These APIs are experimental and may change without notice.
	*
	* @experimental
	*/
	get experimental() {
		if (!this._experimental) this._experimental = { tasks: new ExperimentalClientTasks(this) };
		return this._experimental;
	}
	/**
	* Registers new capabilities. This can only be called before connecting to a transport.
	*
	* The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
	*/
	registerCapabilities(capabilities) {
		if (this.transport) throw new Error("Cannot register capabilities after connecting to transport");
		this._capabilities = mergeCapabilities(this._capabilities, capabilities);
	}
	/**
	* Override request handler registration to enforce client-side validation for elicitation.
	*/
	setRequestHandler(requestSchema, handler) {
		var _a, _b, _c;
		const shape = getObjectShape(requestSchema);
		const methodSchema = shape === null || shape === void 0 ? void 0 : shape.method;
		if (!methodSchema) throw new Error("Schema is missing a method literal");
		let methodValue;
		if (isZ4Schema(methodSchema)) {
			const v4Schema = methodSchema;
			const v4Def = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def;
			methodValue = (_b = v4Def === null || v4Def === void 0 ? void 0 : v4Def.value) !== null && _b !== void 0 ? _b : v4Schema.value;
		} else {
			const v3Schema = methodSchema;
			const legacyDef = v3Schema._def;
			methodValue = (_c = legacyDef === null || legacyDef === void 0 ? void 0 : legacyDef.value) !== null && _c !== void 0 ? _c : v3Schema.value;
		}
		if (typeof methodValue !== "string") throw new Error("Schema method literal must be a string");
		const method = methodValue;
		if (method === "elicitation/create") {
			const wrappedHandler = async (request, extra) => {
				var _a$1, _b$1, _c$1;
				const validatedRequest = safeParse(ElicitRequestSchema, request);
				if (!validatedRequest.success) {
					const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
				}
				const { params } = validatedRequest.data;
				const mode = (_a$1 = params.mode) !== null && _a$1 !== void 0 ? _a$1 : "form";
				const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
				if (mode === "form" && !supportsFormMode) throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
				if (mode === "url" && !supportsUrlMode) throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
				const result = await Promise.resolve(handler(request, extra));
				if (params.task) {
					const taskValidationResult = safeParse(CreateTaskResultSchema, result);
					if (!taskValidationResult.success) {
						const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
						throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
					}
					return taskValidationResult.data;
				}
				const validationResult = safeParse(ElicitResultSchema, result);
				if (!validationResult.success) {
					const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
				}
				const validatedResult = validationResult.data;
				const requestedSchema = mode === "form" ? params.requestedSchema : void 0;
				if (mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
					if ((_c$1 = (_b$1 = this._capabilities.elicitation) === null || _b$1 === void 0 ? void 0 : _b$1.form) === null || _c$1 === void 0 ? void 0 : _c$1.applyDefaults) try {
						applyElicitationDefaults(requestedSchema, validatedResult.content);
					} catch (_d) {}
				}
				return validatedResult;
			};
			return super.setRequestHandler(requestSchema, wrappedHandler);
		}
		if (method === "sampling/createMessage") {
			const wrappedHandler = async (request, extra) => {
				const validatedRequest = safeParse(CreateMessageRequestSchema, request);
				if (!validatedRequest.success) {
					const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
				}
				const { params } = validatedRequest.data;
				const result = await Promise.resolve(handler(request, extra));
				if (params.task) {
					const taskValidationResult = safeParse(CreateTaskResultSchema, result);
					if (!taskValidationResult.success) {
						const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
						throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
					}
					return taskValidationResult.data;
				}
				const validationResult = safeParse(CreateMessageResultSchema, result);
				if (!validationResult.success) {
					const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
				}
				return validationResult.data;
			};
			return super.setRequestHandler(requestSchema, wrappedHandler);
		}
		return super.setRequestHandler(requestSchema, handler);
	}
	assertCapability(capability, method) {
		var _a;
		if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a[capability])) throw new Error(`Server does not support ${capability} (required for ${method})`);
	}
	async connect(transport, options) {
		await super.connect(transport);
		if (transport.sessionId !== void 0) return;
		try {
			const result = await this.request({
				method: "initialize",
				params: {
					protocolVersion: LATEST_PROTOCOL_VERSION,
					capabilities: this._capabilities,
					clientInfo: this._clientInfo
				}
			}, InitializeResultSchema, options);
			if (result === void 0) throw new Error(`Server sent invalid initialize result: ${result}`);
			if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
			this._serverCapabilities = result.capabilities;
			this._serverVersion = result.serverInfo;
			if (transport.setProtocolVersion) transport.setProtocolVersion(result.protocolVersion);
			this._instructions = result.instructions;
			await this.notification({ method: "notifications/initialized" });
		} catch (error$1) {
			this.close();
			throw error$1;
		}
	}
	/**
	* After initialization has completed, this will be populated with the server's reported capabilities.
	*/
	getServerCapabilities() {
		return this._serverCapabilities;
	}
	/**
	* After initialization has completed, this will be populated with information about the server's name and version.
	*/
	getServerVersion() {
		return this._serverVersion;
	}
	/**
	* After initialization has completed, this may be populated with information about the server's instructions.
	*/
	getInstructions() {
		return this._instructions;
	}
	assertCapabilityForMethod(method) {
		var _a, _b, _c, _d, _e;
		switch (method) {
			case "logging/setLevel":
				if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.logging)) throw new Error(`Server does not support logging (required for ${method})`);
				break;
			case "prompts/get":
			case "prompts/list":
				if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) throw new Error(`Server does not support prompts (required for ${method})`);
				break;
			case "resources/list":
			case "resources/templates/list":
			case "resources/read":
			case "resources/subscribe":
			case "resources/unsubscribe":
				if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) throw new Error(`Server does not support resources (required for ${method})`);
				if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) throw new Error(`Server does not support resource subscriptions (required for ${method})`);
				break;
			case "tools/call":
			case "tools/list":
				if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) throw new Error(`Server does not support tools (required for ${method})`);
				break;
			case "completion/complete":
				if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) throw new Error(`Server does not support completions (required for ${method})`);
				break;
			case "initialize": break;
			case "ping": break;
		}
	}
	assertNotificationCapability(method) {
		var _a;
		switch (method) {
			case "notifications/roots/list_changed":
				if (!((_a = this._capabilities.roots) === null || _a === void 0 ? void 0 : _a.listChanged)) throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
				break;
			case "notifications/initialized": break;
			case "notifications/cancelled": break;
			case "notifications/progress": break;
		}
	}
	assertRequestHandlerCapability(method) {
		if (!this._capabilities) return;
		switch (method) {
			case "sampling/createMessage":
				if (!this._capabilities.sampling) throw new Error(`Client does not support sampling capability (required for ${method})`);
				break;
			case "elicitation/create":
				if (!this._capabilities.elicitation) throw new Error(`Client does not support elicitation capability (required for ${method})`);
				break;
			case "roots/list":
				if (!this._capabilities.roots) throw new Error(`Client does not support roots capability (required for ${method})`);
				break;
			case "tasks/get":
			case "tasks/list":
			case "tasks/result":
			case "tasks/cancel":
				if (!this._capabilities.tasks) throw new Error(`Client does not support tasks capability (required for ${method})`);
				break;
			case "ping": break;
		}
	}
	assertTaskCapability(method) {
		var _a, _b;
		assertToolsCallTaskCapability((_b = (_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.tasks) === null || _b === void 0 ? void 0 : _b.requests, method, "Server");
	}
	assertTaskHandlerCapability(method) {
		var _a;
		if (!this._capabilities) return;
		assertClientRequestTaskCapability((_a = this._capabilities.tasks) === null || _a === void 0 ? void 0 : _a.requests, method, "Client");
	}
	async ping(options) {
		return this.request({ method: "ping" }, EmptyResultSchema, options);
	}
	async complete(params, options) {
		return this.request({
			method: "completion/complete",
			params
		}, CompleteResultSchema, options);
	}
	async setLoggingLevel(level, options) {
		return this.request({
			method: "logging/setLevel",
			params: { level }
		}, EmptyResultSchema, options);
	}
	async getPrompt(params, options) {
		return this.request({
			method: "prompts/get",
			params
		}, GetPromptResultSchema, options);
	}
	async listPrompts(params, options) {
		return this.request({
			method: "prompts/list",
			params
		}, ListPromptsResultSchema, options);
	}
	async listResources(params, options) {
		return this.request({
			method: "resources/list",
			params
		}, ListResourcesResultSchema, options);
	}
	async listResourceTemplates(params, options) {
		return this.request({
			method: "resources/templates/list",
			params
		}, ListResourceTemplatesResultSchema, options);
	}
	async readResource(params, options) {
		return this.request({
			method: "resources/read",
			params
		}, ReadResourceResultSchema, options);
	}
	async subscribeResource(params, options) {
		return this.request({
			method: "resources/subscribe",
			params
		}, EmptyResultSchema, options);
	}
	async unsubscribeResource(params, options) {
		return this.request({
			method: "resources/unsubscribe",
			params
		}, EmptyResultSchema, options);
	}
	/**
	* Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
	*
	* For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
	*/
	async callTool(params, resultSchema = CallToolResultSchema, options) {
		if (this.isToolTaskRequired(params.name)) throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
		const result = await this.request({
			method: "tools/call",
			params
		}, resultSchema, options);
		const validator = this.getToolOutputValidator(params.name);
		if (validator) {
			if (!result.structuredContent && !result.isError) throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
			if (result.structuredContent) try {
				const validationResult = validator(result.structuredContent);
				if (!validationResult.valid) throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
			} catch (error$1) {
				if (error$1 instanceof McpError) throw error$1;
				throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error$1 instanceof Error ? error$1.message : String(error$1)}`);
			}
		}
		return result;
	}
	isToolTask(toolName) {
		var _a, _b, _c, _d;
		if (!((_d = (_c = (_b = (_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.tasks) === null || _b === void 0 ? void 0 : _b.requests) === null || _c === void 0 ? void 0 : _c.tools) === null || _d === void 0 ? void 0 : _d.call)) return false;
		return this._cachedKnownTaskTools.has(toolName);
	}
	/**
	* Check if a tool requires task-based execution.
	* Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
	*/
	isToolTaskRequired(toolName) {
		return this._cachedRequiredTaskTools.has(toolName);
	}
	/**
	* Cache validators for tool output schemas.
	* Called after listTools() to pre-compile validators for better performance.
	*/
	cacheToolMetadata(tools) {
		var _a;
		this._cachedToolOutputValidators.clear();
		this._cachedKnownTaskTools.clear();
		this._cachedRequiredTaskTools.clear();
		for (const tool of tools) {
			if (tool.outputSchema) {
				const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
				this._cachedToolOutputValidators.set(tool.name, toolValidator);
			}
			const taskSupport = (_a = tool.execution) === null || _a === void 0 ? void 0 : _a.taskSupport;
			if (taskSupport === "required" || taskSupport === "optional") this._cachedKnownTaskTools.add(tool.name);
			if (taskSupport === "required") this._cachedRequiredTaskTools.add(tool.name);
		}
	}
	/**
	* Get cached validator for a tool
	*/
	getToolOutputValidator(toolName) {
		return this._cachedToolOutputValidators.get(toolName);
	}
	async listTools(params, options) {
		const result = await this.request({
			method: "tools/list",
			params
		}, ListToolsResultSchema, options);
		this.cacheToolMetadata(result.tools);
		return result;
	}
	async sendRootsListChanged() {
		return this.notification({ method: "notifications/roots/list_changed" });
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
/**
* Experimental server task features for MCP SDK.
* WARNING: These APIs are experimental and may change without notice.
*
* @experimental
*/
/**
* Experimental task features for low-level MCP servers.
*
* Access via `server.experimental.tasks`:
* ```typescript
* const stream = server.experimental.tasks.requestStream(request, schema, options);
* ```
*
* For high-level server usage with task-based tools, use `McpServer.experimental.tasks` instead.
*
* @experimental
*/
var ExperimentalServerTasks = class {
	constructor(_server) {
		this._server = _server;
	}
	/**
	* Sends a request and returns an AsyncGenerator that yields response messages.
	* The generator is guaranteed to end with either a 'result' or 'error' message.
	*
	* This method provides streaming access to request processing, allowing you to
	* observe intermediate task status updates for task-augmented requests.
	*
	* @param request - The request to send
	* @param resultSchema - Zod schema for validating the result
	* @param options - Optional request options (timeout, signal, task creation params, etc.)
	* @returns AsyncGenerator that yields ResponseMessage objects
	*
	* @experimental
	*/
	requestStream(request, resultSchema, options) {
		return this._server.requestStream(request, resultSchema, options);
	}
	/**
	* Gets the current status of a task.
	*
	* @param taskId - The task identifier
	* @param options - Optional request options
	* @returns The task status
	*
	* @experimental
	*/
	async getTask(taskId, options) {
		return this._server.getTask({ taskId }, options);
	}
	/**
	* Retrieves the result of a completed task.
	*
	* @param taskId - The task identifier
	* @param resultSchema - Zod schema for validating the result
	* @param options - Optional request options
	* @returns The task result
	*
	* @experimental
	*/
	async getTaskResult(taskId, resultSchema, options) {
		return this._server.getTaskResult({ taskId }, resultSchema, options);
	}
	/**
	* Lists tasks with optional pagination.
	*
	* @param cursor - Optional pagination cursor
	* @param options - Optional request options
	* @returns List of tasks with optional next cursor
	*
	* @experimental
	*/
	async listTasks(cursor, options) {
		return this._server.listTasks(cursor ? { cursor } : void 0, options);
	}
	/**
	* Cancels a running task.
	*
	* @param taskId - The task identifier
	* @param options - Optional request options
	*
	* @experimental
	*/
	async cancelTask(taskId, options) {
		return this._server.cancelTask({ taskId }, options);
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
/**
* An MCP server on top of a pluggable transport.
*
* This server will automatically respond to the initialization flow as initiated from the client.
*
* To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
*
* ```typescript
* // Custom schemas
* const CustomRequestSchema = RequestSchema.extend({...})
* const CustomNotificationSchema = NotificationSchema.extend({...})
* const CustomResultSchema = ResultSchema.extend({...})
*
* // Type aliases
* type CustomRequest = z.infer<typeof CustomRequestSchema>
* type CustomNotification = z.infer<typeof CustomNotificationSchema>
* type CustomResult = z.infer<typeof CustomResultSchema>
*
* // Create typed server
* const server = new Server<CustomRequest, CustomNotification, CustomResult>({
*   name: "CustomServer",
*   version: "1.0.0"
* })
* ```
* @deprecated Use `McpServer` instead for the high-level API. Only use `Server` for advanced use cases.
*/
var Server = class extends Protocol {
	/**
	* Initializes this server with the given name and version information.
	*/
	constructor(_serverInfo, options) {
		var _a, _b;
		super(options);
		this._serverInfo = _serverInfo;
		this._loggingLevels = /* @__PURE__ */ new Map();
		this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));
		this.isMessageIgnored = (level, sessionId) => {
			const currentLevel = this._loggingLevels.get(sessionId);
			return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
		};
		this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
		this._instructions = options === null || options === void 0 ? void 0 : options.instructions;
		this._jsonSchemaValidator = (_b = options === null || options === void 0 ? void 0 : options.jsonSchemaValidator) !== null && _b !== void 0 ? _b : new AjvJsonSchemaValidator();
		this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
		this.setNotificationHandler(InitializedNotificationSchema, () => {
			var _a$1;
			return (_a$1 = this.oninitialized) === null || _a$1 === void 0 ? void 0 : _a$1.call(this);
		});
		if (this._capabilities.logging) this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
			var _a$1;
			const transportSessionId = extra.sessionId || ((_a$1 = extra.requestInfo) === null || _a$1 === void 0 ? void 0 : _a$1.headers["mcp-session-id"]) || void 0;
			const { level } = request.params;
			const parseResult = LoggingLevelSchema.safeParse(level);
			if (parseResult.success) this._loggingLevels.set(transportSessionId, parseResult.data);
			return {};
		});
	}
	/**
	* Access experimental features.
	*
	* WARNING: These APIs are experimental and may change without notice.
	*
	* @experimental
	*/
	get experimental() {
		if (!this._experimental) this._experimental = { tasks: new ExperimentalServerTasks(this) };
		return this._experimental;
	}
	/**
	* Registers new capabilities. This can only be called before connecting to a transport.
	*
	* The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
	*/
	registerCapabilities(capabilities) {
		if (this.transport) throw new Error("Cannot register capabilities after connecting to transport");
		this._capabilities = mergeCapabilities(this._capabilities, capabilities);
	}
	/**
	* Override request handler registration to enforce server-side validation for tools/call.
	*/
	setRequestHandler(requestSchema, handler) {
		var _a, _b, _c;
		const shape = getObjectShape(requestSchema);
		const methodSchema = shape === null || shape === void 0 ? void 0 : shape.method;
		if (!methodSchema) throw new Error("Schema is missing a method literal");
		let methodValue;
		if (isZ4Schema(methodSchema)) {
			const v4Schema = methodSchema;
			const v4Def = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def;
			methodValue = (_b = v4Def === null || v4Def === void 0 ? void 0 : v4Def.value) !== null && _b !== void 0 ? _b : v4Schema.value;
		} else {
			const v3Schema = methodSchema;
			const legacyDef = v3Schema._def;
			methodValue = (_c = legacyDef === null || legacyDef === void 0 ? void 0 : legacyDef.value) !== null && _c !== void 0 ? _c : v3Schema.value;
		}
		if (typeof methodValue !== "string") throw new Error("Schema method literal must be a string");
		if (methodValue === "tools/call") {
			const wrappedHandler = async (request, extra) => {
				const validatedRequest = safeParse(CallToolRequestSchema, request);
				if (!validatedRequest.success) {
					const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
				}
				const { params } = validatedRequest.data;
				const result = await Promise.resolve(handler(request, extra));
				if (params.task) {
					const taskValidationResult = safeParse(CreateTaskResultSchema, result);
					if (!taskValidationResult.success) {
						const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
						throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
					}
					return taskValidationResult.data;
				}
				const validationResult = safeParse(CallToolResultSchema, result);
				if (!validationResult.success) {
					const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
					throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
				}
				return validationResult.data;
			};
			return super.setRequestHandler(requestSchema, wrappedHandler);
		}
		return super.setRequestHandler(requestSchema, handler);
	}
	assertCapabilityForMethod(method) {
		var _a, _b, _c;
		switch (method) {
			case "sampling/createMessage":
				if (!((_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling)) throw new Error(`Client does not support sampling (required for ${method})`);
				break;
			case "elicitation/create":
				if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation)) throw new Error(`Client does not support elicitation (required for ${method})`);
				break;
			case "roots/list":
				if (!((_c = this._clientCapabilities) === null || _c === void 0 ? void 0 : _c.roots)) throw new Error(`Client does not support listing roots (required for ${method})`);
				break;
			case "ping": break;
		}
	}
	assertNotificationCapability(method) {
		var _a, _b;
		switch (method) {
			case "notifications/message":
				if (!this._capabilities.logging) throw new Error(`Server does not support logging (required for ${method})`);
				break;
			case "notifications/resources/updated":
			case "notifications/resources/list_changed":
				if (!this._capabilities.resources) throw new Error(`Server does not support notifying about resources (required for ${method})`);
				break;
			case "notifications/tools/list_changed":
				if (!this._capabilities.tools) throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
				break;
			case "notifications/prompts/list_changed":
				if (!this._capabilities.prompts) throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
				break;
			case "notifications/elicitation/complete":
				if (!((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.elicitation) === null || _b === void 0 ? void 0 : _b.url)) throw new Error(`Client does not support URL elicitation (required for ${method})`);
				break;
			case "notifications/cancelled": break;
			case "notifications/progress": break;
		}
	}
	assertRequestHandlerCapability(method) {
		if (!this._capabilities) return;
		switch (method) {
			case "completion/complete":
				if (!this._capabilities.completions) throw new Error(`Server does not support completions (required for ${method})`);
				break;
			case "logging/setLevel":
				if (!this._capabilities.logging) throw new Error(`Server does not support logging (required for ${method})`);
				break;
			case "prompts/get":
			case "prompts/list":
				if (!this._capabilities.prompts) throw new Error(`Server does not support prompts (required for ${method})`);
				break;
			case "resources/list":
			case "resources/templates/list":
			case "resources/read":
				if (!this._capabilities.resources) throw new Error(`Server does not support resources (required for ${method})`);
				break;
			case "tools/call":
			case "tools/list":
				if (!this._capabilities.tools) throw new Error(`Server does not support tools (required for ${method})`);
				break;
			case "tasks/get":
			case "tasks/list":
			case "tasks/result":
			case "tasks/cancel":
				if (!this._capabilities.tasks) throw new Error(`Server does not support tasks capability (required for ${method})`);
				break;
			case "ping":
			case "initialize": break;
		}
	}
	assertTaskCapability(method) {
		var _a, _b;
		assertClientRequestTaskCapability((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.tasks) === null || _b === void 0 ? void 0 : _b.requests, method, "Client");
	}
	assertTaskHandlerCapability(method) {
		var _a;
		if (!this._capabilities) return;
		assertToolsCallTaskCapability((_a = this._capabilities.tasks) === null || _a === void 0 ? void 0 : _a.requests, method, "Server");
	}
	async _oninitialize(request) {
		const requestedVersion = request.params.protocolVersion;
		this._clientCapabilities = request.params.capabilities;
		this._clientVersion = request.params.clientInfo;
		return {
			protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
			capabilities: this.getCapabilities(),
			serverInfo: this._serverInfo,
			...this._instructions && { instructions: this._instructions }
		};
	}
	/**
	* After initialization has completed, this will be populated with the client's reported capabilities.
	*/
	getClientCapabilities() {
		return this._clientCapabilities;
	}
	/**
	* After initialization has completed, this will be populated with information about the client's name and version.
	*/
	getClientVersion() {
		return this._clientVersion;
	}
	getCapabilities() {
		return this._capabilities;
	}
	async ping() {
		return this.request({ method: "ping" }, EmptyResultSchema);
	}
	async createMessage(params, options) {
		var _a, _b;
		if (params.tools || params.toolChoice) {
			if (!((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling) === null || _b === void 0 ? void 0 : _b.tools)) throw new Error("Client does not support sampling tools capability.");
		}
		if (params.messages.length > 0) {
			const lastMessage = params.messages[params.messages.length - 1];
			const lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content];
			const hasToolResults = lastContent.some((c) => c.type === "tool_result");
			const previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0;
			const previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [];
			const hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
			if (hasToolResults) {
				if (lastContent.some((c) => c.type !== "tool_result")) throw new Error("The last message must contain only tool_result content if any is present");
				if (!hasPreviousToolUse) throw new Error("tool_result blocks are not matching any tool_use from the previous message");
			}
			if (hasPreviousToolUse) {
				const toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id));
				const toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
				if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id))) throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
			}
		}
		if (params.tools) return this.request({
			method: "sampling/createMessage",
			params
		}, CreateMessageResultWithToolsSchema, options);
		return this.request({
			method: "sampling/createMessage",
			params
		}, CreateMessageResultSchema, options);
	}
	/**
	* Creates an elicitation request for the given parameters.
	* For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
	* @param params The parameters for the elicitation request.
	* @param options Optional request options.
	* @returns The result of the elicitation request.
	*/
	async elicitInput(params, options) {
		var _a, _b, _c, _d, _e;
		switch ((_a = params.mode) !== null && _a !== void 0 ? _a : "form") {
			case "url": {
				if (!((_c = (_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation) === null || _c === void 0 ? void 0 : _c.url)) throw new Error("Client does not support url elicitation.");
				const urlParams = params;
				return this.request({
					method: "elicitation/create",
					params: urlParams
				}, ElicitResultSchema, options);
			}
			case "form": {
				if (!((_e = (_d = this._clientCapabilities) === null || _d === void 0 ? void 0 : _d.elicitation) === null || _e === void 0 ? void 0 : _e.form)) throw new Error("Client does not support form elicitation.");
				const formParams = params.mode === "form" ? params : {
					...params,
					mode: "form"
				};
				const result = await this.request({
					method: "elicitation/create",
					params: formParams
				}, ElicitResultSchema, options);
				if (result.action === "accept" && result.content && formParams.requestedSchema) try {
					const validationResult = this._jsonSchemaValidator.getValidator(formParams.requestedSchema)(result.content);
					if (!validationResult.valid) throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
				} catch (error$1) {
					if (error$1 instanceof McpError) throw error$1;
					throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error$1 instanceof Error ? error$1.message : String(error$1)}`);
				}
				return result;
			}
		}
	}
	/**
	* Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
	* notification for the specified elicitation ID.
	*
	* @param elicitationId The ID of the elicitation to mark as complete.
	* @param options Optional notification options. Useful when the completion notification should be related to a prior request.
	* @returns A function that emits the completion notification when awaited.
	*/
	createElicitationCompletionNotifier(elicitationId, options) {
		var _a, _b;
		if (!((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.elicitation) === null || _b === void 0 ? void 0 : _b.url)) throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
		return () => this.notification({
			method: "notifications/elicitation/complete",
			params: { elicitationId }
		}, options);
	}
	async listRoots(params, options) {
		return this.request({
			method: "roots/list",
			params
		}, ListRootsResultSchema, options);
	}
	/**
	* Sends a logging message to the client, if connected.
	* Note: You only need to send the parameters object, not the entire JSON RPC message
	* @see LoggingMessageNotification
	* @param params
	* @param sessionId optional for stateless and backward compatibility
	*/
	async sendLoggingMessage(params, sessionId) {
		if (this._capabilities.logging) {
			if (!this.isMessageIgnored(params.level, sessionId)) return this.notification({
				method: "notifications/message",
				params
			});
		}
	}
	async sendResourceUpdated(params) {
		return this.notification({
			method: "notifications/resources/updated",
			params
		});
	}
	async sendResourceListChanged() {
		return this.notification({ method: "notifications/resources/list_changed" });
	}
	async sendToolListChanged() {
		return this.notification({ method: "notifications/tools/list_changed" });
	}
	async sendPromptListChanged() {
		return this.notification({ method: "notifications/prompts/list_changed" });
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.24.3_zod@3.25.76/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
/**
* Buffers a continuous stdio stream into discrete JSON-RPC messages.
*/
var ReadBuffer = class {
	append(chunk) {
		this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
	}
	readMessage() {
		if (!this._buffer) return null;
		const index = this._buffer.indexOf("\n");
		if (index === -1) return null;
		const line$1 = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
		this._buffer = this._buffer.subarray(index + 1);
		return deserializeMessage(line$1);
	}
	clear() {
		this._buffer = void 0;
	}
};
function deserializeMessage(line$1) {
	return JSONRPCMessageSchema.parse(JSON.parse(line$1));
}
function serializeMessage(message) {
	return JSON.stringify(message) + "\n";
}

//#endregion
export { NEVER as C, __toESM as D, __commonJSMin as E, _coercedNumber as S, AuthenticationMiddleware as T, looseObject as _, startHTTPServer as a, string as b, LATEST_PROTOCOL_VERSION as c, isJSONRPCResponse as d, ZodNumber as f, literal as g, boolean as h, Client as i, isInitializedNotification as l, array as m, serializeMessage as n, proxyServer as o, any as p, Server as r, JSONRPCMessageSchema as s, ReadBuffer as t, isJSONRPCRequest as u, number as v, InMemoryEventStore as w, url as x, object as y };
//# sourceMappingURL=stdio-DBuYn6eo.mjs.map