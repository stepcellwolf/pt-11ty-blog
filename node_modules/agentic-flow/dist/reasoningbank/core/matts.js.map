{"version":3,"file":"matts.js","sourceRoot":"","sources":["../../../src/reasoningbank/core/matts.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * MaTTS: Memory-aware Test-Time Scaling\n * Algorithm 5 from ReasoningBank paper\n *\n * Two modes:\n * - Parallel: k independent rollouts with self-contrast aggregation\n * - Sequential: r iterative refinements with check-and-correct\n */\n\nimport { readFileSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport { ulid } from 'ulid';\nimport { loadConfig } from '../utils/config.js';\nimport { retrieveMemories } from './retrieve.js';\nimport { judgeTrajectory } from './judge.js';\nimport { distillMemories } from './distill.js';\nimport { ModelRouter } from '../../router/router.js';\nimport * as db from '../db/queries.js';\nimport type { Trajectory } from '../db/schema.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Initialize ModelRouter once\nlet routerInstance: ModelRouter | null = null;\nfunction getRouter(): ModelRouter {\n  if (!routerInstance) {\n    routerInstance = new ModelRouter();\n  }\n  return routerInstance;\n}\n\nexport interface MattsResult {\n  runId: string;\n  mode: 'parallel' | 'sequential';\n  k: number;\n  trajectories: Array<{\n    id: string;\n    verdict: { label: string; confidence: number };\n    trajectory: Trajectory;\n  }>;\n  aggregatedMemories: string[];\n  successRate: number;\n  duration: number;\n}\n\n/**\n * Run MaTTS in parallel mode\n * Execute k independent rollouts and aggregate via self-contrast\n */\nexport async function mattsParallel(\n  taskFn: () => Promise<Trajectory>,\n  query: string,\n  options: { k?: number; taskId?: string; agentId?: string; domain?: string } = {}\n): Promise<MattsResult> {\n  const config = loadConfig();\n  const k = options.k || config.matts.parallel_k;\n  const runId = ulid();\n  const startTime = Date.now();\n\n  console.log(`[INFO] Starting MaTTS parallel mode with k=${k}`);\n\n  // Store MaTTS run\n  db.storeMattsRun({\n    run_id: runId,\n    task_id: options.taskId || 'matts-' + runId,\n    mode: 'parallel',\n    k,\n    status: 'running',\n    summary: undefined\n  });\n\n  const trajectories: MattsResult['trajectories'] = [];\n\n  // Execute k independent rollouts\n  for (let i = 0; i < k; i++) {\n    console.log(`[INFO] MaTTS parallel rollout ${i + 1}/${k}`);\n\n    try {\n      const trajectory = await taskFn();\n      const verdict = await judgeTrajectory(trajectory, query);\n\n      trajectories.push({\n        id: ulid(),\n        verdict,\n        trajectory\n      });\n\n      // Store trajectory\n      db.storeTrajectory({\n        task_id: options.taskId || 'matts-' + runId,\n        agent_id: options.agentId || 'matts-agent',\n        query,\n        trajectory_json: JSON.stringify(trajectory),\n        started_at: new Date().toISOString(),\n        ended_at: new Date().toISOString(),\n        judge_label: verdict.label,\n        judge_conf: verdict.confidence,\n        judge_reasons: JSON.stringify(verdict.reasons),\n        matts_run_id: runId\n      });\n    } catch (error) {\n      console.error(`[ERROR] MaTTS rollout ${i + 1} failed:`, error);\n    }\n  }\n\n  // Aggregate memories via self-contrast\n  const aggregatedMemories = await aggregateMemories(trajectories, query, options);\n\n  const successRate = trajectories.filter(t => t.verdict.label === 'Success').length / trajectories.length;\n  const duration = Date.now() - startTime;\n\n  console.log(`[INFO] MaTTS parallel complete: ${trajectories.length} trajectories, ${successRate * 100}% success in ${duration}ms`);\n\n  db.logMetric('rb.matts.parallel.duration_ms', duration);\n  db.logMetric('rb.matts.parallel.success_rate', successRate);\n  db.logMetric('rb.matts.parallel.memories', aggregatedMemories.length);\n\n  return {\n    runId,\n    mode: 'parallel',\n    k,\n    trajectories,\n    aggregatedMemories,\n    successRate,\n    duration\n  };\n}\n\n/**\n * Run MaTTS in sequential mode\n * Iterative refinement with check-and-correct\n */\nexport async function mattsSequential(\n  taskFn: (memories: any[]) => Promise<Trajectory>,\n  query: string,\n  options: { r?: number; taskId?: string; agentId?: string; domain?: string } = {}\n): Promise<MattsResult> {\n  const config = loadConfig();\n  const r = options.r || config.matts.sequential_r || config.matts.sequential_k;\n  const runId = ulid();\n  const startTime = Date.now();\n\n  console.log(`[INFO] Starting MaTTS sequential mode with r=${r}`);\n\n  db.storeMattsRun({\n    run_id: runId,\n    task_id: options.taskId || 'matts-seq-' + runId,\n    mode: 'sequential',\n    k: r,\n    status: 'running',\n    summary: undefined\n  });\n\n  const trajectories: MattsResult['trajectories'] = [];\n  let previousMemories: any[] = [];\n\n  // Iterative refinement\n  for (let i = 0; i < r; i++) {\n    console.log(`[INFO] MaTTS sequential iteration ${i + 1}/${r}`);\n\n    try {\n      // Retrieve relevant memories (including from previous iterations)\n      const memories = await retrieveMemories(query, {\n        domain: options.domain\n      });\n\n      // Execute with memories\n      const trajectory = await taskFn([...memories, ...previousMemories]);\n      const verdict = await judgeTrajectory(trajectory, query);\n\n      trajectories.push({\n        id: ulid(),\n        verdict,\n        trajectory\n      });\n\n      // If success and stop_on_success is true, break early\n      if (verdict.label === 'Success' && (config.matts.sequential_stop_on_success ?? true)) {\n        console.log(`[INFO] Success achieved at iteration ${i + 1}, stopping early`);\n        break;\n      }\n\n      // Distill memories from this iteration\n      const newMemories = await distillMemories(trajectory, verdict, query, options);\n      previousMemories = [...previousMemories, ...newMemories];\n\n      // Store trajectory\n      db.storeTrajectory({\n        task_id: options.taskId || 'matts-seq-' + runId,\n        agent_id: options.agentId || 'matts-agent',\n        query,\n        trajectory_json: JSON.stringify(trajectory),\n        started_at: new Date().toISOString(),\n        ended_at: new Date().toISOString(),\n        judge_label: verdict.label,\n        judge_conf: verdict.confidence,\n        judge_reasons: JSON.stringify(verdict.reasons),\n        matts_run_id: runId\n      });\n    } catch (error) {\n      console.error(`[ERROR] MaTTS iteration ${i + 1} failed:`, error);\n    }\n  }\n\n  const successRate = trajectories.filter(t => t.verdict.label === 'Success').length / trajectories.length;\n  const duration = Date.now() - startTime;\n\n  console.log(`[INFO] MaTTS sequential complete: ${trajectories.length} iterations, ${successRate * 100}% success in ${duration}ms`);\n\n  db.logMetric('rb.matts.sequential.duration_ms', duration);\n  db.logMetric('rb.matts.sequential.success_rate', successRate);\n\n  return {\n    runId,\n    mode: 'sequential',\n    k: r,\n    trajectories,\n    aggregatedMemories: previousMemories,\n    successRate,\n    duration\n  };\n}\n\n/**\n * Aggregate memories from multiple trajectories using self-contrast\n */\nasync function aggregateMemories(\n  trajectories: MattsResult['trajectories'],\n  query: string,\n  options: any\n): Promise<string[]> {\n  console.log('[INFO] Aggregating memories via self-contrast');\n\n  // Load aggregation prompt\n  const promptPath = join(__dirname, '../prompts', 'matts-aggregate.json');\n  const promptTemplate = JSON.parse(readFileSync(promptPath, 'utf-8'));\n\n  // Format trajectories for comparison\n  const trajectoryTexts = trajectories.map((t, i) => ({\n    id: t.id,\n    label: t.verdict.label,\n    confidence: t.verdict.confidence,\n    steps: JSON.stringify(t.trajectory.steps || [], null, 2)\n  }));\n\n  // Check if we have any API key configured\n  const hasApiKey = process.env.OPENROUTER_API_KEY ||\n                    process.env.ANTHROPIC_API_KEY ||\n                    process.env.GOOGLE_GEMINI_API_KEY;\n\n  if (!hasApiKey) {\n    console.warn('[WARN] No API key set, skipping aggregation');\n    return [];\n  }\n\n  try {\n    const prompt = promptTemplate.template\n      .replace('{{k}}', String(trajectories.length))\n      .replace('{{task_query}}', query)\n      .replace('{{trajectories}}', JSON.stringify(trajectoryTexts, null, 2));\n\n    // Use ModelRouter for multi-provider support\n    const router = getRouter();\n    const response = await router.chat({\n      model: promptTemplate.model,\n      messages: [\n        { role: 'system', content: promptTemplate.system },\n        { role: 'user', content: prompt }\n      ],\n      temperature: promptTemplate.temperature,\n      maxTokens: promptTemplate.max_tokens\n    }, 'reasoningbank-matts-aggregate');\n\n    // Extract content from router response\n    const content = response.content\n      .filter(block => block.type === 'text')\n      .map(block => block.text)\n      .join('\\n');\n\n    // Parse and store aggregated memories\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      const parsed = JSON.parse(jsonMatch[0]);\n      const memories = parsed.memories || [];\n\n      // Store with boosted confidence\n      const memoryIds: string[] = [];\n      for (const mem of memories) {\n        const verdict = { label: 'Success' as const, confidence: 0.9, reasons: [] };\n        const ids = await distillMemories(\n          { steps: [] },\n          verdict,\n          query,\n          options\n        );\n        memoryIds.push(...ids);\n      }\n\n      return memoryIds;\n    }\n  } catch (error) {\n    console.error('[ERROR] Memory aggregation failed:', error);\n  }\n\n  return [];\n}\n"]}