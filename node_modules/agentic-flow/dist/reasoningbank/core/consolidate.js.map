{"version":3,"file":"consolidate.js","sourceRoot":"","sources":["../../../src/reasoningbank/core/consolidate.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Memory Consolidation\n * Algorithm 4 from ReasoningBank paper: Dedup, Contradict, Prune\n */\n\nimport { ulid } from 'ulid';\nimport { loadConfig } from '../utils/config.js';\nimport { cosineSimilarity } from '../utils/mmr.js';\nimport * as db from '../db/queries.js';\n\nexport interface ConsolidationResult {\n  itemsProcessed: number;\n  duplicatesFound: number;\n  contradictionsFound: number;\n  itemsPruned: number;\n  durationMs: number;\n}\n\n/**\n * Run consolidation: deduplicate, detect contradictions, prune old memories\n */\nexport async function consolidate(): Promise<ConsolidationResult> {\n  const config = loadConfig();\n  const startTime = Date.now();\n\n  console.log('[INFO] Starting memory consolidation...');\n\n  const runId = ulid();\n  const memories = db.getAllActiveMemories();\n\n  console.log(`[INFO] Processing ${memories.length} active memories`);\n\n  let duplicatesFound = 0;\n  let contradictionsFound = 0;\n  let itemsPruned = 0;\n\n  // Step 1: Deduplicate similar memories\n  duplicatesFound = await deduplicateMemories(memories, config.consolidate.duplicate_threshold);\n\n  // Step 2: Detect contradictions\n  contradictionsFound = await detectContradictions(memories, config.consolidate.contradiction_threshold);\n\n  // Step 3: Prune old, unused memories\n  itemsPruned = db.pruneOldMemories({\n    maxAgeDays: config.consolidate.prune_age_days,\n    minConfidence: config.consolidate.min_confidence_keep\n  });\n\n  const durationMs = Date.now() - startTime;\n\n  // Store consolidation run\n  db.storeConsolidationRun({\n    run_id: runId,\n    items_processed: memories.length,\n    duplicates_found: duplicatesFound,\n    contradictions_found: contradictionsFound,\n    items_pruned: itemsPruned,\n    duration_ms: durationMs\n  });\n\n  console.log(`[INFO] Consolidation complete: ${duplicatesFound} dupes, ${contradictionsFound} contradictions, ${itemsPruned} pruned in ${durationMs}ms`);\n\n  db.logMetric('rb.consolidate.duration_ms', durationMs);\n  db.logMetric('rb.consolidate.duplicates', duplicatesFound);\n  db.logMetric('rb.consolidate.contradictions', contradictionsFound);\n  db.logMetric('rb.consolidate.pruned', itemsPruned);\n\n  return {\n    itemsProcessed: memories.length,\n    duplicatesFound,\n    contradictionsFound,\n    itemsPruned,\n    durationMs\n  };\n}\n\n/**\n * Deduplicate highly similar memories\n */\nasync function deduplicateMemories(\n  memories: any[],\n  threshold: number\n): Promise<number> {\n  let duplicatesFound = 0;\n\n  // Fetch embeddings for all memories\n  const dbConn = db.getDb();\n  const embeddingsMap = new Map<string, Float32Array>();\n\n  for (const mem of memories) {\n    const row = dbConn.prepare('SELECT vector FROM pattern_embeddings WHERE id = ?').get(mem.id) as { vector: Buffer } | undefined;\n    if (row) {\n      embeddingsMap.set(mem.id, new Float32Array(row.vector));\n    }\n  }\n\n  // Compare all pairs\n  for (let i = 0; i < memories.length; i++) {\n    for (let j = i + 1; j < memories.length; j++) {\n      const mem1 = memories[i];\n      const mem2 = memories[j];\n\n      const emb1 = embeddingsMap.get(mem1.id);\n      const emb2 = embeddingsMap.get(mem2.id);\n\n      if (!emb1 || !emb2) continue;\n\n      const similarity = cosineSimilarity(emb1, emb2);\n\n      if (similarity >= threshold) {\n        // Mark as duplicate\n        db.storeLink(mem1.id, mem2.id, 'duplicate_of', similarity);\n        duplicatesFound++;\n\n        // Merge: keep the one with higher usage\n        if (mem1.usage_count < mem2.usage_count) {\n          // Delete mem1 (lower usage)\n          dbConn.prepare('DELETE FROM patterns WHERE id = ?').run(mem1.id);\n          console.log(`[INFO] Merged duplicate: ${mem1.pattern_data.title} â†’ ${mem2.pattern_data.title}`);\n        }\n      }\n    }\n  }\n\n  return duplicatesFound;\n}\n\n/**\n * Detect contradicting memories\n * Uses embedding similarity + semantic analysis\n */\nasync function detectContradictions(\n  memories: any[],\n  threshold: number\n): Promise<number> {\n  let contradictionsFound = 0;\n\n  const dbConn = db.getDb();\n  const embeddingsMap = new Map<string, Float32Array>();\n\n  for (const mem of memories) {\n    const row = dbConn.prepare('SELECT vector FROM pattern_embeddings WHERE id = ?').get(mem.id) as { vector: Buffer } | undefined;\n    if (row) {\n      embeddingsMap.set(mem.id, new Float32Array(row.vector));\n    }\n  }\n\n  // Look for memories with high similarity but opposite outcomes\n  for (let i = 0; i < memories.length; i++) {\n    for (let j = i + 1; j < memories.length; j++) {\n      const mem1 = memories[i];\n      const mem2 = memories[j];\n\n      const emb1 = embeddingsMap.get(mem1.id);\n      const emb2 = embeddingsMap.get(mem2.id);\n\n      if (!emb1 || !emb2) continue;\n\n      const similarity = cosineSimilarity(emb1, emb2);\n\n      // High similarity but different outcomes = potential contradiction\n      if (similarity >= threshold) {\n        const outcome1 = mem1.pattern_data.source?.outcome;\n        const outcome2 = mem2.pattern_data.source?.outcome;\n\n        if (outcome1 !== outcome2) {\n          db.storeLink(mem1.id, mem2.id, 'contradicts', similarity);\n          contradictionsFound++;\n          console.log(`[WARN] Contradiction detected: ${mem1.pattern_data.title} vs ${mem2.pattern_data.title}`);\n        }\n      }\n    }\n  }\n\n  return contradictionsFound;\n}\n\n/**\n * Check if consolidation should run\n * Returns true if threshold of new memories is reached\n */\nexport function shouldConsolidate(): boolean {\n  const config = loadConfig();\n  const newCount = db.countNewMemoriesSinceConsolidation();\n  return newCount >= config.consolidate.trigger_threshold;\n}\n"]}