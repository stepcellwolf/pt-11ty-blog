{"version":3,"file":"queries.js","sourceRoot":"","sources":["../../../src/reasoningbank/db/queries.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Database queries for ReasoningBank\n * Operates on Claude Flow's memory.db at .swarm/memory.db\n */\n\nimport Database from 'better-sqlite3';\nimport { existsSync, mkdirSync } from 'fs';\nimport { join, dirname } from 'path';\nimport type { ReasoningMemory, PatternEmbedding, TaskTrajectory, MattsRun } from './schema.js';\n\n// Simple logger for database operations\nconst logger = {\n  info: (msg: string, data?: any) => console.log(`[INFO] ${msg}`, data || ''),\n  error: (msg: string, data?: any) => console.error(`[ERROR] ${msg}`, data || '')\n};\n\nlet dbInstance: Database.Database | null = null;\n\n/**\n * Run database migrations (create tables)\n */\nexport async function runMigrations(): Promise<void> {\n  const dbPath = process.env.CLAUDE_FLOW_DB_PATH || join(process.cwd(), '.swarm', 'memory.db');\n\n  // Create directory if it doesn't exist\n  const dbDir = dirname(dbPath);\n  if (!existsSync(dbDir)) {\n    mkdirSync(dbDir, { recursive: true });\n    logger.info('Created database directory', { path: dbDir });\n  }\n\n  // Create database file\n  const db = new Database(dbPath);\n  db.pragma('journal_mode = WAL');\n  db.pragma('foreign_keys = ON');\n\n  // Create tables\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS patterns (\n      id TEXT PRIMARY KEY,\n      type TEXT NOT NULL,\n      pattern_data TEXT NOT NULL,\n      confidence REAL NOT NULL DEFAULT 0.5,\n      usage_count INTEGER NOT NULL DEFAULT 0,\n      created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      last_used TEXT\n    );\n\n    CREATE TABLE IF NOT EXISTS pattern_embeddings (\n      id TEXT PRIMARY KEY,\n      model TEXT NOT NULL,\n      dims INTEGER NOT NULL,\n      vector BLOB NOT NULL,\n      created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      FOREIGN KEY (id) REFERENCES patterns(id) ON DELETE CASCADE\n    );\n\n    CREATE TABLE IF NOT EXISTS pattern_links (\n      src_id TEXT NOT NULL,\n      dst_id TEXT NOT NULL,\n      relation TEXT NOT NULL,\n      weight REAL NOT NULL DEFAULT 1.0,\n      created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      PRIMARY KEY (src_id, dst_id, relation),\n      FOREIGN KEY (src_id) REFERENCES patterns(id) ON DELETE CASCADE,\n      FOREIGN KEY (dst_id) REFERENCES patterns(id) ON DELETE CASCADE\n    );\n\n    CREATE TABLE IF NOT EXISTS task_trajectories (\n      task_id TEXT PRIMARY KEY,\n      agent_id TEXT NOT NULL,\n      query TEXT NOT NULL,\n      trajectory_json TEXT NOT NULL,\n      started_at TEXT,\n      ended_at TEXT,\n      judge_label TEXT,\n      judge_conf REAL,\n      judge_reasons TEXT,\n      matts_run_id TEXT,\n      created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n\n    CREATE TABLE IF NOT EXISTS matts_runs (\n      run_id TEXT PRIMARY KEY,\n      task_id TEXT NOT NULL,\n      mode TEXT NOT NULL,\n      k INTEGER NOT NULL,\n      status TEXT NOT NULL,\n      summary TEXT,\n      created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n\n    CREATE TABLE IF NOT EXISTS consolidation_runs (\n      run_id TEXT PRIMARY KEY,\n      items_processed INTEGER NOT NULL,\n      duplicates_found INTEGER NOT NULL,\n      contradictions_found INTEGER NOT NULL,\n      items_pruned INTEGER NOT NULL,\n      duration_ms INTEGER NOT NULL,\n      created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n\n    CREATE TABLE IF NOT EXISTS metrics_log (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      metric_name TEXT NOT NULL,\n      value REAL NOT NULL,\n      timestamp TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n\n    CREATE INDEX IF NOT EXISTS idx_patterns_type ON patterns(type);\n    CREATE INDEX IF NOT EXISTS idx_patterns_confidence ON patterns(confidence DESC);\n    CREATE INDEX IF NOT EXISTS idx_patterns_created_at ON patterns(created_at DESC);\n    CREATE INDEX IF NOT EXISTS idx_pattern_links_relation ON pattern_links(relation);\n    CREATE INDEX IF NOT EXISTS idx_trajectories_agent ON task_trajectories(agent_id);\n  `);\n\n  db.close();\n  dbInstance = null; // Reset instance to force reconnection\n\n  logger.info('Database migrations completed', { path: dbPath });\n}\n\n/**\n * Get database connection (singleton)\n */\nexport function getDb(): Database.Database {\n  if (dbInstance) return dbInstance;\n\n  const dbPath = process.env.CLAUDE_FLOW_DB_PATH || join(process.cwd(), '.swarm', 'memory.db');\n\n  if (!existsSync(dbPath)) {\n    throw new Error(`Database not found at ${dbPath}. Run migrations first.`);\n  }\n\n  dbInstance = new Database(dbPath);\n  dbInstance.pragma('journal_mode = WAL');\n  dbInstance.pragma('foreign_keys = ON');\n\n  logger.info('Connected to ReasoningBank database', { path: dbPath });\n\n  return dbInstance;\n}\n\n/**\n * Fetch reasoning memory candidates for retrieval\n */\nexport function fetchMemoryCandidates(options: {\n  domain?: string;\n  agent?: string;\n  minConfidence?: number;\n}): Array<ReasoningMemory & { embedding: Float32Array; age_days: number }> {\n  const db = getDb();\n\n  let query = `\n    SELECT\n      p.*,\n      pe.vector as embedding,\n      CAST((julianday('now') - julianday(p.created_at)) AS INTEGER) as age_days\n    FROM patterns p\n    JOIN pattern_embeddings pe ON p.id = pe.id\n    WHERE p.type = 'reasoning_memory'\n      AND p.confidence >= ?\n  `;\n\n  const params: any[] = [options.minConfidence || 0.3];\n\n  if (options.domain) {\n    query += ` AND json_extract(p.pattern_data, '$.domain') = ?`;\n    params.push(options.domain);\n  }\n\n  query += ` ORDER BY p.confidence DESC, p.usage_count DESC`;\n\n  const stmt = db.prepare(query);\n  const rows = stmt.all(...params) as any[];\n\n  return rows.map((row: any) => {\n    const buffer = Buffer.from((row as any).embedding);\n    // Create Float32Array from buffer - buffer length / 4 bytes per float\n    const float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length / 4);\n\n    return {\n      ...row,\n      pattern_data: JSON.parse((row as any).pattern_data),\n      embedding: float32Array\n    };\n  });\n}\n\n/**\n * Store a new reasoning memory\n */\nexport function upsertMemory(memory: Omit<ReasoningMemory, 'created_at' | 'last_used'>): string {\n  const db = getDb();\n\n  const stmt = db.prepare(`\n    INSERT OR REPLACE INTO patterns (id, type, pattern_data, confidence, usage_count, created_at)\n    VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `);\n\n  stmt.run(\n    memory.id,\n    memory.type,\n    JSON.stringify(memory.pattern_data),\n    memory.confidence,\n    memory.usage_count\n  );\n\n  logger.info('Upserted reasoning memory', { id: memory.id, title: memory.pattern_data.title });\n\n  return memory.id;\n}\n\n/**\n * Store embedding for a memory\n */\nexport function upsertEmbedding(embedding: PatternEmbedding): void {\n  const db = getDb();\n\n  const buffer = Buffer.from(embedding.vector.buffer);\n\n  const stmt = db.prepare(`\n    INSERT OR REPLACE INTO pattern_embeddings (id, model, dims, vector, created_at)\n    VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `);\n\n  stmt.run(embedding.id, embedding.model, embedding.dims, buffer);\n}\n\n/**\n * Increment usage count for a memory\n */\nexport function incrementUsage(memoryId: string): void {\n  const db = getDb();\n\n  db.prepare(`\n    UPDATE patterns\n    SET usage_count = usage_count + 1,\n        last_used = CURRENT_TIMESTAMP\n    WHERE id = ?\n  `).run(memoryId);\n}\n\n/**\n * Store task trajectory\n */\nexport function storeTrajectory(trajectory: Omit<TaskTrajectory, 'created_at'>): void {\n  const db = getDb();\n\n  db.prepare(`\n    INSERT OR REPLACE INTO task_trajectories\n    (task_id, agent_id, query, trajectory_json, started_at, ended_at,\n     judge_label, judge_conf, judge_reasons, matts_run_id, created_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `).run(\n    trajectory.task_id,\n    trajectory.agent_id,\n    trajectory.query,\n    trajectory.trajectory_json,\n    trajectory.started_at || null,\n    trajectory.ended_at || null,\n    trajectory.judge_label || null,\n    trajectory.judge_conf || null,\n    trajectory.judge_reasons || null,\n    trajectory.matts_run_id || null\n  );\n}\n\n/**\n * Store MaTTS run\n */\nexport function storeMattsRun(run: Omit<MattsRun, 'created_at'>): void {\n  const db = getDb();\n\n  db.prepare(`\n    INSERT INTO matts_runs (run_id, task_id, mode, k, status, summary, created_at)\n    VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `).run(run.run_id, run.task_id, run.mode, run.k, run.status, run.summary || null);\n}\n\n/**\n * Log performance metric\n */\nexport function logMetric(name: string, value: number): void {\n  try {\n    const db = getDb();\n\n    // Log to metrics_log table (our own table)\n    db.prepare(`\n      INSERT INTO metrics_log (metric_name, value, timestamp)\n      VALUES (?, ?, CURRENT_TIMESTAMP)\n    `).run(name, value);\n  } catch (error) {\n    // Silently fail if metrics table doesn't exist\n    // This is optional logging, not critical\n  }\n}\n\n/**\n * Count new memories since last consolidation\n */\nexport function countNewMemoriesSinceConsolidation(): number {\n  const db = getDb();\n\n  const lastRun = db.prepare(`\n    SELECT created_at\n    FROM consolidation_runs\n    ORDER BY created_at DESC\n    LIMIT 1\n  `).get() as { created_at: string } | undefined;\n\n  if (!lastRun) {\n    // No consolidation yet, count all memories\n    const result = db.prepare(`\n      SELECT COUNT(*) as count\n      FROM patterns\n      WHERE type = 'reasoning_memory'\n    `).get() as { count: number };\n    return result.count;\n  }\n\n  const result = db.prepare(`\n    SELECT COUNT(*) as count\n    FROM patterns\n    WHERE type = 'reasoning_memory'\n      AND created_at > ?\n  `).get(lastRun.created_at) as { count: number };\n\n  return result.count;\n}\n\n/**\n * Get all active reasoning memories\n */\nexport function getAllActiveMemories(): ReasoningMemory[] {\n  const db = getDb();\n\n  const rows = db.prepare(`\n    SELECT *\n    FROM patterns\n    WHERE type = 'reasoning_memory'\n      AND confidence >= 0.3\n    ORDER BY confidence DESC, usage_count DESC\n  `).all() as any[];\n\n  return rows.map((row: any) => ({\n    ...row,\n    pattern_data: JSON.parse((row as any).pattern_data)\n  }));\n}\n\n/**\n * Store memory link (relationship)\n */\nexport function storeLink(\n  srcId: string,\n  dstId: string,\n  relation: 'entails' | 'contradicts' | 'refines' | 'duplicate_of',\n  weight: number\n): void {\n  const db = getDb();\n\n  db.prepare(`\n    INSERT OR REPLACE INTO pattern_links (src_id, dst_id, relation, weight, created_at)\n    VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `).run(srcId, dstId, relation, weight);\n}\n\n/**\n * Get contradictions for a memory\n */\nexport function getContradictions(memoryId: string): string[] {\n  const db = getDb();\n\n  const rows = db.prepare(`\n    SELECT dst_id\n    FROM pattern_links\n    WHERE src_id = ? AND relation = 'contradicts'\n  `).all(memoryId) as { dst_id: string }[];\n\n  return rows.map(r => r.dst_id);\n}\n\n/**\n * Store consolidation run\n */\nexport function storeConsolidationRun(run: {\n  run_id: string;\n  items_processed: number;\n  duplicates_found: number;\n  contradictions_found: number;\n  items_pruned: number;\n  duration_ms: number;\n}): void {\n  const db = getDb();\n\n  db.prepare(`\n    INSERT INTO consolidation_runs\n    (run_id, items_processed, duplicates_found, contradictions_found, items_pruned, duration_ms, created_at)\n    VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n  `).run(\n    run.run_id,\n    run.items_processed,\n    run.duplicates_found,\n    run.contradictions_found,\n    run.items_pruned,\n    run.duration_ms\n  );\n}\n\n/**\n * Prune old, unused memories\n */\nexport function pruneOldMemories(options: {\n  maxAgeDays: number;\n  minConfidence: number;\n}): number {\n  const db = getDb();\n\n  const result = db.prepare(`\n    DELETE FROM patterns\n    WHERE type = 'reasoning_memory'\n      AND usage_count = 0\n      AND confidence < ?\n      AND CAST((julianday('now') - julianday(created_at)) AS INTEGER) > ?\n  `).run(options.minConfidence, options.maxAgeDays);\n\n  return result.changes;\n}\n\n/**\n * Close database connection\n */\nexport function closeDb(): void {\n  if (dbInstance) {\n    dbInstance.close();\n    dbInstance = null;\n    logger.info('Closed ReasoningBank database connection');\n  }\n}\n"]}