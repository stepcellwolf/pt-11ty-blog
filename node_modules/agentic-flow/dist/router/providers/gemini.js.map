{"version":3,"file":"gemini.js","sourceRoot":"","sources":["../../../src/router/providers/gemini.ts"],"names":[],"mappings":"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","sourcesContent":["// Google Gemini provider implementation\nimport { GoogleGenAI } from '@google/genai';\nimport {\n  LLMProvider,\n  ChatParams,\n  ChatResponse,\n  StreamChunk,\n  ProviderConfig,\n  ProviderError,\n  ContentBlock\n} from '../types.js';\n\nexport class GeminiProvider implements LLMProvider {\n  name = 'gemini';\n  type = 'gemini' as const;\n  supportsStreaming = true;\n  supportsTools = false;\n  supportsMCP = false;\n\n  private client: GoogleGenAI;\n  private config: ProviderConfig;\n\n  constructor(config: ProviderConfig) {\n    this.config = config;\n\n    if (!config.apiKey) {\n      throw new Error('Google Gemini API key is required');\n    }\n\n    this.client = new GoogleGenAI({ apiKey: config.apiKey });\n  }\n\n  validateCapabilities(features: string[]): boolean {\n    const supported = ['chat', 'streaming'];\n    return features.every(f => supported.includes(f));\n  }\n\n  async chat(params: ChatParams): Promise<ChatResponse> {\n    try {\n      // Convert messages to Gemini format\n      const contents = params.messages.map(msg => ({\n        role: msg.role === 'assistant' ? 'model' : 'user',\n        parts: [{ text: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content) }]\n      }));\n\n      const response = await this.client.models.generateContent({\n        model: params.model || 'gemini-2.0-flash-exp',\n        contents,\n        config: {\n          temperature: params.temperature,\n          maxOutputTokens: params.maxTokens || 8192\n        }\n      });\n\n      const text = response.text || '';\n\n      return {\n        id: crypto.randomUUID(),\n        model: params.model || 'gemini-2.0-flash-exp',\n        content: [{ type: 'text', text }] as ContentBlock[],\n        stopReason: 'end_turn',\n        usage: {\n          inputTokens: response.usageMetadata?.promptTokenCount || 0,\n          outputTokens: response.usageMetadata?.candidatesTokenCount || 0\n        },\n        metadata: {\n          provider: 'gemini',\n          cost: this.calculateCost(response.usageMetadata || {}),\n          latency: 0\n        }\n      };\n    } catch (error: any) {\n      throw this.handleError(error);\n    }\n  }\n\n  async *stream(params: ChatParams): AsyncGenerator<StreamChunk> {\n    try {\n      const contents = params.messages.map(msg => ({\n        role: msg.role === 'assistant' ? 'model' : 'user',\n        parts: [{ text: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content) }]\n      }));\n\n      const stream = await this.client.models.generateContentStream({\n        model: params.model || 'gemini-2.0-flash-exp',\n        contents,\n        config: {\n          temperature: params.temperature,\n          maxOutputTokens: params.maxTokens || 8192\n        }\n      });\n\n      for await (const chunk of stream) {\n        const text = chunk.text || '';\n        if (text) {\n          yield {\n            type: 'content_block_delta',\n            delta: { type: 'text_delta', text }\n          } as StreamChunk;\n        }\n      }\n    } catch (error: any) {\n      throw this.handleError(error);\n    }\n  }\n\n  private calculateCost(usage: any): number {\n    // Gemini pricing varies by model\n    const inputTokens = usage.promptTokenCount || 0;\n    const outputTokens = usage.candidatesTokenCount || 0;\n\n    // Flash pricing: Free tier or low cost\n    const inputCost = (inputTokens / 1_000_000) * 0.075;\n    const outputCost = (outputTokens / 1_000_000) * 0.3;\n    return inputCost + outputCost;\n  }\n\n  private handleError(error: any): ProviderError {\n    const providerError = new Error(\n      error.message || 'Gemini request failed'\n    ) as ProviderError;\n\n    providerError.provider = 'gemini';\n    providerError.statusCode = error.status || 500;\n    providerError.retryable = error.status >= 500 || error.status === 429;\n\n    return providerError;\n  }\n}\n"]}