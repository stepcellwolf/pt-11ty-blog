{"version":3,"file":"retry.js","sourceRoot":"","sources":["../../src/utils/retry.ts"],"names":[],"mappings":"AAAA,yCAAyC;AACzC,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AASrC,MAAM,cAAc,GAA2B;IAC7C,WAAW,EAAE,CAAC;IACd,SAAS,EAAE,IAAI;IACf,QAAQ,EAAE,KAAK;IACf,WAAW,EAAE,CAAC,KAAU,EAAE,EAAE;QAC1B,0DAA0D;QAC1D,IAAI,KAAK,EAAE,MAAM,IAAI,GAAG;YAAE,OAAO,IAAI,CAAC;QACtC,IAAI,KAAK,EAAE,MAAM,KAAK,GAAG;YAAE,OAAO,IAAI,CAAC;QACvC,IAAI,KAAK,EAAE,IAAI,KAAK,YAAY;YAAE,OAAO,IAAI,CAAC;QAC9C,IAAI,KAAK,EAAE,IAAI,KAAK,WAAW;YAAE,OAAO,IAAI,CAAC;QAC7C,OAAO,KAAK,CAAC;IACf,CAAC;CACF,CAAC;AAEF,MAAM,CAAC,KAAK,UAAU,SAAS,CAC7B,EAAoB,EACpB,UAAwB,EAAE;IAE1B,MAAM,IAAI,GAAG,EAAE,GAAG,cAAc,EAAE,GAAG,OAAO,EAAE,CAAC;IAC/C,IAAI,SAAkB,CAAC;IAEvB,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,IAAI,IAAI,CAAC,WAAW,EAAE,OAAO,EAAE,EAAE,CAAC;QAC7D,IAAI,CAAC;YACH,MAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;YACjF,OAAO,MAAM,EAAE,EAAE,CAAC;QACpB,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,SAAS,GAAG,KAAK,CAAC;YAElB,IAAI,OAAO,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;gBAChC,MAAM,CAAC,KAAK,CAAC,4BAA4B,EAAE;oBACzC,OAAO;oBACP,WAAW,EAAE,IAAI,CAAC,WAAW;oBAC7B,KAAK;iBACN,CAAC,CAAC;gBACH,MAAM,KAAK,CAAC;YACd,CAAC;YAED,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC7B,MAAM,CAAC,IAAI,CAAC,qBAAqB,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;gBAC9C,MAAM,KAAK,CAAC;YACd,CAAC;YAED,sCAAsC;YACtC,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CACpB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,EAChE,IAAI,CAAC,QAAQ,CACd,CAAC;YAEF,MAAM,CAAC,IAAI,CAAC,4BAA4B,EAAE;gBACxC,OAAO;gBACP,WAAW,EAAE,OAAO,GAAG,CAAC;gBACxB,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;gBAC1B,KAAK;aACN,CAAC,CAAC;YAEH,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAC3D,CAAC;IACH,CAAC;IAED,MAAM,SAAS,CAAC;AAClB,CAAC","sourcesContent":["// Retry utility with exponential backoff\nimport { logger } from './logger.js';\n\ninterface RetryOptions {\n  maxAttempts?: number;\n  baseDelay?: number;\n  maxDelay?: number;\n  shouldRetry?: (error: any) => boolean;\n}\n\nconst defaultOptions: Required<RetryOptions> = {\n  maxAttempts: 3,\n  baseDelay: 1000,\n  maxDelay: 10000,\n  shouldRetry: (error: any) => {\n    // Retry on network errors, rate limits, and server errors\n    if (error?.status >= 500) return true;\n    if (error?.status === 429) return true;\n    if (error?.code === 'ECONNRESET') return true;\n    if (error?.code === 'ETIMEDOUT') return true;\n    return false;\n  }\n};\n\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const opts = { ...defaultOptions, ...options };\n  let lastError: unknown;\n\n  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {\n    try {\n      logger.debug('Attempting operation', { attempt, maxAttempts: opts.maxAttempts });\n      return await fn();\n    } catch (error: unknown) {\n      lastError = error;\n\n      if (attempt >= opts.maxAttempts) {\n        logger.error('Max retry attempts reached', {\n          attempt,\n          maxAttempts: opts.maxAttempts,\n          error\n        });\n        throw error;\n      }\n\n      if (!opts.shouldRetry(error)) {\n        logger.warn('Error not retryable', { error });\n        throw error;\n      }\n\n      // Calculate backoff delay with jitter\n      const delay = Math.min(\n        opts.baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000,\n        opts.maxDelay\n      );\n\n      logger.warn('Operation failed, retrying', {\n        attempt,\n        nextAttempt: attempt + 1,\n        delayMs: Math.round(delay),\n        error\n      });\n\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n"]}