{"version":3,"file":"swarm-learning-optimizer.js","sourceRoot":"","sources":["../../src/hooks/swarm-learning-optimizer.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAsCH,MAAM,OAAO,sBAAsB;IACzB,aAAa,CAAgB;IACpB,SAAS,GAAG,oBAAoB,CAAC;IAElD,YAAY,aAA4B;QACtC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IACrC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,qBAAqB,CACzB,eAAuB,EACvB,OAAqB,EACrB,OAAgB;QAEhB,MAAM,SAAS,GAAG,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;QAExE,MAAM,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC;YACpC,SAAS;YACT,IAAI,EAAE,eAAe;YACrB,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,cAAc,EAAE,OAAO,CAAC,cAAc,EAAE,UAAU,EAAE,OAAO,CAAC,UAAU,EAAE,CAAC;YACjG,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;YAC/B,MAAM,EAAE,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,OAAO,CAAC;YAC9C,OAAO;YACP,SAAS,EAAE,OAAO,CAAC,WAAW;YAC9B,UAAU,EAAE,CAAC,EAAE,oCAAoC;YACnD,QAAQ,EAAE,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC;SAClD,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,eAAe,CAAC,OAAqB,EAAE,OAAgB;QAC7D,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,CAAC;QAEzB,IAAI,MAAM,GAAG,GAAG,CAAC,CAAC,0BAA0B;QAE5C,sCAAsC;QACtC,IAAI,OAAO,CAAC,WAAW,IAAI,EAAE,EAAE,CAAC;YAC9B,MAAM,IAAI,GAAG,CAAC;QAChB,CAAC;aAAM,IAAI,OAAO,CAAC,WAAW,IAAI,EAAE,EAAE,CAAC;YACrC,MAAM,IAAI,GAAG,CAAC;QAChB,CAAC;QAED,4BAA4B;QAC5B,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;YACpB,IAAI,OAAO,CAAC,OAAO,IAAI,GAAG,EAAE,CAAC;gBAC3B,MAAM,IAAI,GAAG,CAAC;YAChB,CAAC;iBAAM,IAAI,OAAO,CAAC,OAAO,IAAI,GAAG,EAAE,CAAC;gBAClC,MAAM,IAAI,IAAI,CAAC;YACjB,CAAC;iBAAM,IAAI,OAAO,CAAC,OAAO,IAAI,GAAG,EAAE,CAAC;gBAClC,MAAM,IAAI,GAAG,CAAC;YAChB,CAAC;QACH,CAAC;QAED,iDAAiD;QACjD,MAAM,YAAY,GAAG,CAAC,OAAO,CAAC,UAAU,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;QACvE,IAAI,YAAY,GAAG,GAAG,EAAE,CAAC;YACvB,MAAM,IAAI,GAAG,CAAC;QAChB,CAAC;QAED,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IAC/B,CAAC;IAED;;OAEG;IACK,gBAAgB,CAAC,OAAqB,EAAE,OAAgB;QAC9D,MAAM,SAAS,GAAa,EAAE,CAAC;QAE/B,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,SAAS,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;QACxE,CAAC;QAED,IAAI,OAAO,CAAC,WAAW,GAAG,EAAE,EAAE,CAAC;YAC7B,SAAS,CAAC,IAAI,CAAC,qBAAqB,OAAO,CAAC,WAAW,+BAA+B,CAAC,CAAC;QAC1F,CAAC;QAED,IAAI,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,GAAG,GAAG,EAAE,CAAC;YAC7C,SAAS,CAAC,IAAI,CAAC,oBAAoB,OAAO,CAAC,OAAO,oDAAoD,CAAC,CAAC;QAC1G,CAAC;QAED,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,EAAE,CAAC;YAC1B,SAAS,CAAC,IAAI,CAAC,gEAAgE,CAAC,CAAC;QACnF,CAAC;QAED,IAAI,OAAO,CAAC,QAAQ,KAAK,MAAM,IAAI,OAAO,CAAC,UAAU,GAAG,EAAE,EAAE,CAAC;YAC3D,SAAS,CAAC,IAAI,CAAC,6EAA6E,CAAC,CAAC;QAChG,CAAC;QAED,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC3B,IAAI,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,IAAI,GAAG,EAAE,CAAC;gBAC9C,OAAO,sDAAsD,CAAC;YAChE,CAAC;YACD,OAAO,2CAA2C,CAAC;QACrD,CAAC;QAED,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,eAAe,CACnB,eAAuB,EACvB,cAAsD,EACtD,mBAA2B;QAE3B,yCAAyC;QACzC,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,eAAe,EAAE;YAC/E,CAAC,EAAE,EAAE;YACL,SAAS,EAAE,GAAG;YACd,aAAa,EAAE,IAAI;SACpB,CAAC,CAAC;QAEH,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjC,uDAAuD;YACvD,OAAO,IAAI,CAAC,wBAAwB,CAAC,cAAc,EAAE,mBAAmB,CAAC,CAAC;QAC5E,CAAC;QAED,iDAAiD;QACjD,MAAM,cAAc,GAAG,IAAI,GAAG,EAAsE,CAAC;QAErG,KAAK,MAAM,OAAO,IAAI,eAAe,EAAE,CAAC;YACtC,IAAI,CAAC;gBACH,MAAM,OAAO,GAAiB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBACzD,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAElC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAClC,cAAc,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC;gBAC5E,CAAC;gBAED,MAAM,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC;gBAC5C,KAAK,CAAC,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC;gBACpC,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;gBACjB,KAAK,CAAC,UAAU,IAAI,OAAO,CAAC,OAAO,IAAI,GAAG,CAAC;YAC7C,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACX,4BAA4B;gBAC5B,SAAS;YACX,CAAC;QACH,CAAC;QAED,yDAAyD;QACzD,IAAI,YAAY,GAAG,cAAc,CAAC;QAClC,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,WAAW,GAAG,GAAG,CAAC;QACtB,MAAM,YAAY,GAAuE,EAAE,CAAC;QAE5F,KAAK,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,cAAc,CAAC,OAAO,EAAE,EAAE,CAAC;YACxD,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC;YAChD,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC;YAChD,MAAM,KAAK,GAAG,SAAS,GAAG,GAAG,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,iBAAiB;YAE3E,IAAI,KAAK,GAAG,SAAS,EAAE,CAAC;gBACtB,IAAI,SAAS,GAAG,CAAC,EAAE,CAAC;oBAClB,oCAAoC;oBACpC,YAAY,CAAC,IAAI,CAAC;wBAChB,QAAQ,EAAE,YAAY;wBACtB,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,GAAG,GAAG;wBAC7C,SAAS,EAAE,oBAAoB,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,UAAU,cAAc,CAAC,GAAG,CAAC,YAAY,CAAE,CAAC,KAAK,aAAa;qBACpH,CAAC,CAAC;gBACL,CAAC;gBACD,SAAS,GAAG,KAAK,CAAC;gBAClB,YAAY,GAAG,QAAQ,CAAC;gBACxB,WAAW,GAAG,UAAU,CAAC;YAC3B,CAAC;iBAAM,CAAC;gBACN,YAAY,CAAC,IAAI,CAAC;oBAChB,QAAQ;oBACR,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,GAAG;oBACzC,SAAS,EAAE,oBAAoB,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,UAAU,IAAI,CAAC,KAAK,aAAa;iBACtF,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED,6EAA6E;QAC7E,MAAM,gBAAgB,GAAG,IAAI,CAAC,yBAAyB,CAAC,cAAc,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;QAE9G,OAAO;YACL,mBAAmB,EAAE,YAAmB;YACxC,oBAAoB,EAAE,gBAAgB;YACtC,qBAAqB,EAAE,IAAI,CAAC,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,CAAC;YAChG,eAAe,EAAE,WAAW;YAC5B,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,GAAG,GAAG;YAC7C,SAAS,EAAE,YAAY,eAAe,CAAC,MAAM,kCAAkC;gBACrE,GAAG,YAAY,sBAAsB,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB;YACzF,YAAY,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;SACnF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,wBAAwB,CAC9B,cAAsD,EACtD,mBAA2B;QAE3B,iEAAiE;QACjE,IAAI,QAAmD,CAAC;QACxD,IAAI,eAAuB,CAAC;QAC5B,IAAI,SAAiB,CAAC;QAEtB,IAAI,mBAAmB,IAAI,CAAC,EAAE,CAAC;YAC7B,QAAQ,GAAG,MAAM,CAAC;YAClB,eAAe,GAAG,GAAG,CAAC;YACtB,SAAS,GAAG,qFAAqF,CAAC;QACpG,CAAC;aAAM,IAAI,mBAAmB,IAAI,EAAE,EAAE,CAAC;YACrC,QAAQ,GAAG,cAAc,CAAC;YAC1B,eAAe,GAAG,GAAG,CAAC;YACtB,SAAS,GAAG,sFAAsF,CAAC;QACrG,CAAC;aAAM,CAAC;YACN,QAAQ,GAAG,cAAc,CAAC;YAC1B,eAAe,GAAG,GAAG,CAAC;YACtB,SAAS,GAAG,mGAAmG,CAAC;QAClH,CAAC;QAED,6BAA6B;QAC7B,IAAI,cAAc,KAAK,UAAU,IAAI,cAAc,KAAK,MAAM,EAAE,CAAC;YAC/D,eAAe,IAAI,GAAG,CAAC,CAAC,uDAAuD;QACjF,CAAC;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,CAAC,cAAc,EAAE,mBAAmB,EAAE,EAAE,CAAC,CAAC;QAE1F,OAAO;YACL,mBAAmB,EAAE,QAAQ;YAC7B,oBAAoB,EAAE,SAAS;YAC/B,qBAAqB,EAAE,IAAI,CAAC,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;YAC5F,eAAe;YACf,UAAU,EAAE,GAAG,EAAE,4CAA4C;YAC7D,SAAS,EAAE,GAAG,SAAS,qDAAqD;YAC5E,YAAY,EAAE;gBACZ;oBACE,QAAQ,EAAE,QAAQ,KAAK,MAAM,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,MAAM;oBACvD,UAAU,EAAE,GAAG;oBACf,SAAS,EAAE,uDAAuD;iBACnE;aACF;SACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,yBAAyB,CAC/B,cAAsD,EACtD,mBAA2B,EAC3B,eAAsB;QAEtB,kDAAkD;QAClD,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC/B,MAAM,UAAU,GAAG,eAAe;iBAC/B,GAAG,CAAC,CAAC,CAAC,EAAE;gBACP,IAAI,CAAC;oBACH,MAAM,OAAO,GAAiB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;oBACnD,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC;gBAC5D,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACX,OAAO,IAAI,CAAC;gBACd,CAAC;YACH,CAAC,CAAC;iBACD,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAiD,CAAC;YAE3E,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC1B,8CAA8C;gBAC9C,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAkD,CAAC;gBAC3E,KAAK,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,IAAI,UAAU,EAAE,CAAC;oBAC/C,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;wBAC7B,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,WAAW,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;oBACxD,CAAC;oBACD,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC;oBACvC,KAAK,CAAC,WAAW,IAAI,MAAM,CAAC;oBAC5B,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;gBACnB,CAAC;gBAED,IAAI,aAAa,GAAG,CAAC,CAAC;gBACtB,IAAI,aAAa,GAAG,CAAC,CAAC;gBACtB,KAAK,MAAM,CAAC,SAAS,EAAE,EAAE,WAAW,EAAE,KAAK,EAAE,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;oBACrE,MAAM,SAAS,GAAG,WAAW,GAAG,KAAK,CAAC;oBACtC,IAAI,SAAS,GAAG,aAAa,EAAE,CAAC;wBAC9B,aAAa,GAAG,SAAS,CAAC;wBAC1B,aAAa,GAAG,SAAS,CAAC;oBAC5B,CAAC;gBACH,CAAC;gBAED,OAAO,aAAa,CAAC;YACvB,CAAC;QACH,CAAC;QAED,yCAAyC;QACzC,QAAQ,cAAc,EAAE,CAAC;YACvB,KAAK,KAAK;gBACR,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,mBAAmB,CAAC,CAAC;YAC1C,KAAK,QAAQ;gBACX,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,mBAAmB,CAAC,CAAC;YAC1C,KAAK,MAAM;gBACT,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,mBAAmB,CAAC,CAAC;YAC1C,KAAK,UAAU;gBACb,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,mBAAmB,CAAC,CAAC;QAC7C,CAAC;IACH,CAAC;IAED;;OAEG;IACK,uBAAuB,CAAC,QAAgB;QAC9C,QAAQ,QAAQ,EAAE,CAAC;YACjB,KAAK,MAAM;gBACT,OAAO,EAAE,CAAC,CAAC,0CAA0C;YACvD,KAAK,cAAc;gBACjB,OAAO,EAAE,CAAC,CAAC,8BAA8B;YAC3C,KAAK,MAAM;gBACT,OAAO,EAAE,CAAC,CAAC,wCAAwC;YACrD,KAAK,MAAM;gBACT,OAAO,EAAE,CAAC,CAAC,iCAAiC;YAC9C;gBACE,OAAO,EAAE,CAAC;QACd,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,oBAAoB;QAOxB,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE;YAC1E,CAAC,EAAE,IAAI;YACP,aAAa,EAAE,IAAI;SACpB,CAAC,CAAC;QAEH,MAAM,KAAK,GAAG;YACZ,aAAa,EAAE,WAAW,CAAC,MAAM;YACjC,cAAc,EAAE,EAA4B;YAC5C,iBAAiB,EAAE,EAA8B;YACjD,YAAY,EAAE,EAAc;YAC5B,oBAAoB,EAAE,EAA4B;YAClD,cAAc,EAAE,CAAC;YACjB,sBAAsB,EAAE,cAAc;SACvC,CAAC;QAEF,KAAK,MAAM,OAAO,IAAI,WAAW,EAAE,CAAC;YAClC,IAAI,CAAC;gBACH,MAAM,OAAO,GAAiB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBAEzD,uBAAuB;gBACvB,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;gBAE3F,gBAAgB;gBAChB,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAC/C,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;gBACjD,CAAC;gBACD,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;oBACpB,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBAClE,CAAC;gBAED,qBAAqB;gBACrB,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YAC/C,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACX,SAAS;YACX,CAAC;QACH,CAAC;QAED,qBAAqB;QACrB,KAAK,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAC,EAAE,CAAC;YAC3E,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACxB,KAAK,CAAC,oBAAoB,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC;YAC/F,CAAC;QACH,CAAC;QAED,KAAK,CAAC,cAAc,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;YAClD,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM;YAC3E,CAAC,CAAC,CAAC,CAAC;QAEN,gCAAgC;QAChC,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,KAAK,MAAM,CAAC,QAAQ,EAAE,UAAU,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,oBAAoB,CAAC,EAAE,CAAC;YAChF,IAAI,UAAU,GAAG,WAAW,EAAE,CAAC;gBAC7B,WAAW,GAAG,UAAU,CAAC;gBACzB,KAAK,CAAC,sBAAsB,GAAG,QAAQ,CAAC;YAC1C,CAAC;QACH,CAAC;QAED,OAAO;YACL,aAAa,EAAE,KAAK,CAAC,aAAa;YAClC,cAAc,EAAE,KAAK,CAAC,cAAc;YACpC,oBAAoB,EAAE,KAAK,CAAC,oBAAoB;YAChD,cAAc,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC,GAAG,EAAE;YAC1D,sBAAsB,EAAE,KAAK,CAAC,sBAAsB;SACrD,CAAC;IACJ,CAAC;CACF;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,qBAAqB,CACzC,aAA4B,EAC5B,eAAuB,EACvB,UAGI,EAAE;IAEN,MAAM,SAAS,GAAG,IAAI,sBAAsB,CAAC,aAAa,CAAC,CAAC;IAE5D,MAAM,UAAU,GAAG,OAAO,CAAC,cAAc,IAAI,QAAQ,CAAC;IACtD,MAAM,UAAU,GAAG,OAAO,CAAC,mBAAmB,IAAI,CAAC,CAAC;IAEpD,OAAO,MAAM,SAAS,CAAC,eAAe,CAAC,eAAe,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;AAClF,CAAC","sourcesContent":["/**\n * Swarm Learning Optimizer\n *\n * Enhances parallel execution with adaptive learning, pattern recognition,\n * and automated topology selection using ReasoningBank intelligence.\n */\n\nimport { ReasoningBank } from '../reasoningbank';\n\nexport interface SwarmMetrics {\n  topology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n  agentCount: number;\n  batchSize: number;\n  totalTimeMs: number;\n  successRate: number;\n  speedup?: number;\n  taskComplexity: 'low' | 'medium' | 'high' | 'critical';\n  operations: number;\n}\n\nexport interface LearningPattern {\n  taskType: string;\n  optimalTopology: string;\n  optimalBatchSize: number;\n  expectedSpeedup: number;\n  successRate: number;\n  timestamp: string;\n}\n\nexport interface OptimizationRecommendation {\n  recommendedTopology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n  recommendedBatchSize: number;\n  recommendedAgentCount: number;\n  expectedSpeedup: number;\n  confidence: number;\n  reasoning: string;\n  alternatives: Array<{\n    topology: string;\n    confidence: number;\n    reasoning: string;\n  }>;\n}\n\nexport class SwarmLearningOptimizer {\n  private reasoningBank: ReasoningBank;\n  private readonly NAMESPACE = 'swarm/optimization';\n\n  constructor(reasoningBank: ReasoningBank) {\n    this.reasoningBank = reasoningBank;\n  }\n\n  /**\n   * Store swarm execution metrics for learning\n   */\n  async storeExecutionPattern(\n    taskDescription: string,\n    metrics: SwarmMetrics,\n    success: boolean\n  ): Promise<void> {\n    const sessionId = `${this.NAMESPACE}/${metrics.topology}/${Date.now()}`;\n\n    await this.reasoningBank.storePattern({\n      sessionId,\n      task: taskDescription,\n      input: JSON.stringify({ taskComplexity: metrics.taskComplexity, agentCount: metrics.agentCount }),\n      output: JSON.stringify(metrics),\n      reward: this.calculateReward(metrics, success),\n      success,\n      latencyMs: metrics.totalTimeMs,\n      tokensUsed: 0, // Not tracking tokens for swarm ops\n      critique: this.generateCritique(metrics, success)\n    });\n  }\n\n  /**\n   * Calculate reward score for swarm execution (0-1)\n   */\n  private calculateReward(metrics: SwarmMetrics, success: boolean): number {\n    if (!success) return 0.0;\n\n    let reward = 0.5; // Base reward for success\n\n    // Reward for high success rate (+0.2)\n    if (metrics.successRate >= 90) {\n      reward += 0.2;\n    } else if (metrics.successRate >= 75) {\n      reward += 0.1;\n    }\n\n    // Reward for speedup (+0.2)\n    if (metrics.speedup) {\n      if (metrics.speedup >= 3.0) {\n        reward += 0.2;\n      } else if (metrics.speedup >= 2.0) {\n        reward += 0.15;\n      } else if (metrics.speedup >= 1.5) {\n        reward += 0.1;\n      }\n    }\n\n    // Reward for efficiency (operations/time) (+0.1)\n    const opsPerSecond = (metrics.operations / metrics.totalTimeMs) * 1000;\n    if (opsPerSecond > 0.1) {\n      reward += 0.1;\n    }\n\n    return Math.min(1.0, reward);\n  }\n\n  /**\n   * Generate critique for learning\n   */\n  private generateCritique(metrics: SwarmMetrics, success: boolean): string {\n    const critiques: string[] = [];\n\n    if (!success) {\n      critiques.push('Swarm execution failed - investigate error handling');\n    }\n\n    if (metrics.successRate < 80) {\n      critiques.push(`Low success rate (${metrics.successRate}%) - review agent reliability`);\n    }\n\n    if (metrics.speedup && metrics.speedup < 1.2) {\n      critiques.push(`Minimal speedup (${metrics.speedup}x) - consider different topology or larger batches`);\n    }\n\n    if (metrics.batchSize < 3) {\n      critiques.push('Small batch size - may not fully utilize parallel capabilities');\n    }\n\n    if (metrics.topology === 'mesh' && metrics.agentCount > 10) {\n      critiques.push('Mesh topology with many agents (O(n²) coordination) - consider hierarchical');\n    }\n\n    if (critiques.length === 0) {\n      if (metrics.speedup && metrics.speedup >= 3.0) {\n        return 'Excellent parallel execution - pattern worth reusing';\n      }\n      return 'Good swarm execution - successful pattern';\n    }\n\n    return critiques.join('. ');\n  }\n\n  /**\n   * Get optimization recommendations based on learned patterns\n   */\n  async getOptimization(\n    taskDescription: string,\n    taskComplexity: 'low' | 'medium' | 'high' | 'critical',\n    estimatedAgentCount: number\n  ): Promise<OptimizationRecommendation> {\n    // Search for similar successful patterns\n    const similarPatterns = await this.reasoningBank.searchPatterns(taskDescription, {\n      k: 10,\n      minReward: 0.7,\n      onlySuccesses: true\n    });\n\n    if (similarPatterns.length === 0) {\n      // No learned patterns - return default recommendations\n      return this.getDefaultRecommendation(taskComplexity, estimatedAgentCount);\n    }\n\n    // Analyze patterns to find optimal configuration\n    const topologyScores = new Map<string, { totalReward: number; count: number; avgSpeedup: number }>();\n\n    for (const pattern of similarPatterns) {\n      try {\n        const metrics: SwarmMetrics = JSON.parse(pattern.output);\n        const topology = metrics.topology;\n\n        if (!topologyScores.has(topology)) {\n          topologyScores.set(topology, { totalReward: 0, count: 0, avgSpeedup: 0 });\n        }\n\n        const score = topologyScores.get(topology)!;\n        score.totalReward += pattern.reward;\n        score.count += 1;\n        score.avgSpeedup += metrics.speedup || 1.0;\n      } catch (e) {\n        // Skip invalid pattern data\n        continue;\n      }\n    }\n\n    // Find best topology based on average reward and speedup\n    let bestTopology = 'hierarchical';\n    let bestScore = 0;\n    let bestSpeedup = 1.0;\n    const alternatives: Array<{ topology: string; confidence: number; reasoning: string }> = [];\n\n    for (const [topology, data] of topologyScores.entries()) {\n      const avgReward = data.totalReward / data.count;\n      const avgSpeedup = data.avgSpeedup / data.count;\n      const score = avgReward * 0.6 + (avgSpeedup / 5.0) * 0.4; // Weighted score\n\n      if (score > bestScore) {\n        if (bestScore > 0) {\n          // Previous best becomes alternative\n          alternatives.push({\n            topology: bestTopology,\n            confidence: Math.round(bestScore * 100) / 100,\n            reasoning: `Average speedup: ${bestSpeedup.toFixed(2)}x from ${topologyScores.get(bestTopology)!.count} executions`\n          });\n        }\n        bestScore = score;\n        bestTopology = topology;\n        bestSpeedup = avgSpeedup;\n      } else {\n        alternatives.push({\n          topology,\n          confidence: Math.round(score * 100) / 100,\n          reasoning: `Average speedup: ${avgSpeedup.toFixed(2)}x from ${data.count} executions`\n        });\n      }\n    }\n\n    // Determine optimal batch size based on task complexity and learned patterns\n    const optimalBatchSize = this.determineOptimalBatchSize(taskComplexity, estimatedAgentCount, similarPatterns);\n\n    return {\n      recommendedTopology: bestTopology as any,\n      recommendedBatchSize: optimalBatchSize,\n      recommendedAgentCount: Math.min(estimatedAgentCount, this.getMaxAgentsForTopology(bestTopology)),\n      expectedSpeedup: bestSpeedup,\n      confidence: Math.round(bestScore * 100) / 100,\n      reasoning: `Based on ${similarPatterns.length} similar successful executions. ` +\n                `${bestTopology} topology achieved ${bestSpeedup.toFixed(2)}x average speedup.`,\n      alternatives: alternatives.sort((a, b) => b.confidence - a.confidence).slice(0, 2)\n    };\n  }\n\n  /**\n   * Get default recommendations when no learned patterns exist\n   */\n  private getDefaultRecommendation(\n    taskComplexity: 'low' | 'medium' | 'high' | 'critical',\n    estimatedAgentCount: number\n  ): OptimizationRecommendation {\n    // Default topology selection based on agent count and complexity\n    let topology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n    let expectedSpeedup: number;\n    let reasoning: string;\n\n    if (estimatedAgentCount <= 5) {\n      topology = 'mesh';\n      expectedSpeedup = 2.5;\n      reasoning = 'Mesh topology optimal for small swarms (≤5 agents) - full peer-to-peer coordination';\n    } else if (estimatedAgentCount <= 10) {\n      topology = 'hierarchical';\n      expectedSpeedup = 3.5;\n      reasoning = 'Hierarchical topology optimal for medium swarms (6-10 agents) - efficient delegation';\n    } else {\n      topology = 'hierarchical';\n      expectedSpeedup = 4.0;\n      reasoning = 'Hierarchical topology required for large swarms (>10 agents) - avoids O(n²) coordination overhead';\n    }\n\n    // Adjust for task complexity\n    if (taskComplexity === 'critical' || taskComplexity === 'high') {\n      expectedSpeedup *= 1.2; // Higher complexity benefits more from parallelization\n    }\n\n    const batchSize = this.determineOptimalBatchSize(taskComplexity, estimatedAgentCount, []);\n\n    return {\n      recommendedTopology: topology,\n      recommendedBatchSize: batchSize,\n      recommendedAgentCount: Math.min(estimatedAgentCount, this.getMaxAgentsForTopology(topology)),\n      expectedSpeedup,\n      confidence: 0.6, // Lower confidence without learned patterns\n      reasoning: `${reasoning} (default recommendation - no learned patterns yet)`,\n      alternatives: [\n        {\n          topology: topology === 'mesh' ? 'hierarchical' : 'mesh',\n          confidence: 0.5,\n          reasoning: 'Alternative topology if default does not perform well'\n        }\n      ]\n    };\n  }\n\n  /**\n   * Determine optimal batch size based on complexity and learned patterns\n   */\n  private determineOptimalBatchSize(\n    taskComplexity: 'low' | 'medium' | 'high' | 'critical',\n    estimatedAgentCount: number,\n    learnedPatterns: any[]\n  ): number {\n    // Analyze learned patterns for optimal batch size\n    if (learnedPatterns.length > 0) {\n      const batchSizes = learnedPatterns\n        .map(p => {\n          try {\n            const metrics: SwarmMetrics = JSON.parse(p.output);\n            return { batchSize: metrics.batchSize, reward: p.reward };\n          } catch (e) {\n            return null;\n          }\n        })\n        .filter(x => x !== null) as Array<{ batchSize: number; reward: number }>;\n\n      if (batchSizes.length > 0) {\n        // Find batch size with highest average reward\n        const batchMap = new Map<number, { totalReward: number; count: number }>();\n        for (const { batchSize, reward } of batchSizes) {\n          if (!batchMap.has(batchSize)) {\n            batchMap.set(batchSize, { totalReward: 0, count: 0 });\n          }\n          const entry = batchMap.get(batchSize)!;\n          entry.totalReward += reward;\n          entry.count += 1;\n        }\n\n        let bestBatchSize = 3;\n        let bestAvgReward = 0;\n        for (const [batchSize, { totalReward, count }] of batchMap.entries()) {\n          const avgReward = totalReward / count;\n          if (avgReward > bestAvgReward) {\n            bestAvgReward = avgReward;\n            bestBatchSize = batchSize;\n          }\n        }\n\n        return bestBatchSize;\n      }\n    }\n\n    // Default batch size based on complexity\n    switch (taskComplexity) {\n      case 'low':\n        return Math.min(3, estimatedAgentCount);\n      case 'medium':\n        return Math.min(5, estimatedAgentCount);\n      case 'high':\n        return Math.min(7, estimatedAgentCount);\n      case 'critical':\n        return Math.min(10, estimatedAgentCount);\n    }\n  }\n\n  /**\n   * Get maximum agents for topology (to avoid coordination overhead)\n   */\n  private getMaxAgentsForTopology(topology: string): number {\n    switch (topology) {\n      case 'mesh':\n        return 10; // O(n²) coordination overhead beyond this\n      case 'hierarchical':\n        return 50; // Scales well with delegation\n      case 'ring':\n        return 20; // Sequential token passing limits scale\n      case 'star':\n        return 30; // Central coordinator bottleneck\n      default:\n        return 10;\n    }\n  }\n\n  /**\n   * Generate statistics report on learned patterns\n   */\n  async getOptimizationStats(): Promise<{\n    totalPatterns: number;\n    topologiesUsed: Record<string, number>;\n    avgSpeedupByTopology: Record<string, number>;\n    avgSuccessRate: number;\n    bestPerformingTopology: string;\n  }> {\n    const allPatterns = await this.reasoningBank.searchPatterns(this.NAMESPACE, {\n      k: 1000,\n      onlySuccesses: true\n    });\n\n    const stats = {\n      totalPatterns: allPatterns.length,\n      topologiesUsed: {} as Record<string, number>,\n      speedupByTopology: {} as Record<string, number[]>,\n      successRates: [] as number[],\n      avgSpeedupByTopology: {} as Record<string, number>,\n      avgSuccessRate: 0,\n      bestPerformingTopology: 'hierarchical'\n    };\n\n    for (const pattern of allPatterns) {\n      try {\n        const metrics: SwarmMetrics = JSON.parse(pattern.output);\n\n        // Count topology usage\n        stats.topologiesUsed[metrics.topology] = (stats.topologiesUsed[metrics.topology] || 0) + 1;\n\n        // Track speedup\n        if (!stats.speedupByTopology[metrics.topology]) {\n          stats.speedupByTopology[metrics.topology] = [];\n        }\n        if (metrics.speedup) {\n          stats.speedupByTopology[metrics.topology].push(metrics.speedup);\n        }\n\n        // Track success rate\n        stats.successRates.push(metrics.successRate);\n      } catch (e) {\n        continue;\n      }\n    }\n\n    // Calculate averages\n    for (const [topology, speedups] of Object.entries(stats.speedupByTopology)) {\n      if (speedups.length > 0) {\n        stats.avgSpeedupByTopology[topology] = speedups.reduce((a, b) => a + b, 0) / speedups.length;\n      }\n    }\n\n    stats.avgSuccessRate = stats.successRates.length > 0\n      ? stats.successRates.reduce((a, b) => a + b, 0) / stats.successRates.length\n      : 0;\n\n    // Find best performing topology\n    let bestSpeedup = 0;\n    for (const [topology, avgSpeedup] of Object.entries(stats.avgSpeedupByTopology)) {\n      if (avgSpeedup > bestSpeedup) {\n        bestSpeedup = avgSpeedup;\n        stats.bestPerformingTopology = topology;\n      }\n    }\n\n    return {\n      totalPatterns: stats.totalPatterns,\n      topologiesUsed: stats.topologiesUsed,\n      avgSpeedupByTopology: stats.avgSpeedupByTopology,\n      avgSuccessRate: Math.round(stats.avgSuccessRate * 10) / 10,\n      bestPerformingTopology: stats.bestPerformingTopology\n    };\n  }\n}\n\n/**\n * Auto-select optimal swarm configuration\n */\nexport async function autoSelectSwarmConfig(\n  reasoningBank: ReasoningBank,\n  taskDescription: string,\n  options: {\n    taskComplexity?: 'low' | 'medium' | 'high' | 'critical';\n    estimatedAgentCount?: number;\n  } = {}\n): Promise<OptimizationRecommendation> {\n  const optimizer = new SwarmLearningOptimizer(reasoningBank);\n\n  const complexity = options.taskComplexity || 'medium';\n  const agentCount = options.estimatedAgentCount || 5;\n\n  return await optimizer.getOptimization(taskDescription, complexity, agentCount);\n}\n"]}