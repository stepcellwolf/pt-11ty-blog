{"version":3,"file":"provider-manager.js","sourceRoot":"","sources":["../../src/core/provider-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Provider Manager - Intelligent LLM Provider Fallback & Dynamic Switching\n *\n * Features:\n * - Automatic failover between providers\n * - Health monitoring and circuit breaking\n * - Cost-based optimization\n * - Performance tracking\n * - Rate limit handling\n * - Provider quality scoring\n */\n\nimport { logger } from '../utils/logger.js';\n\nexport type ProviderType = 'anthropic' | 'gemini' | 'openrouter' | 'onnx';\n\nexport interface ProviderConfig {\n  name: ProviderType;\n  apiKey?: string;\n  baseUrl?: string;\n  priority: number; // 1 = highest priority\n  maxRetries: number;\n  timeout: number; // milliseconds\n  costPerToken: number; // USD per 1M tokens\n  enabled: boolean;\n  healthCheckInterval?: number; // milliseconds\n}\n\nexport interface ProviderHealth {\n  provider: ProviderType;\n  isHealthy: boolean;\n  lastChecked: Date;\n  consecutiveFailures: number;\n  averageLatency: number; // milliseconds\n  successRate: number; // 0-1\n  errorRate: number; // 0-1\n  circuitBreakerOpen: boolean;\n}\n\nexport interface ProviderMetrics {\n  provider: ProviderType;\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  totalTokens: number;\n  totalCost: number;\n  averageLatency: number;\n  lastUsed: Date;\n}\n\nexport interface FallbackStrategy {\n  type: 'priority' | 'cost-optimized' | 'performance-optimized' | 'round-robin';\n  maxFailures: number; // Circuit breaker threshold\n  recoveryTime: number; // milliseconds before retry\n  retryBackoff: 'linear' | 'exponential';\n  costThreshold?: number; // Max USD per request\n  latencyThreshold?: number; // Max milliseconds\n}\n\nexport class ProviderManager {\n  private providers: Map<ProviderType, ProviderConfig> = new Map();\n  private health: Map<ProviderType, ProviderHealth> = new Map();\n  private metrics: Map<ProviderType, ProviderMetrics> = new Map();\n  private strategy: FallbackStrategy;\n  private currentProvider: ProviderType | null = null;\n  private healthCheckIntervals: Map<ProviderType, NodeJS.Timeout> = new Map();\n\n  constructor(\n    providers: ProviderConfig[],\n    strategy: FallbackStrategy = {\n      type: 'priority',\n      maxFailures: 3,\n      recoveryTime: 60000, // 1 minute\n      retryBackoff: 'exponential'\n    }\n  ) {\n    this.strategy = strategy;\n    this.initializeProviders(providers);\n    this.startHealthChecks();\n  }\n\n  /**\n   * Initialize provider configurations\n   */\n  private initializeProviders(providers: ProviderConfig[]): void {\n    for (const provider of providers) {\n      this.providers.set(provider.name, provider);\n\n      // Initialize health tracking\n      this.health.set(provider.name, {\n        provider: provider.name,\n        isHealthy: true,\n        lastChecked: new Date(),\n        consecutiveFailures: 0,\n        averageLatency: 0,\n        successRate: 1.0,\n        errorRate: 0.0,\n        circuitBreakerOpen: false\n      });\n\n      // Initialize metrics\n      this.metrics.set(provider.name, {\n        provider: provider.name,\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        totalTokens: 0,\n        totalCost: 0,\n        averageLatency: 0,\n        lastUsed: new Date()\n      });\n    }\n\n    logger.info('Provider Manager initialized', {\n      providers: Array.from(this.providers.keys()),\n      strategy: this.strategy.type\n    });\n  }\n\n  /**\n   * Start health check monitoring for all providers\n   */\n  private startHealthChecks(): void {\n    for (const [name, config] of this.providers.entries()) {\n      if (config.healthCheckInterval) {\n        const interval = setInterval(() => {\n          this.performHealthCheck(name);\n        }, config.healthCheckInterval);\n\n        this.healthCheckIntervals.set(name, interval);\n      }\n    }\n  }\n\n  /**\n   * Perform health check on a provider\n   */\n  private async performHealthCheck(provider: ProviderType): Promise<void> {\n    const health = this.health.get(provider);\n    if (!health) return;\n\n    try {\n      const startTime = Date.now();\n      // TODO: Implement actual health check API call\n      // For now, just check if circuit breaker should recover\n      const latency = Date.now() - startTime;\n\n      health.lastChecked = new Date();\n      health.averageLatency = (health.averageLatency + latency) / 2;\n\n      // Recovery logic: reset circuit breaker after recovery time\n      if (health.circuitBreakerOpen) {\n        const timeSinceLastCheck = Date.now() - health.lastChecked.getTime();\n        if (timeSinceLastCheck >= this.strategy.recoveryTime) {\n          logger.info('Circuit breaker recovering', { provider });\n          health.circuitBreakerOpen = false;\n          health.consecutiveFailures = 0;\n        }\n      }\n\n      logger.debug('Health check completed', { provider, health });\n    } catch (error) {\n      logger.error('Health check failed', { provider, error: (error as Error).message });\n      this.recordFailure(provider, error as Error);\n    }\n  }\n\n  /**\n   * Select the best provider based on strategy\n   */\n  public async selectProvider(\n    taskComplexity?: 'simple' | 'medium' | 'complex',\n    estimatedTokens?: number\n  ): Promise<ProviderType> {\n    const availableProviders = this.getAvailableProviders();\n\n    if (availableProviders.length === 0) {\n      throw new Error('No healthy providers available');\n    }\n\n    let selectedProvider: ProviderType;\n\n    switch (this.strategy.type) {\n      case 'priority':\n        selectedProvider = this.selectByPriority(availableProviders);\n        break;\n\n      case 'cost-optimized':\n        selectedProvider = this.selectByCost(availableProviders, estimatedTokens);\n        break;\n\n      case 'performance-optimized':\n        selectedProvider = this.selectByPerformance(availableProviders);\n        break;\n\n      case 'round-robin':\n        selectedProvider = this.selectRoundRobin(availableProviders);\n        break;\n\n      default:\n        selectedProvider = availableProviders[0];\n    }\n\n    // Apply task complexity heuristics\n    if (taskComplexity === 'complex' && this.providers.has('anthropic')) {\n      const anthropicHealth = this.health.get('anthropic');\n      if (anthropicHealth?.isHealthy && !anthropicHealth.circuitBreakerOpen) {\n        selectedProvider = 'anthropic'; // Prefer Claude for complex tasks\n      }\n    } else if (taskComplexity === 'simple' && this.providers.has('gemini')) {\n      const geminiHealth = this.health.get('gemini');\n      if (geminiHealth?.isHealthy && !geminiHealth.circuitBreakerOpen) {\n        selectedProvider = 'gemini'; // Prefer Gemini for simple tasks (faster, cheaper)\n      }\n    }\n\n    this.currentProvider = selectedProvider;\n    logger.info('Provider selected', {\n      provider: selectedProvider,\n      strategy: this.strategy.type,\n      taskComplexity,\n      estimatedTokens\n    });\n\n    return selectedProvider;\n  }\n\n  /**\n   * Get list of healthy, available providers\n   */\n  private getAvailableProviders(): ProviderType[] {\n    const available: ProviderType[] = [];\n\n    for (const [name, config] of this.providers.entries()) {\n      const health = this.health.get(name);\n\n      if (\n        config.enabled &&\n        health?.isHealthy &&\n        !health.circuitBreakerOpen\n      ) {\n        available.push(name);\n      }\n    }\n\n    // Sort by priority\n    available.sort((a, b) => {\n      const priorityA = this.providers.get(a)?.priority ?? 999;\n      const priorityB = this.providers.get(b)?.priority ?? 999;\n      return priorityA - priorityB;\n    });\n\n    return available;\n  }\n\n  /**\n   * Select provider by priority\n   */\n  private selectByPriority(providers: ProviderType[]): ProviderType {\n    return providers[0]; // Already sorted by priority\n  }\n\n  /**\n   * Select provider by cost optimization\n   */\n  private selectByCost(providers: ProviderType[], estimatedTokens?: number): ProviderType {\n    if (!estimatedTokens) {\n      return this.selectByPriority(providers);\n    }\n\n    let bestProvider = providers[0];\n    let lowestCost = Infinity;\n\n    for (const provider of providers) {\n      const config = this.providers.get(provider);\n      if (!config) continue;\n\n      const estimatedCost = (estimatedTokens / 1_000_000) * config.costPerToken;\n\n      if (estimatedCost < lowestCost) {\n        lowestCost = estimatedCost;\n        bestProvider = provider;\n      }\n    }\n\n    return bestProvider;\n  }\n\n  /**\n   * Select provider by performance (latency + success rate)\n   */\n  private selectByPerformance(providers: ProviderType[]): ProviderType {\n    let bestProvider = providers[0];\n    let bestScore = -Infinity;\n\n    for (const provider of providers) {\n      const health = this.health.get(provider);\n      if (!health) continue;\n\n      // Score = success rate (weighted 70%) - normalized latency (weighted 30%)\n      const normalizedLatency = health.averageLatency / 1000; // Convert to seconds\n      const score = (health.successRate * 0.7) - (normalizedLatency * 0.3);\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestProvider = provider;\n      }\n    }\n\n    return bestProvider;\n  }\n\n  /**\n   * Select provider using round-robin\n   */\n  private selectRoundRobin(providers: ProviderType[]): ProviderType {\n    if (!this.currentProvider || !providers.includes(this.currentProvider)) {\n      return providers[0];\n    }\n\n    const currentIndex = providers.indexOf(this.currentProvider);\n    const nextIndex = (currentIndex + 1) % providers.length;\n    return providers[nextIndex];\n  }\n\n  /**\n   * Execute request with automatic fallback\n   */\n  public async executeWithFallback<T>(\n    requestFn: (provider: ProviderType) => Promise<T>,\n    taskComplexity?: 'simple' | 'medium' | 'complex',\n    estimatedTokens?: number\n  ): Promise<{ result: T; provider: ProviderType; attempts: number }> {\n    const startTime = Date.now();\n    let attempts = 0;\n    let lastError: Error | null = null;\n\n    // Try each available provider\n    const availableProviders = this.getAvailableProviders();\n    const provider = await this.selectProvider(taskComplexity, estimatedTokens);\n\n    // Start with selected provider, then try fallbacks\n    const providersToTry = [\n      provider,\n      ...availableProviders.filter(p => p !== provider)\n    ];\n\n    for (const currentProvider of providersToTry) {\n      attempts++;\n      const config = this.providers.get(currentProvider);\n      if (!config) continue;\n\n      try {\n        logger.info('Attempting request', { provider: currentProvider, attempt: attempts });\n\n        const requestStartTime = Date.now();\n        const result = await this.executeWithRetry(\n          requestFn,\n          currentProvider,\n          config.maxRetries\n        );\n        const latency = Date.now() - requestStartTime;\n\n        // Record success\n        this.recordSuccess(currentProvider, latency, estimatedTokens || 0);\n\n        logger.info('Request successful', {\n          provider: currentProvider,\n          attempts,\n          latency,\n          totalTime: Date.now() - startTime\n        });\n\n        return { result, provider: currentProvider, attempts };\n\n      } catch (error) {\n        lastError = error as Error;\n        logger.warn('Provider request failed', {\n          provider: currentProvider,\n          attempt: attempts,\n          error: lastError.message\n        });\n\n        // Record failure\n        this.recordFailure(currentProvider, lastError);\n\n        // Continue to next provider\n        continue;\n      }\n    }\n\n    // All providers failed\n    throw new Error(\n      `All providers failed after ${attempts} attempts. Last error: ${lastError?.message}`\n    );\n  }\n\n  /**\n   * Execute request with retry logic\n   */\n  private async executeWithRetry<T>(\n    requestFn: (provider: ProviderType) => Promise<T>,\n    provider: ProviderType,\n    maxRetries: number\n  ): Promise<T> {\n    let lastError: Error | null = null;\n\n    for (let retry = 0; retry <= maxRetries; retry++) {\n      try {\n        // Apply backoff delay\n        if (retry > 0) {\n          const delay = this.calculateBackoffDelay(retry);\n          logger.debug('Retry backoff', { provider, retry, delay });\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n\n        return await requestFn(provider);\n\n      } catch (error) {\n        lastError = error as Error;\n\n        // Check if error is retryable\n        if (!this.isRetryableError(error as Error)) {\n          throw error;\n        }\n\n        logger.debug('Retryable error, continuing', {\n          provider,\n          retry,\n          error: lastError.message\n        });\n      }\n    }\n\n    throw lastError || new Error('Max retries exceeded');\n  }\n\n  /**\n   * Calculate backoff delay\n   */\n  private calculateBackoffDelay(retry: number): number {\n    if (this.strategy.retryBackoff === 'exponential') {\n      // Exponential backoff: 1s, 2s, 4s, 8s, 16s...\n      return Math.min(1000 * Math.pow(2, retry), 30000); // Max 30s\n    } else {\n      // Linear backoff: 1s, 2s, 3s, 4s...\n      return Math.min(1000 * retry, 10000); // Max 10s\n    }\n  }\n\n  /**\n   * Check if error is retryable\n   */\n  private isRetryableError(error: Error): boolean {\n    const retryablePatterns = [\n      /rate limit/i,\n      /timeout/i,\n      /connection/i,\n      /network/i,\n      /503/,\n      /502/,\n      /429/\n    ];\n\n    return retryablePatterns.some(pattern => pattern.test(error.message));\n  }\n\n  /**\n   * Record successful request\n   */\n  private recordSuccess(provider: ProviderType, latency: number, tokens: number): void {\n    const metrics = this.metrics.get(provider);\n    const health = this.health.get(provider);\n    const config = this.providers.get(provider);\n\n    if (metrics) {\n      metrics.totalRequests++;\n      metrics.successfulRequests++;\n      metrics.totalTokens += tokens;\n      metrics.totalCost += (tokens / 1_000_000) * (config?.costPerToken || 0);\n      metrics.averageLatency = (metrics.averageLatency + latency) / 2;\n      metrics.lastUsed = new Date();\n    }\n\n    if (health) {\n      health.consecutiveFailures = 0;\n      health.isHealthy = true;\n      health.circuitBreakerOpen = false;\n      health.successRate = metrics ? metrics.successfulRequests / metrics.totalRequests : 1.0;\n      health.errorRate = 1.0 - health.successRate;\n      health.averageLatency = latency;\n    }\n  }\n\n  /**\n   * Record failed request\n   */\n  private recordFailure(provider: ProviderType, error: Error): void {\n    const metrics = this.metrics.get(provider);\n    const health = this.health.get(provider);\n\n    if (metrics) {\n      metrics.totalRequests++;\n      metrics.failedRequests++;\n    }\n\n    if (health) {\n      health.consecutiveFailures++;\n      health.successRate = metrics ? metrics.successfulRequests / metrics.totalRequests : 0.0;\n      health.errorRate = 1.0 - health.successRate;\n\n      // Open circuit breaker if threshold exceeded\n      if (health.consecutiveFailures >= this.strategy.maxFailures) {\n        logger.warn('Circuit breaker opened', {\n          provider,\n          consecutiveFailures: health.consecutiveFailures,\n          threshold: this.strategy.maxFailures\n        });\n\n        health.circuitBreakerOpen = true;\n        health.isHealthy = false;\n      }\n    }\n\n    logger.error('Provider failure recorded', {\n      provider,\n      error: error.message,\n      consecutiveFailures: health?.consecutiveFailures,\n      circuitBreakerOpen: health?.circuitBreakerOpen\n    });\n  }\n\n  /**\n   * Get current metrics for all providers\n   */\n  public getMetrics(): ProviderMetrics[] {\n    return Array.from(this.metrics.values());\n  }\n\n  /**\n   * Get health status for all providers\n   */\n  public getHealth(): ProviderHealth[] {\n    return Array.from(this.health.values());\n  }\n\n  /**\n   * Get cost summary\n   */\n  public getCostSummary(): {\n    total: number;\n    byProvider: Record<ProviderType, number>;\n    totalTokens: number;\n  } {\n    let total = 0;\n    let totalTokens = 0;\n    const byProvider: Record<string, number> = {};\n\n    for (const [name, metrics] of this.metrics.entries()) {\n      total += metrics.totalCost;\n      totalTokens += metrics.totalTokens;\n      byProvider[name] = metrics.totalCost;\n    }\n\n    return { total, byProvider: byProvider as Record<ProviderType, number>, totalTokens };\n  }\n\n  /**\n   * Cleanup and stop health checks\n   */\n  public destroy(): void {\n    for (const interval of this.healthCheckIntervals.values()) {\n      clearInterval(interval);\n    }\n    this.healthCheckIntervals.clear();\n    logger.info('Provider Manager destroyed');\n  }\n}\n"]}