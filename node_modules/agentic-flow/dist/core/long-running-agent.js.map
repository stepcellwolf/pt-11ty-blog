{"version":3,"file":"long-running-agent.js","sourceRoot":"","sources":["../../src/core/long-running-agent.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Long-Running Agent with Provider Fallback\n *\n * Demonstrates how to use ProviderManager for resilient, cost-optimized agents\n * that can run for hours or days with automatic provider switching.\n */\n\nimport { ProviderManager, ProviderConfig, FallbackStrategy } from './provider-manager.js';\nimport { logger } from '../utils/logger.js';\n\nexport interface LongRunningAgentConfig {\n  agentName: string;\n  providers: ProviderConfig[];\n  fallbackStrategy?: FallbackStrategy;\n  checkpointInterval?: number; // Save state every N milliseconds\n  maxRuntime?: number; // Max runtime in milliseconds\n  costBudget?: number; // Max USD to spend\n  performanceTarget?: number; // Target latency in milliseconds\n}\n\nexport interface AgentCheckpoint {\n  timestamp: Date;\n  taskProgress: number; // 0-1\n  currentProvider: string;\n  totalCost: number;\n  totalTokens: number;\n  completedTasks: number;\n  failedTasks: number;\n  state: Record<string, any>;\n}\n\nexport class LongRunningAgent {\n  private providerManager: ProviderManager;\n  private config: LongRunningAgentConfig;\n  private startTime: Date;\n  private checkpoints: AgentCheckpoint[] = [];\n  private currentState: Record<string, any> = {};\n  private isRunning: boolean = false;\n  private checkpointInterval?: NodeJS.Timeout;\n\n  constructor(config: LongRunningAgentConfig) {\n    this.config = config;\n    this.startTime = new Date();\n\n    // Initialize provider manager\n    this.providerManager = new ProviderManager(\n      config.providers,\n      config.fallbackStrategy\n    );\n\n    logger.info('Long-running agent initialized', {\n      agentName: config.agentName,\n      providers: config.providers.map(p => p.name)\n    });\n  }\n\n  /**\n   * Start the agent with automatic checkpointing\n   */\n  public async start(): Promise<void> {\n    this.isRunning = true;\n    this.startTime = new Date();\n\n    // Start checkpoint interval\n    if (this.config.checkpointInterval) {\n      this.checkpointInterval = setInterval(() => {\n        this.saveCheckpoint();\n      }, this.config.checkpointInterval);\n    }\n\n    logger.info('Long-running agent started', {\n      agentName: this.config.agentName,\n      startTime: this.startTime\n    });\n  }\n\n  /**\n   * Execute a task with automatic provider fallback\n   */\n  public async executeTask<T>(\n    task: {\n      name: string;\n      complexity: 'simple' | 'medium' | 'complex';\n      estimatedTokens?: number;\n      execute: (provider: string) => Promise<T>;\n    }\n  ): Promise<T> {\n    if (!this.isRunning) {\n      throw new Error('Agent not running. Call start() first.');\n    }\n\n    // Check budget constraint\n    if (this.config.costBudget) {\n      const currentCost = this.providerManager.getCostSummary().total;\n      if (currentCost >= this.config.costBudget) {\n        throw new Error(`Cost budget exceeded: $${currentCost.toFixed(2)} >= $${this.config.costBudget}`);\n      }\n    }\n\n    // Check runtime constraint\n    if (this.config.maxRuntime) {\n      const runtime = Date.now() - this.startTime.getTime();\n      if (runtime >= this.config.maxRuntime) {\n        throw new Error(`Max runtime exceeded: ${runtime}ms >= ${this.config.maxRuntime}ms`);\n      }\n    }\n\n    logger.info('Executing task', {\n      agentName: this.config.agentName,\n      taskName: task.name,\n      complexity: task.complexity\n    });\n\n    try {\n      // Execute with automatic fallback\n      const { result, provider, attempts } = await this.providerManager.executeWithFallback(\n        task.execute,\n        task.complexity,\n        task.estimatedTokens\n      );\n\n      // Update state\n      this.currentState.lastTask = task.name;\n      this.currentState.lastProvider = provider;\n      this.currentState.completedTasks = (this.currentState.completedTasks || 0) + 1;\n\n      logger.info('Task completed', {\n        agentName: this.config.agentName,\n        taskName: task.name,\n        provider,\n        attempts\n      });\n\n      return result;\n\n    } catch (error) {\n      this.currentState.failedTasks = (this.currentState.failedTasks || 0) + 1;\n\n      logger.error('Task failed', {\n        agentName: this.config.agentName,\n        taskName: task.name,\n        error: (error as Error).message\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Save checkpoint of current state\n   */\n  private saveCheckpoint(): void {\n    const costSummary = this.providerManager.getCostSummary();\n    const health = this.providerManager.getHealth();\n\n    const checkpoint: AgentCheckpoint = {\n      timestamp: new Date(),\n      taskProgress: this.calculateProgress(),\n      currentProvider: this.currentState.lastProvider || 'none',\n      totalCost: costSummary.total,\n      totalTokens: costSummary.totalTokens,\n      completedTasks: this.currentState.completedTasks || 0,\n      failedTasks: this.currentState.failedTasks || 0,\n      state: { ...this.currentState }\n    };\n\n    this.checkpoints.push(checkpoint);\n\n    logger.info('Checkpoint saved', {\n      agentName: this.config.agentName,\n      checkpoint: {\n        ...checkpoint,\n        state: undefined // Don't log full state\n      }\n    });\n\n    // Alert if cost approaching budget\n    if (this.config.costBudget) {\n      const costPercentage = (costSummary.total / this.config.costBudget) * 100;\n      if (costPercentage >= 80) {\n        logger.warn('Cost budget warning', {\n          agentName: this.config.agentName,\n          currentCost: costSummary.total,\n          budget: this.config.costBudget,\n          percentage: costPercentage.toFixed(1) + '%'\n        });\n      }\n    }\n\n    // Alert if providers unhealthy\n    const unhealthyProviders = health.filter(h => !h.isHealthy || h.circuitBreakerOpen);\n    if (unhealthyProviders.length > 0) {\n      logger.warn('Unhealthy providers detected', {\n        agentName: this.config.agentName,\n        unhealthy: unhealthyProviders.map(h => ({\n          provider: h.provider,\n          circuitBreakerOpen: h.circuitBreakerOpen,\n          consecutiveFailures: h.consecutiveFailures\n        }))\n      });\n    }\n  }\n\n  /**\n   * Calculate task progress (override in subclass)\n   */\n  protected calculateProgress(): number {\n    // Default: based on completed vs total tasks\n    const completed = this.currentState.completedTasks || 0;\n    const failed = this.currentState.failedTasks || 0;\n    const total = completed + failed;\n\n    return total > 0 ? completed / total : 0;\n  }\n\n  /**\n   * Get current status\n   */\n  public getStatus(): {\n    isRunning: boolean;\n    runtime: number;\n    completedTasks: number;\n    failedTasks: number;\n    totalCost: number;\n    totalTokens: number;\n    providers: any[];\n    lastCheckpoint?: AgentCheckpoint;\n  } {\n    const costSummary = this.providerManager.getCostSummary();\n    const health = this.providerManager.getHealth();\n    const runtime = Date.now() - this.startTime.getTime();\n\n    return {\n      isRunning: this.isRunning,\n      runtime,\n      completedTasks: this.currentState.completedTasks || 0,\n      failedTasks: this.currentState.failedTasks || 0,\n      totalCost: costSummary.total,\n      totalTokens: costSummary.totalTokens,\n      providers: health.map(h => ({\n        name: h.provider,\n        healthy: h.isHealthy,\n        circuitBreakerOpen: h.circuitBreakerOpen,\n        successRate: (h.successRate * 100).toFixed(1) + '%',\n        avgLatency: h.averageLatency.toFixed(0) + 'ms'\n      })),\n      lastCheckpoint: this.checkpoints[this.checkpoints.length - 1]\n    };\n  }\n\n  /**\n   * Get detailed metrics\n   */\n  public getMetrics() {\n    return {\n      providers: this.providerManager.getMetrics(),\n      health: this.providerManager.getHealth(),\n      costs: this.providerManager.getCostSummary(),\n      checkpoints: this.checkpoints\n    };\n  }\n\n  /**\n   * Restore from checkpoint\n   */\n  public restoreFromCheckpoint(checkpoint: AgentCheckpoint): void {\n    this.currentState = { ...checkpoint.state };\n    logger.info('Restored from checkpoint', {\n      agentName: this.config.agentName,\n      checkpoint: checkpoint.timestamp\n    });\n  }\n\n  /**\n   * Stop the agent\n   */\n  public async stop(): Promise<void> {\n    this.isRunning = false;\n\n    // Clear checkpoint interval\n    if (this.checkpointInterval) {\n      clearInterval(this.checkpointInterval);\n    }\n\n    // Save final checkpoint\n    this.saveCheckpoint();\n\n    // Cleanup provider manager\n    this.providerManager.destroy();\n\n    logger.info('Long-running agent stopped', {\n      agentName: this.config.agentName,\n      runtime: Date.now() - this.startTime.getTime(),\n      completedTasks: this.currentState.completedTasks,\n      failedTasks: this.currentState.failedTasks\n    });\n  }\n}\n"]}