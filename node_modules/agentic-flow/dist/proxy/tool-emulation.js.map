{"version":3,"file":"tool-emulation.js","sourceRoot":"","sources":["../../src/proxy/tool-emulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Tool Emulation Layer for Models Without Native Function Calling\n *\n * Implements two strategies:\n * 1. ReAct Pattern - Structured reasoning with tool use\n * 2. Prompt-Based - Direct JSON tool invocation\n *\n * Automatically selected based on model capabilities.\n */\n\nexport interface Tool {\n  name: string;\n  description?: string;\n  input_schema?: {\n    type: string;\n    properties?: Record<string, any>;\n    required?: string[];\n  };\n}\n\nexport interface ToolCall {\n  name: string;\n  arguments: Record<string, any>;\n  id?: string;\n}\n\nexport interface EmulationResult {\n  toolCalls: ToolCall[];\n  reasoning?: string;\n  finalAnswer?: string;\n  confidence: number;  // 0-1\n}\n\n/**\n * ReAct Pattern Implementation\n * Best for: Models with 32k+ context, complex multi-step tasks\n */\nexport class ReActEmulator {\n  constructor(private tools: Tool[]) {}\n\n  /**\n   * Build ReAct prompt with tool catalog\n   */\n  buildPrompt(userMessage: string, previousSteps: string = ''): string {\n    const toolCatalog = this.tools.map(tool => {\n      const params = tool.input_schema?.properties || {};\n      const required = tool.input_schema?.required || [];\n\n      const paramDocs = Object.entries(params).map(([name, schema]: [string, any]) => {\n        const req = required.includes(name) ? '(required)' : '(optional)';\n        const type = schema.type || 'any';\n        return `    - ${name} ${req}: ${type} - ${schema.description || ''}`;\n      }).join('\\n');\n\n      return `â€¢ ${tool.name}: ${tool.description || 'No description'}\n${paramDocs}`;\n    }).join('\\n\\n');\n\n    return `You are solving a task using available tools. Think step-by-step using this format:\n\nThought: [Your reasoning about what to do next]\nAction: [tool_name]\nAction Input: [JSON object with tool parameters]\nObservation: [Tool result will be inserted here by the system]\n... (repeat Thought/Action/Observation as needed)\nFinal Answer: [Your complete answer to the user's question]\n\nAvailable Tools:\n${toolCatalog}\n\nIMPORTANT:\n- Action Input must be valid JSON matching the tool's schema\n- Only use tools from the list above\n- When you have enough information, provide a Final Answer\n- If a tool fails, think about alternative approaches\n\n${previousSteps}\n\nUser Question: ${userMessage}\n\nBegin!`;\n  }\n\n  /**\n   * Parse ReAct response and extract tool calls\n   */\n  parseResponse(response: string): {\n    toolCall?: ToolCall;\n    thought?: string;\n    finalAnswer?: string;\n  } {\n    // Extract components ([\\s\\S] instead of /s flag for ES5 compatibility)\n    const thoughtMatch = response.match(/Thought:\\s*([\\s\\S]+?)(?=\\n(?:Action:|Final Answer:|$))/);\n    const actionMatch = response.match(/Action:\\s*(\\w+)/);\n    const inputMatch = response.match(/Action Input:\\s*(\\{[\\s\\S]*?\\})/);\n    const finalMatch = response.match(/Final Answer:\\s*([\\s\\S]+?)$/);\n\n\n    if (finalMatch) {\n      return {\n        finalAnswer: finalMatch[1].trim(),\n        thought: thoughtMatch?.[1].trim()\n      };\n    }\n\n    if (actionMatch && inputMatch) {\n      try {\n        const args = JSON.parse(inputMatch[1].trim());\n        return {\n          toolCall: {\n            name: actionMatch[1],\n            arguments: args,\n            id: `react_${Date.now()}`\n          },\n          thought: thoughtMatch?.[1].trim()\n        };\n      } catch (e) {\n        console.error('Failed to parse Action Input JSON:', e);\n        return { thought: thoughtMatch?.[1].trim() };\n      }\n    }\n\n    return { thought: thoughtMatch?.[1].trim() };\n  }\n\n  /**\n   * Build prompt with observation after tool execution\n   */\n  appendObservation(previousPrompt: string, observation: string): string {\n    return `${previousPrompt}\\nObservation: ${observation}\\n`;\n  }\n}\n\n/**\n * Prompt-Based Tool Emulation\n * Best for: Simple tasks, models with limited context\n */\nexport class PromptEmulator {\n  constructor(private tools: Tool[]) {}\n\n  /**\n   * Build simple prompt for tool invocation\n   */\n  buildPrompt(userMessage: string): string {\n    const toolCatalog = this.tools.map(tool => {\n      const params = tool.input_schema?.properties || {};\n      const paramList = Object.keys(params).join(', ');\n\n      return `${tool.name}(${paramList}): ${tool.description || 'No description'}`;\n    }).join('\\n');\n\n    return `You have access to these tools:\n\n${toolCatalog}\n\nTo use a tool, respond with ONLY this JSON format (no other text):\n{\n  \"tool\": \"tool_name\",\n  \"arguments\": {\n    \"param1\": \"value1\",\n    \"param2\": \"value2\"\n  }\n}\n\nIf you don't need a tool, respond with your answer normally.\n\nUser: ${userMessage}\n\nResponse:`;\n  }\n\n  /**\n   * Parse response - either tool call JSON or regular text\n   */\n  parseResponse(response: string): {\n    toolCall?: ToolCall;\n    textResponse?: string;\n  } {\n    // Try to extract JSON from response\n    const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n\n    if (!jsonMatch) {\n      return { textResponse: response.trim() };\n    }\n\n    try {\n      const parsed = JSON.parse(jsonMatch[0]);\n\n      if (parsed.tool && parsed.arguments) {\n        return {\n          toolCall: {\n            name: parsed.tool,\n            arguments: parsed.arguments,\n            id: `prompt_${Date.now()}`\n          }\n        };\n      }\n    } catch (e) {\n      // Not valid JSON, treat as text response\n    }\n\n    return { textResponse: response.trim() };\n  }\n}\n\n/**\n * Unified Tool Emulation Interface\n */\nexport class ToolEmulator {\n  private reactEmulator: ReActEmulator;\n  private promptEmulator: PromptEmulator;\n\n  constructor(\n    private tools: Tool[],\n    private strategy: 'react' | 'prompt'\n  ) {\n    this.reactEmulator = new ReActEmulator(tools);\n    this.promptEmulator = new PromptEmulator(tools);\n  }\n\n  /**\n   * Build prompt based on selected strategy\n   */\n  buildPrompt(userMessage: string, context?: { previousSteps?: string }): string {\n    if (this.strategy === 'react') {\n      return this.reactEmulator.buildPrompt(userMessage, context?.previousSteps);\n    } else {\n      return this.promptEmulator.buildPrompt(userMessage);\n    }\n  }\n\n  /**\n   * Parse model response and extract tool calls\n   */\n  parseResponse(response: string): {\n    toolCall?: ToolCall;\n    finalAnswer?: string;\n    thought?: string;\n    textResponse?: string;\n  } {\n    if (this.strategy === 'react') {\n      return this.reactEmulator.parseResponse(response);\n    } else {\n      return this.promptEmulator.parseResponse(response);\n    }\n  }\n\n  /**\n   * Append observation (ReAct only)\n   */\n  appendObservation(prompt: string, observation: string): string {\n    if (this.strategy === 'react') {\n      return this.reactEmulator.appendObservation(prompt, observation);\n    }\n    return prompt;\n  }\n\n  /**\n   * Validate tool call against schema\n   */\n  validateToolCall(toolCall: ToolCall): { valid: boolean; errors?: string[] } {\n    const tool = this.tools.find(t => t.name === toolCall.name);\n\n    if (!tool) {\n      return {\n        valid: false,\n        errors: [`Tool '${toolCall.name}' not found. Available: ${this.tools.map(t => t.name).join(', ')}`]\n      };\n    }\n\n    const errors: string[] = [];\n    const schema = tool.input_schema;\n\n    if (!schema) {\n      return { valid: true };  // No schema to validate against\n    }\n\n    // Check required parameters\n    const required = schema.required || [];\n    for (const param of required) {\n      if (!(param in toolCall.arguments)) {\n        errors.push(`Missing required parameter: ${param}`);\n      }\n    }\n\n    // Type checking (basic)\n    const properties = schema.properties || {};\n    for (const [key, value] of Object.entries(toolCall.arguments)) {\n      if (properties[key]) {\n        const expectedType = properties[key].type;\n        const actualType = typeof value;\n\n        if (expectedType === 'string' && actualType !== 'string') {\n          errors.push(`Parameter '${key}' must be string, got ${actualType}`);\n        } else if (expectedType === 'number' && actualType !== 'number') {\n          errors.push(`Parameter '${key}' must be number, got ${actualType}`);\n        } else if (expectedType === 'boolean' && actualType !== 'boolean') {\n          errors.push(`Parameter '${key}' must be boolean, got ${actualType}`);\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n\n  /**\n   * Get confidence score for emulation result\n   * Based on: JSON validity, schema compliance, reasoning quality\n   */\n  getConfidence(parsed: ReturnType<typeof this.parseResponse>): number {\n    let confidence = 0.5;  // Base confidence\n\n    if (parsed.toolCall) {\n      const validation = this.validateToolCall(parsed.toolCall);\n      if (validation.valid) {\n        confidence += 0.3;  // Valid tool call\n      } else {\n        confidence -= 0.2;  // Invalid tool call\n      }\n    }\n\n    if (parsed.thought && parsed.thought.length > 20) {\n      confidence += 0.1;  // Good reasoning\n    }\n\n    if (parsed.finalAnswer && parsed.finalAnswer.length > 10) {\n      confidence += 0.1;  // Complete answer\n    }\n\n    return Math.max(0, Math.min(1, confidence));\n  }\n}\n\n/**\n * Execute tool emulation loop\n */\nexport async function executeEmulation(\n  emulator: ToolEmulator,\n  userMessage: string,\n  modelCall: (prompt: string) => Promise<string>,\n  toolExecutor: (toolCall: ToolCall) => Promise<any>,\n  options: {\n    maxIterations?: number;\n    verbose?: boolean;\n  } = {}\n): Promise<EmulationResult> {\n  const maxIterations = options.maxIterations || 5;\n  const verbose = options.verbose || false;\n\n  let prompt = emulator.buildPrompt(userMessage);\n  const toolCalls: ToolCall[] = [];\n  let finalAnswer: string | undefined;\n  let lastReasoning: string | undefined;\n\n  if (verbose) {\n    console.log('\\nðŸ”§ Starting tool emulation...\\n');\n  }\n\n  for (let i = 0; i < maxIterations; i++) {\n    if (verbose) {\n      console.log(`\\nâ”â”â” Iteration ${i + 1}/${maxIterations} â”â”â”`);\n    }\n\n    // Call model\n    const response = await modelCall(prompt);\n\n    if (verbose) {\n      console.log(`Model response:\\n${response.substring(0, 300)}...\\n`);\n    }\n\n    // Parse response\n    const parsed = emulator.parseResponse(response);\n\n    if (parsed.finalAnswer) {\n      finalAnswer = parsed.finalAnswer;\n      lastReasoning = parsed.thought;\n      if (verbose) {\n        console.log('âœ… Received final answer, stopping loop.\\n');\n      }\n      break;\n    }\n\n    if (parsed.toolCall) {\n      // Validate tool call\n      const validation = emulator.validateToolCall(parsed.toolCall);\n\n      if (!validation.valid) {\n        if (verbose) {\n          console.log(`âŒ Invalid tool call: ${validation.errors?.join(', ')}\\n`);\n        }\n        // Append error as observation and retry\n        prompt = emulator.appendObservation(\n          prompt,\n          `ERROR: ${validation.errors?.join('. ')}`\n        );\n        continue;\n      }\n\n      if (verbose) {\n        console.log(`ðŸ”¨ Executing tool: ${parsed.toolCall.name}`);\n        console.log(`   Arguments: ${JSON.stringify(parsed.toolCall.arguments)}\\n`);\n      }\n\n      // Execute tool\n      try {\n        const result = await toolExecutor(parsed.toolCall);\n        toolCalls.push(parsed.toolCall);\n\n        if (verbose) {\n          console.log(`âœ… Tool result: ${JSON.stringify(result).substring(0, 200)}\\n`);\n        }\n\n        // Append observation\n        prompt = emulator.appendObservation(\n          prompt,\n          JSON.stringify(result)\n        );\n      } catch (error: any) {\n        if (verbose) {\n          console.log(`âŒ Tool execution failed: ${error.message}\\n`);\n        }\n        prompt = emulator.appendObservation(\n          prompt,\n          `ERROR: ${error.message}`\n        );\n      }\n\n      lastReasoning = parsed.thought;\n    } else if (parsed.textResponse) {\n      // Model didn't use a tool and gave a direct response\n      finalAnswer = parsed.textResponse;\n      if (verbose) {\n        console.log('ðŸ“ Model provided direct text response (no tool use).\\n');\n      }\n      break;\n    }\n  }\n\n  if (!finalAnswer && verbose) {\n    console.log('âš ï¸  Reached max iterations without final answer.\\n');\n  }\n\n  const confidence = emulator.getConfidence({\n    toolCall: toolCalls[toolCalls.length - 1],\n    finalAnswer,\n    thought: lastReasoning\n  });\n\n  return {\n    toolCalls,\n    reasoning: lastReasoning,\n    finalAnswer,\n    confidence\n  };\n}\n"]}