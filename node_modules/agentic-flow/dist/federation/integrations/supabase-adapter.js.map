{"version":3,"file":"supabase-adapter.js","sourceRoot":"","sources":["../../../src/federation/integrations/supabase-adapter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Supabase Database Adapter for Federation Hub\n *\n * Provides PostgreSQL backend using Supabase for:\n * - Hub persistence\n * - Agent metadata\n * - Memory storage (optional pgvector)\n * - Real-time subscriptions\n */\n\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\n\nexport interface SupabaseConfig {\n  url: string;\n  anonKey: string;\n  serviceRoleKey?: string;\n  vectorBackend?: 'pgvector' | 'agentdb' | 'hybrid';\n  syncInterval?: number; // ms\n}\n\nexport interface AgentMemory {\n  id: string;\n  tenant_id: string;\n  agent_id: string;\n  session_id: string;\n  content: string;\n  embedding?: number[];\n  metadata?: Record<string, any>;\n  created_at?: string;\n  expires_at?: string;\n}\n\nexport class SupabaseFederationAdapter {\n  private client: SupabaseClient;\n  private config: SupabaseConfig;\n\n  constructor(config: SupabaseConfig) {\n    this.config = config;\n\n    // Use service role key for server-side operations\n    const key = config.serviceRoleKey || config.anonKey;\n    this.client = createClient(config.url, key);\n  }\n\n  /**\n   * Initialize Supabase schema for federation\n   */\n  async initialize(): Promise<void> {\n    console.log('üîß Initializing Supabase Federation Schema...');\n\n    // Check if tables exist, create if needed\n    await this.ensureTables();\n\n    if (this.config.vectorBackend === 'pgvector') {\n      await this.ensureVectorExtension();\n    }\n\n    console.log('‚úÖ Supabase Federation Schema Ready');\n  }\n\n  /**\n   * Ensure required tables exist\n   */\n  private async ensureTables(): Promise<void> {\n    // Note: In production, use Supabase migrations\n    // This is a runtime check for development\n\n    const { data, error } = await this.client\n      .from('agent_sessions')\n      .select('id')\n      .limit(1);\n\n    if (error && error.code === 'PGRST116') {\n      console.log('‚ö†Ô∏è  Tables not found. Please run Supabase migrations.');\n      console.log('üìñ See: docs/supabase/migrations/');\n    }\n  }\n\n  /**\n   * Ensure pgvector extension is enabled\n   */\n  private async ensureVectorExtension(): Promise<void> {\n    try {\n      // This requires service role key with proper permissions\n      const { error } = await this.client.rpc('exec_sql', {\n        sql: 'CREATE EXTENSION IF NOT EXISTS vector;'\n      });\n\n      if (error) {\n        console.warn('‚ö†Ô∏è  pgvector extension check failed:', error.message);\n        console.log('üìñ Enable manually: CREATE EXTENSION vector;');\n      }\n    } catch (err) {\n      console.warn('‚ö†Ô∏è  Could not verify pgvector extension');\n    }\n  }\n\n  /**\n   * Store agent memory in Supabase\n   */\n  async storeMemory(memory: AgentMemory): Promise<void> {\n    const { error } = await this.client\n      .from('agent_memories')\n      .insert({\n        id: memory.id,\n        tenant_id: memory.tenant_id,\n        agent_id: memory.agent_id,\n        session_id: memory.session_id,\n        content: memory.content,\n        embedding: memory.embedding,\n        metadata: memory.metadata,\n        created_at: memory.created_at || new Date().toISOString(),\n        expires_at: memory.expires_at,\n      });\n\n    if (error) {\n      throw new Error(`Failed to store memory: ${error.message}`);\n    }\n  }\n\n  /**\n   * Query memories by tenant and agent\n   */\n  async queryMemories(\n    tenantId: string,\n    agentId?: string,\n    limit: number = 100\n  ): Promise<AgentMemory[]> {\n    let query = this.client\n      .from('agent_memories')\n      .select('*')\n      .eq('tenant_id', tenantId)\n      .order('created_at', { ascending: false })\n      .limit(limit);\n\n    if (agentId) {\n      query = query.eq('agent_id', agentId);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      throw new Error(`Failed to query memories: ${error.message}`);\n    }\n\n    return data as AgentMemory[];\n  }\n\n  /**\n   * Semantic search using pgvector\n   */\n  async semanticSearch(\n    embedding: number[],\n    tenantId: string,\n    limit: number = 10\n  ): Promise<AgentMemory[]> {\n    if (this.config.vectorBackend !== 'pgvector') {\n      throw new Error('pgvector backend not enabled');\n    }\n\n    // Use pgvector cosine similarity search\n    const { data, error } = await this.client.rpc('search_memories', {\n      query_embedding: embedding,\n      query_tenant_id: tenantId,\n      match_count: limit,\n    });\n\n    if (error) {\n      throw new Error(`Semantic search failed: ${error.message}`);\n    }\n\n    return data as AgentMemory[];\n  }\n\n  /**\n   * Register agent session\n   */\n  async registerSession(\n    sessionId: string,\n    tenantId: string,\n    agentId: string,\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    const { error } = await this.client\n      .from('agent_sessions')\n      .insert({\n        session_id: sessionId,\n        tenant_id: tenantId,\n        agent_id: agentId,\n        metadata,\n        started_at: new Date().toISOString(),\n        status: 'active',\n      });\n\n    if (error) {\n      throw new Error(`Failed to register session: ${error.message}`);\n    }\n  }\n\n  /**\n   * Update session status\n   */\n  async updateSessionStatus(\n    sessionId: string,\n    status: 'active' | 'completed' | 'failed'\n  ): Promise<void> {\n    const updates: any = { status };\n\n    if (status !== 'active') {\n      updates.ended_at = new Date().toISOString();\n    }\n\n    const { error } = await this.client\n      .from('agent_sessions')\n      .update(updates)\n      .eq('session_id', sessionId);\n\n    if (error) {\n      throw new Error(`Failed to update session: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get active sessions for tenant\n   */\n  async getActiveSessions(tenantId: string): Promise<any[]> {\n    const { data, error } = await this.client\n      .from('agent_sessions')\n      .select('*')\n      .eq('tenant_id', tenantId)\n      .eq('status', 'active')\n      .order('started_at', { ascending: false });\n\n    if (error) {\n      throw new Error(`Failed to get sessions: ${error.message}`);\n    }\n\n    return data || [];\n  }\n\n  /**\n   * Subscribe to real-time memory updates\n   */\n  subscribeToMemories(\n    tenantId: string,\n    callback: (payload: any) => void\n  ): () => void {\n    const subscription = this.client\n      .channel(`memories:${tenantId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'agent_memories',\n          filter: `tenant_id=eq.${tenantId}`,\n        },\n        callback\n      )\n      .subscribe();\n\n    // Return unsubscribe function\n    return () => {\n      subscription.unsubscribe();\n    };\n  }\n\n  /**\n   * Clean up expired memories\n   */\n  async cleanupExpiredMemories(): Promise<number> {\n    const { data, error } = await this.client\n      .from('agent_memories')\n      .delete()\n      .lt('expires_at', new Date().toISOString())\n      .select('id');\n\n    if (error) {\n      throw new Error(`Cleanup failed: ${error.message}`);\n    }\n\n    return data?.length || 0;\n  }\n\n  /**\n   * Get hub statistics\n   */\n  async getStats(tenantId?: string): Promise<any> {\n    // Total memories\n    let memoriesQuery = this.client\n      .from('agent_memories')\n      .select('id', { count: 'exact', head: true });\n\n    if (tenantId) {\n      memoriesQuery = memoriesQuery.eq('tenant_id', tenantId);\n    }\n\n    const { count: totalMemories } = await memoriesQuery;\n\n    // Active sessions\n    let sessionsQuery = this.client\n      .from('agent_sessions')\n      .select('session_id', { count: 'exact', head: true })\n      .eq('status', 'active');\n\n    if (tenantId) {\n      sessionsQuery = sessionsQuery.eq('tenant_id', tenantId);\n    }\n\n    const { count: activeSessions } = await sessionsQuery;\n\n    return {\n      total_memories: totalMemories || 0,\n      active_sessions: activeSessions || 0,\n      backend: 'supabase',\n      vector_backend: this.config.vectorBackend,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Close connection\n   */\n  async close(): Promise<void> {\n    // Supabase client doesn't need explicit closing\n    console.log('‚úÖ Supabase connection closed');\n  }\n}\n\n/**\n * Create Supabase adapter from environment variables\n */\nexport function createSupabaseAdapter(): SupabaseFederationAdapter {\n  const url = process.env.SUPABASE_URL;\n  const anonKey = process.env.SUPABASE_ANON_KEY;\n  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n  if (!url || !anonKey) {\n    throw new Error(\n      'Missing Supabase credentials. Set SUPABASE_URL and SUPABASE_ANON_KEY'\n    );\n  }\n\n  return new SupabaseFederationAdapter({\n    url,\n    anonKey,\n    serviceRoleKey,\n    vectorBackend: (process.env.FEDERATION_VECTOR_BACKEND as any) || 'hybrid',\n    syncInterval: parseInt(process.env.FEDERATION_SYNC_INTERVAL || '60000'),\n  });\n}\n"]}