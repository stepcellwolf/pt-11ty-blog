{"version":3,"file":"FederationHubServer.js","sourceRoot":"","sources":["../../src/federation/FederationHubServer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Federation Hub Server - WebSocket-based hub for agent synchronization\n *\n * This is a production-ready implementation using WebSocket (HTTP/2 upgrade)\n * as a fallback until native QUIC is implemented.\n */\n\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { createServer } from 'http';\nimport { logger } from '../utils/logger.js';\nimport Database from 'better-sqlite3';\n// AgentDB is optional - federation works with SQLite only\ntype AgentDB = any;\n\nexport interface HubConfig {\n  port?: number;\n  dbPath?: string;\n  maxAgents?: number;\n  syncInterval?: number;\n}\n\nexport interface AgentConnection {\n  ws: WebSocket;\n  agentId: string;\n  tenantId: string;\n  connectedAt: number;\n  lastSyncAt: number;\n  vectorClock: Record<string, number>;\n}\n\nexport interface SyncMessage {\n  type: 'auth' | 'pull' | 'push' | 'ack' | 'error';\n  agentId?: string;\n  tenantId?: string;\n  token?: string;\n  vectorClock?: Record<string, number>;\n  data?: any[];\n  error?: string;\n  timestamp: number;\n}\n\nexport class FederationHubServer {\n  private config: HubConfig;\n  private wss?: WebSocketServer;\n  private server?: ReturnType<typeof createServer>;\n  private connections: Map<string, AgentConnection> = new Map();\n  private db: Database.Database;\n  private agentDB: AgentDB;\n  private globalVectorClock: Record<string, number> = {};\n\n  constructor(config: HubConfig) {\n    this.config = {\n      port: 8443,\n      dbPath: ':memory:',\n      maxAgents: 1000,\n      syncInterval: 5000,\n      ...config\n    };\n\n    // Initialize hub database (SQLite for metadata)\n    this.db = new Database(this.config.dbPath!);\n    this.initializeDatabase();\n\n    // AgentDB integration optional - using SQLite for now\n    this.agentDB = null as any;\n    logger.info('Federation hub initialized with SQLite');\n  }\n\n  /**\n   * Initialize hub database schema\n   */\n  private initializeDatabase(): void {\n    // Memory store: tenant-isolated episodes\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS episodes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        tenant_id TEXT NOT NULL,\n        agent_id TEXT NOT NULL,\n        session_id TEXT NOT NULL,\n        task TEXT NOT NULL,\n        input TEXT NOT NULL,\n        output TEXT NOT NULL,\n        reward REAL NOT NULL,\n        critique TEXT,\n        success INTEGER NOT NULL,\n        tokens_used INTEGER DEFAULT 0,\n        latency_ms INTEGER DEFAULT 0,\n        vector_clock TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        UNIQUE(tenant_id, agent_id, session_id, task)\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_episodes_tenant ON episodes(tenant_id);\n      CREATE INDEX IF NOT EXISTS idx_episodes_task ON episodes(tenant_id, task);\n      CREATE INDEX IF NOT EXISTS idx_episodes_created ON episodes(created_at);\n\n      -- Change log for sync\n      CREATE TABLE IF NOT EXISTS change_log (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        tenant_id TEXT NOT NULL,\n        agent_id TEXT NOT NULL,\n        operation TEXT NOT NULL,\n        episode_id INTEGER,\n        vector_clock TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        FOREIGN KEY(episode_id) REFERENCES episodes(id)\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_changes_tenant ON change_log(tenant_id);\n      CREATE INDEX IF NOT EXISTS idx_changes_created ON change_log(created_at);\n\n      -- Agent registry\n      CREATE TABLE IF NOT EXISTS agents (\n        agent_id TEXT PRIMARY KEY,\n        tenant_id TEXT NOT NULL,\n        connected_at INTEGER NOT NULL,\n        last_sync_at INTEGER NOT NULL,\n        vector_clock TEXT NOT NULL\n      );\n    `);\n\n    logger.info('Federation hub database initialized');\n  }\n\n  /**\n   * Start the hub server\n   */\n  async start(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Create HTTP server\n        this.server = createServer();\n\n        // Create WebSocket server\n        this.wss = new WebSocketServer({ server: this.server });\n\n        // Handle connections\n        this.wss.on('connection', (ws: WebSocket) => {\n          this.handleConnection(ws);\n        });\n\n        // Start listening\n        this.server.listen(this.config.port, () => {\n          logger.info('Federation hub server started', {\n            port: this.config.port,\n            protocol: 'WebSocket',\n            maxAgents: this.config.maxAgents\n          });\n          resolve();\n        });\n\n        // Error handling\n        this.server.on('error', (error) => {\n          logger.error('Hub server error', { error: error.message });\n          reject(error);\n        });\n\n      } catch (error: any) {\n        logger.error('Failed to start hub server', { error: error.message });\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Handle new agent connection\n   */\n  private handleConnection(ws: WebSocket): void {\n    let agentId: string | undefined;\n    let tenantId: string | undefined;\n    let authenticated = false;\n\n    logger.info('New connection attempt');\n\n    ws.on('message', async (data: Buffer) => {\n      try {\n        const message: SyncMessage = JSON.parse(data.toString());\n\n        // Authentication required first\n        if (!authenticated && message.type !== 'auth') {\n          this.sendError(ws, 'Authentication required');\n          ws.close();\n          return;\n        }\n\n        switch (message.type) {\n          case 'auth':\n            const authResult = await this.handleAuth(ws, message);\n            if (authResult) {\n              agentId = authResult.agentId;\n              tenantId = authResult.tenantId;\n              authenticated = true;\n\n              // Register connection\n              this.connections.set(agentId, {\n                ws,\n                agentId,\n                tenantId,\n                connectedAt: Date.now(),\n                lastSyncAt: Date.now(),\n                vectorClock: message.vectorClock || {}\n              });\n\n              logger.info('Agent authenticated', { agentId, tenantId });\n            }\n            break;\n\n          case 'pull':\n            if (agentId && tenantId) {\n              await this.handlePull(ws, agentId, tenantId, message);\n            }\n            break;\n\n          case 'push':\n            if (agentId && tenantId) {\n              await this.handlePush(ws, agentId, tenantId, message);\n            }\n            break;\n\n          default:\n            this.sendError(ws, `Unknown message type: ${message.type}`);\n        }\n\n      } catch (error: any) {\n        logger.error('Message handling error', { error: error.message });\n        this.sendError(ws, error.message);\n      }\n    });\n\n    ws.on('close', () => {\n      if (agentId) {\n        this.connections.delete(agentId);\n        logger.info('Agent disconnected', { agentId, tenantId });\n      }\n    });\n\n    ws.on('error', (error) => {\n      logger.error('WebSocket error', { error: error.message, agentId });\n    });\n  }\n\n  /**\n   * Handle authentication\n   */\n  private async handleAuth(\n    ws: WebSocket,\n    message: SyncMessage\n  ): Promise<{ agentId: string; tenantId: string } | null> {\n    if (!message.agentId || !message.tenantId || !message.token) {\n      this.sendError(ws, 'Missing authentication credentials');\n      return null;\n    }\n\n    // TODO: Verify JWT token (for now, accept all)\n    // In production, verify JWT signature and expiration\n\n    // Register agent\n    this.db.prepare(`\n      INSERT OR REPLACE INTO agents (agent_id, tenant_id, connected_at, last_sync_at, vector_clock)\n      VALUES (?, ?, ?, ?, ?)\n    `).run(\n      message.agentId,\n      message.tenantId,\n      Date.now(),\n      Date.now(),\n      JSON.stringify(message.vectorClock || {})\n    );\n\n    // Send acknowledgment\n    this.send(ws, {\n      type: 'ack',\n      timestamp: Date.now()\n    });\n\n    return {\n      agentId: message.agentId,\n      tenantId: message.tenantId\n    };\n  }\n\n  /**\n   * Handle pull request (agent wants updates from hub)\n   */\n  private async handlePull(\n    ws: WebSocket,\n    agentId: string,\n    tenantId: string,\n    message: SyncMessage\n  ): Promise<void> {\n    const conn = this.connections.get(agentId);\n    if (!conn) {\n      this.sendError(ws, 'Agent not connected');\n      return;\n    }\n\n    // Get changes since agent's last vector clock\n    const changes = await this.getChangesSince(tenantId, message.vectorClock || {});\n\n    // Update last sync time\n    conn.lastSyncAt = Date.now();\n\n    // Send changes to agent\n    this.send(ws, {\n      type: 'ack',\n      data: changes,\n      vectorClock: this.globalVectorClock,\n      timestamp: Date.now()\n    });\n\n    logger.info('Pull completed', {\n      agentId,\n      tenantId,\n      changeCount: changes.length\n    });\n  }\n\n  /**\n   * Handle push request (agent sending updates to hub)\n   */\n  private async handlePush(\n    ws: WebSocket,\n    agentId: string,\n    tenantId: string,\n    message: SyncMessage\n  ): Promise<void> {\n    const conn = this.connections.get(agentId);\n    if (!conn) {\n      this.sendError(ws, 'Agent not connected');\n      return;\n    }\n\n    if (!message.data || message.data.length === 0) {\n      this.send(ws, { type: 'ack', timestamp: Date.now() });\n      return;\n    }\n\n    // Store episodes in both SQLite (metadata) and AgentDB (vector memory)\n    const stmt = this.db.prepare(`\n      INSERT OR REPLACE INTO episodes\n      (tenant_id, agent_id, session_id, task, input, output, reward, critique, success, tokens_used, latency_ms, vector_clock, created_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const changeStmt = this.db.prepare(`\n      INSERT INTO change_log (tenant_id, agent_id, operation, episode_id, vector_clock, created_at)\n      VALUES (?, ?, 'insert', last_insert_rowid(), ?, ?)\n    `);\n\n    let insertCount = 0;\n\n    for (const episode of message.data) {\n      try {\n        // Store in SQLite for metadata\n        stmt.run(\n          tenantId,\n          agentId,\n          episode.sessionId || agentId,\n          episode.task,\n          episode.input,\n          episode.output,\n          episode.reward,\n          episode.critique || '',\n          episode.success ? 1 : 0,\n          episode.tokensUsed || 0,\n          episode.latencyMs || 0,\n          JSON.stringify(message.vectorClock),\n          Date.now()\n        );\n\n        changeStmt.run(\n          tenantId,\n          agentId,\n          JSON.stringify(message.vectorClock),\n          Date.now()\n        );\n\n        // Store in AgentDB for vector memory (with tenant isolation)\n        await this.agentDB.storePattern({\n          sessionId: `${tenantId}/${episode.sessionId || agentId}`,\n          task: episode.task,\n          input: episode.input,\n          output: episode.output,\n          reward: episode.reward,\n          critique: episode.critique || '',\n          success: episode.success,\n          tokensUsed: episode.tokensUsed || 0,\n          latencyMs: episode.latencyMs || 0,\n          metadata: {\n            tenantId,\n            agentId,\n            vectorClock: message.vectorClock\n          }\n        });\n\n        insertCount++;\n      } catch (error: any) {\n        logger.error('Failed to insert episode', { error: error.message });\n      }\n    }\n\n    // Update global vector clock\n    if (message.vectorClock) {\n      for (const [agent, ts] of Object.entries(message.vectorClock)) {\n        this.globalVectorClock[agent] = Math.max(\n          this.globalVectorClock[agent] || 0,\n          ts\n        );\n      }\n    }\n\n    // Update connection vector clock\n    conn.vectorClock = { ...this.globalVectorClock };\n    conn.lastSyncAt = Date.now();\n\n    // Send acknowledgment\n    this.send(ws, {\n      type: 'ack',\n      timestamp: Date.now()\n    });\n\n    logger.info('Push completed', {\n      agentId,\n      tenantId,\n      episodeCount: insertCount\n    });\n\n    // Broadcast to other agents in same tenant (optional real-time sync)\n    this.broadcastToTenant(tenantId, agentId, {\n      type: 'push',\n      agentId,\n      data: message.data,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Get changes since a given vector clock\n   * Returns memories from other agents in the same tenant\n   */\n  private async getChangesSince(\n    tenantId: string,\n    vectorClock: Record<string, number>\n  ): Promise<any[]> {\n    // Get all episodes for tenant from SQLite\n    const episodes = this.db.prepare(`\n      SELECT * FROM episodes\n      WHERE tenant_id = ?\n      ORDER BY created_at DESC\n      LIMIT 100\n    `).all(tenantId);\n\n    return episodes.map((row: any) => ({\n      id: row.id,\n      agentId: row.agent_id,\n      sessionId: row.session_id,\n      task: row.task,\n      input: row.input,\n      output: row.output,\n      reward: row.reward,\n      critique: row.critique,\n      success: row.success === 1,\n      tokensUsed: row.tokens_used,\n      latencyMs: row.latency_ms,\n      vectorClock: JSON.parse(row.vector_clock),\n      createdAt: row.created_at\n    }));\n  }\n\n  /**\n   * Broadcast message to all agents in a tenant (except sender)\n   */\n  private broadcastToTenant(\n    tenantId: string,\n    senderAgentId: string,\n    message: SyncMessage\n  ): void {\n    let broadcastCount = 0;\n\n    for (const [agentId, conn] of this.connections.entries()) {\n      if (conn.tenantId === tenantId && agentId !== senderAgentId) {\n        this.send(conn.ws, message);\n        broadcastCount++;\n      }\n    }\n\n    if (broadcastCount > 0) {\n      logger.debug('Broadcasted to tenant agents', {\n        tenantId,\n        recipientCount: broadcastCount\n      });\n    }\n  }\n\n  /**\n   * Send message to WebSocket\n   */\n  private send(ws: WebSocket, message: SyncMessage): void {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(message));\n    }\n  }\n\n  /**\n   * Send error message\n   */\n  private sendError(ws: WebSocket, error: string): void {\n    this.send(ws, {\n      type: 'error',\n      error,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Get hub statistics\n   */\n  getStats(): {\n    connectedAgents: number;\n    totalEpisodes: number;\n    tenants: number;\n    uptime: number;\n  } {\n    const totalEpisodes = this.db.prepare('SELECT COUNT(*) as count FROM episodes').get() as any;\n    const tenants = this.db.prepare('SELECT COUNT(DISTINCT tenant_id) as count FROM episodes').get() as any;\n\n    return {\n      connectedAgents: this.connections.size,\n      totalEpisodes: totalEpisodes.count,\n      tenants: tenants.count,\n      uptime: process.uptime()\n    };\n  }\n\n  /**\n   * Stop the hub server\n   */\n  async stop(): Promise<void> {\n    logger.info('Stopping federation hub server');\n\n    // Close all connections\n    for (const [agentId, conn] of this.connections.entries()) {\n      conn.ws.close();\n    }\n    this.connections.clear();\n\n    // Close WebSocket server\n    if (this.wss) {\n      this.wss.close();\n    }\n\n    // Close HTTP server\n    if (this.server) {\n      this.server.close();\n    }\n\n    // Close databases\n    this.db.close();\n    await this.agentDB.close();\n\n    logger.info('Federation hub server stopped');\n  }\n\n  /**\n   * Query patterns from AgentDB with tenant isolation\n   */\n  async queryPatterns(tenantId: string, task: string, k: number = 5): Promise<any[]> {\n    try {\n      const results = await this.agentDB.searchPatterns({\n        task,\n        k,\n        minReward: 0.0\n      });\n\n      // Filter by tenant (session ID contains tenant prefix)\n      return results.filter((r: any) =>\n        r.sessionId?.startsWith(`${tenantId}/`)\n      );\n    } catch (error: any) {\n      logger.error('Pattern query failed', { error: error.message });\n      return [];\n    }\n  }\n}\n"]}