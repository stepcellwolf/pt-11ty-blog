{"version":3,"sources":["../../../src/memory/shared-memory.js"],"sourcesContent":["/**\n * SharedMemory - Unified memory persistence module for ruv-swarm\n * Supports both .swarm/ and .hive-mind/ directories with SQLite backend\n *\n * @module shared-memory\n */\n\nimport Database from 'better-sqlite3';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { EventEmitter } from 'events';\nimport { performance } from 'perf_hooks';\nimport { getProjectRoot, getSwarmDir, getHiveMindDir } from '../utils/project-root.js';\n\n/**\n * Migration definitions for schema evolution\n */\nconst MIGRATIONS = [\n  {\n    version: 1,\n    description: 'Initial schema',\n    sql: `\n      -- Memory store table\n      CREATE TABLE IF NOT EXISTS memory_store (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        key TEXT NOT NULL,\n        namespace TEXT NOT NULL DEFAULT 'default',\n        value TEXT NOT NULL,\n        type TEXT NOT NULL DEFAULT 'json',\n        metadata TEXT,\n        created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n        updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n        accessed_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n        access_count INTEGER NOT NULL DEFAULT 0,\n        ttl INTEGER,\n        expires_at INTEGER,\n        compressed INTEGER DEFAULT 0,\n        size INTEGER NOT NULL DEFAULT 0,\n        UNIQUE(key, namespace)\n      );\n      \n      -- Metadata table for system information\n      CREATE TABLE IF NOT EXISTS metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))\n      );\n      \n      -- Migrations tracking table\n      CREATE TABLE IF NOT EXISTS migrations (\n        version INTEGER PRIMARY KEY,\n        description TEXT,\n        applied_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))\n      );\n      \n      -- Performance indexes\n      CREATE INDEX IF NOT EXISTS idx_memory_namespace ON memory_store(namespace);\n      CREATE INDEX IF NOT EXISTS idx_memory_expires ON memory_store(expires_at) WHERE expires_at IS NOT NULL;\n      CREATE INDEX IF NOT EXISTS idx_memory_accessed ON memory_store(accessed_at);\n      CREATE INDEX IF NOT EXISTS idx_memory_key_namespace ON memory_store(key, namespace);\n      \n      -- Insert initial metadata\n      INSERT OR IGNORE INTO metadata (key, value) VALUES \n        ('version', '1.0.0'),\n        ('created_at', strftime('%s', 'now'));\n    `,\n  },\n  {\n    version: 2,\n    description: 'Add tags and search capabilities',\n    sql: `\n      -- Add tags column\n      ALTER TABLE memory_store ADD COLUMN tags TEXT;\n      \n      -- Create tags index for faster searching\n      CREATE INDEX IF NOT EXISTS idx_memory_tags ON memory_store(tags) WHERE tags IS NOT NULL;\n      \n      -- Update version\n      UPDATE metadata SET value = '1.1.0', updated_at = strftime('%s', 'now') WHERE key = 'version';\n    `,\n  },\n];\n\n/**\n * High-performance LRU cache implementation\n */\nclass LRUCache {\n  constructor(maxSize = 1000, maxMemoryMB = 50) {\n    this.maxSize = maxSize;\n    this.maxMemory = maxMemoryMB * 1024 * 1024;\n    this.cache = new Map();\n    this.currentMemory = 0;\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  get(key) {\n    if (this.cache.has(key)) {\n      const value = this.cache.get(key);\n      // Move to end (most recently used)\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      this.hits++;\n      return value.data;\n    }\n    this.misses++;\n    return null;\n  }\n\n  set(key, data, size = 0) {\n    // Estimate size if not provided\n    if (!size) {\n      size = this._estimateSize(data);\n    }\n\n    // Handle memory pressure\n    while (this.currentMemory + size > this.maxMemory && this.cache.size > 0) {\n      this._evictLRU();\n    }\n\n    // Handle size limit\n    while (this.cache.size >= this.maxSize) {\n      this._evictLRU();\n    }\n\n    this.cache.set(key, { data, size, timestamp: Date.now() });\n    this.currentMemory += size;\n  }\n\n  delete(key) {\n    const entry = this.cache.get(key);\n    if (entry) {\n      this.currentMemory -= entry.size;\n      return this.cache.delete(key);\n    }\n    return false;\n  }\n\n  clear() {\n    this.cache.clear();\n    this.currentMemory = 0;\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      size: this.cache.size,\n      memoryUsage: this.currentMemory,\n      memoryUsageMB: this.currentMemory / (1024 * 1024),\n      hitRate: total > 0 ? (this.hits / total) * 100 : 0,\n      evictions: this.evictions,\n      utilizationPercent: (this.currentMemory / this.maxMemory) * 100,\n    };\n  }\n\n  _estimateSize(data) {\n    try {\n      return JSON.stringify(data).length * 2; // UTF-16 estimate\n    } catch {\n      return 1000; // Default for non-serializable\n    }\n  }\n\n  _evictLRU() {\n    const firstKey = this.cache.keys().next().value;\n    if (firstKey !== undefined) {\n      const entry = this.cache.get(firstKey);\n      this.cache.delete(firstKey);\n      this.currentMemory -= entry.size;\n      this.evictions++;\n    }\n  }\n}\n\n/**\n * SharedMemory class - Core implementation\n */\nexport class SharedMemory extends EventEmitter {\n  constructor(options = {}) {\n    super();\n\n    this.options = {\n      directory: options.directory || '.hive-mind',\n      filename: options.filename || 'memory.db',\n      cacheSize: options.cacheSize || 1000,\n      cacheMemoryMB: options.cacheMemoryMB || 50,\n      compressionThreshold: options.compressionThreshold || 10240, // 10KB\n      gcInterval: options.gcInterval || 300000, // 5 minutes\n      enableWAL: options.enableWAL !== false,\n      enableVacuum: options.enableVacuum !== false,\n      ...options,\n    };\n\n    this.db = null;\n    this.cache = new LRUCache(this.options.cacheSize, this.options.cacheMemoryMB);\n    this.statements = new Map();\n    this.gcTimer = null;\n    this.isInitialized = false;\n\n    // Performance tracking\n    this.metrics = {\n      operations: new Map(),\n      lastGC: Date.now(),\n      totalOperations: 0,\n    };\n  }\n\n  /**\n   * Initialize the database and run migrations\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n\n    const startTime = performance.now();\n\n    try {\n      // Ensure directory exists\n      const projectRoot = getProjectRoot();\n      const fullDirPath = path.join(projectRoot, this.options.directory);\n      await fs.mkdir(fullDirPath, { recursive: true });\n\n      // Open database\n      const dbPath = path.join(fullDirPath, this.options.filename);\n      this.db = new Database(dbPath);\n\n      // Configure for performance\n      this._configureDatabase();\n\n      // Run migrations\n      await this._runMigrations();\n\n      // Prepare statements\n      this._prepareStatements();\n\n      // Start garbage collection\n      this._startGarbageCollection();\n\n      this.isInitialized = true;\n\n      const duration = performance.now() - startTime;\n      this._recordMetric('initialize', duration);\n\n      this.emit('initialized', { dbPath, duration });\n    } catch (error) {\n      this.emit('error', error);\n      throw new Error(`Failed to initialize SharedMemory: ${error.message}`);\n    }\n  }\n\n  /**\n   * Store a value in memory\n   */\n  async store(key, value, options = {}) {\n    this._ensureInitialized();\n\n    const startTime = performance.now();\n\n    try {\n      const namespace = options.namespace || 'default';\n      const ttl = options.ttl;\n      const tags = options.tags ? JSON.stringify(options.tags) : null;\n      const metadata = options.metadata ? JSON.stringify(options.metadata) : null;\n\n      // Serialize value\n      let serialized = value;\n      let type = 'string';\n      let compressed = 0;\n\n      if (typeof value !== 'string') {\n        serialized = JSON.stringify(value);\n        type = 'json';\n      }\n\n      const size = Buffer.byteLength(serialized);\n\n      // Compress if needed\n      if (size > this.options.compressionThreshold) {\n        // In production, use proper compression\n        compressed = 1;\n      }\n\n      // Calculate expiry\n      const expiresAt = ttl ? Math.floor(Date.now() / 1000) + ttl : null;\n\n      // Store in database\n      this.statements\n        .get('upsert')\n        .run(key, namespace, serialized, type, metadata, tags, ttl, expiresAt, compressed, size);\n\n      // Update cache\n      const cacheKey = this._getCacheKey(key, namespace);\n      this.cache.set(cacheKey, value, size);\n\n      const duration = performance.now() - startTime;\n      this._recordMetric('store', duration);\n\n      this.emit('stored', { key, namespace, size, compressed: !!compressed });\n\n      return { success: true, key, namespace, size };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve a value from memory\n   */\n  async retrieve(key, namespace = 'default') {\n    this._ensureInitialized();\n\n    const startTime = performance.now();\n\n    try {\n      // Check cache first\n      const cacheKey = this._getCacheKey(key, namespace);\n      const cached = this.cache.get(cacheKey);\n\n      if (cached !== null) {\n        this._recordMetric('retrieve_cache', performance.now() - startTime);\n        return cached;\n      }\n\n      // Get from database\n      const row = this.statements.get('select').get(key, namespace);\n\n      if (!row) {\n        this._recordMetric('retrieve_miss', performance.now() - startTime);\n        return null;\n      }\n\n      // Check expiry\n      if (row.expires_at && row.expires_at < Math.floor(Date.now() / 1000)) {\n        // Delete expired entry\n        this.statements.get('delete').run(key, namespace);\n        this._recordMetric('retrieve_expired', performance.now() - startTime);\n        return null;\n      }\n\n      // Update access stats\n      this.statements.get('updateAccess').run(key, namespace);\n\n      // Deserialize value\n      let value = row.value;\n      if (row.type === 'json') {\n        value = JSON.parse(value);\n      }\n\n      // Update cache\n      this.cache.set(cacheKey, value, row.size);\n\n      const duration = performance.now() - startTime;\n      this._recordMetric('retrieve_db', duration);\n\n      return value;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List entries in a namespace\n   */\n  async list(namespace = 'default', options = {}) {\n    this._ensureInitialized();\n\n    const limit = options.limit || 100;\n    const offset = options.offset || 0;\n\n    try {\n      const rows = this.statements.get('list').all(namespace, limit, offset);\n\n      return rows.map((row) => ({\n        key: row.key,\n        namespace: row.namespace,\n        type: row.type,\n        size: row.size,\n        compressed: !!row.compressed,\n        tags: row.tags ? JSON.parse(row.tags) : [],\n        createdAt: new Date(row.created_at * 1000),\n        updatedAt: new Date(row.updated_at * 1000),\n        accessedAt: new Date(row.accessed_at * 1000),\n        accessCount: row.access_count,\n        expiresAt: row.expires_at ? new Date(row.expires_at * 1000) : null,\n      }));\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an entry\n   */\n  async delete(key, namespace = 'default') {\n    this._ensureInitialized();\n\n    try {\n      // Remove from cache\n      const cacheKey = this._getCacheKey(key, namespace);\n      this.cache.delete(cacheKey);\n\n      // Remove from database\n      const result = this.statements.get('delete').run(key, namespace);\n\n      if (result.changes > 0) {\n        this.emit('deleted', { key, namespace });\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all entries in a namespace\n   */\n  async clear(namespace = 'default') {\n    this._ensureInitialized();\n\n    try {\n      // Clear cache entries for namespace\n      for (const [key] of this.cache.cache) {\n        if (key.startsWith(`${namespace}:`)) {\n          this.cache.delete(key);\n        }\n      }\n\n      // Clear database entries\n      const result = this.statements.get('clearNamespace').run(namespace);\n\n      this.emit('cleared', { namespace, count: result.changes });\n\n      return { cleared: result.changes };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get statistics\n   */\n  async getStats() {\n    this._ensureInitialized();\n\n    try {\n      const dbStats = this.statements.get('stats').all();\n      const cacheStats = this.cache.getStats();\n\n      // Transform database stats\n      const namespaceStats = {};\n      for (const row of dbStats) {\n        namespaceStats[row.namespace] = {\n          count: row.count,\n          totalSize: row.total_size,\n          avgSize: row.avg_size,\n          compressed: row.compressed_count,\n        };\n      }\n\n      return {\n        namespaces: namespaceStats,\n        cache: cacheStats,\n        metrics: this._getMetricsSummary(),\n        database: {\n          totalEntries: Object.values(namespaceStats).reduce((sum, ns) => sum + ns.count, 0),\n          totalSize: Object.values(namespaceStats).reduce((sum, ns) => sum + ns.totalSize, 0),\n        },\n      };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search entries by pattern or tags\n   */\n  async search(options = {}) {\n    this._ensureInitialized();\n\n    const { pattern, namespace, tags, limit = 50, offset = 0 } = options;\n\n    try {\n      let query = 'SELECT * FROM memory_store WHERE 1=1';\n      const params = [];\n\n      if (namespace) {\n        query += ' AND namespace = ?';\n        params.push(namespace);\n      }\n\n      if (pattern) {\n        query += ' AND key LIKE ?';\n        params.push(`%${pattern}%`);\n      }\n\n      if (tags && tags.length > 0) {\n        // Simple tag search - in production, use JSON functions\n        query += ' AND tags IS NOT NULL';\n      }\n\n      query += ' ORDER BY accessed_at DESC LIMIT ? OFFSET ?';\n      params.push(limit, offset);\n\n      const stmt = this.db.prepare(query);\n      const rows = stmt.all(...params);\n\n      return rows.map((row) => ({\n        key: row.key,\n        namespace: row.namespace,\n        value: row.type === 'json' ? JSON.parse(row.value) : row.value,\n        metadata: row.metadata ? JSON.parse(row.metadata) : null,\n        tags: row.tags ? JSON.parse(row.tags) : [],\n      }));\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Backup the database\n   */\n  async backup(filepath) {\n    this._ensureInitialized();\n\n    try {\n      await this.db.backup(filepath);\n      this.emit('backup', { filepath });\n      return { success: true, filepath };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Close the database connection\n   */\n  async close() {\n    if (!this.isInitialized) return;\n\n    try {\n      // Stop garbage collection\n      if (this.gcTimer) {\n        clearInterval(this.gcTimer);\n        this.gcTimer = null;\n      }\n\n      // Final optimization\n      if (this.options.enableVacuum) {\n        this.db.pragma('optimize');\n      }\n\n      // Close statements\n      for (const stmt of this.statements.values()) {\n        stmt.finalize();\n      }\n      this.statements.clear();\n\n      // Close database\n      this.db.close();\n      this.db = null;\n\n      // Clear cache\n      this.cache.clear();\n\n      this.isInitialized = false;\n\n      this.emit('closed');\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n\n  _ensureInitialized() {\n    if (!this.isInitialized) {\n      throw new Error('SharedMemory not initialized. Call initialize() first.');\n    }\n  }\n\n  _configureDatabase() {\n    // Performance optimizations\n    if (this.options.enableWAL) {\n      this.db.pragma('journal_mode = WAL');\n    }\n    this.db.pragma('synchronous = NORMAL');\n    this.db.pragma('cache_size = -64000'); // 64MB\n    this.db.pragma('temp_store = MEMORY');\n    this.db.pragma('mmap_size = 268435456'); // 256MB\n  }\n\n  _runMigrations() {\n    // Create migrations table if needed\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS migrations (\n        version INTEGER PRIMARY KEY,\n        description TEXT,\n        applied_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))\n      )\n    `);\n\n    // Get current version\n    const currentVersion =\n      this.db.prepare('SELECT MAX(version) as version FROM migrations').get().version || 0;\n\n    // Run pending migrations\n    const pending = MIGRATIONS.filter((m) => m.version > currentVersion);\n\n    if (pending.length > 0) {\n      const transaction = this.db.transaction((migrations) => {\n        for (const migration of migrations) {\n          this.db.exec(migration.sql);\n          this.db\n            .prepare('INSERT INTO migrations (version, description) VALUES (?, ?)')\n            .run(migration.version, migration.description);\n        }\n      });\n\n      transaction(pending);\n      this.emit('migrated', { from: currentVersion, to: pending[pending.length - 1].version });\n    }\n  }\n\n  _prepareStatements() {\n    // Upsert statement\n    this.statements.set(\n      'upsert',\n      this.db.prepare(`\n      INSERT INTO memory_store (key, namespace, value, type, metadata, tags, ttl, expires_at, compressed, size)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      ON CONFLICT(key, namespace) DO UPDATE SET\n        value = excluded.value,\n        type = excluded.type,\n        metadata = excluded.metadata,\n        tags = excluded.tags,\n        ttl = excluded.ttl,\n        expires_at = excluded.expires_at,\n        compressed = excluded.compressed,\n        size = excluded.size,\n        updated_at = strftime('%s', 'now'),\n        access_count = memory_store.access_count + 1\n    `),\n    );\n\n    // Select statement\n    this.statements.set(\n      'select',\n      this.db.prepare(`\n      SELECT * FROM memory_store WHERE key = ? AND namespace = ?\n    `),\n    );\n\n    // Update access statement\n    this.statements.set(\n      'updateAccess',\n      this.db.prepare(`\n      UPDATE memory_store \n      SET accessed_at = strftime('%s', 'now'), access_count = access_count + 1\n      WHERE key = ? AND namespace = ?\n    `),\n    );\n\n    // Delete statement\n    this.statements.set(\n      'delete',\n      this.db.prepare(`\n      DELETE FROM memory_store WHERE key = ? AND namespace = ?\n    `),\n    );\n\n    // List statement\n    this.statements.set(\n      'list',\n      this.db.prepare(`\n      SELECT * FROM memory_store \n      WHERE namespace = ? \n      ORDER BY accessed_at DESC \n      LIMIT ? OFFSET ?\n    `),\n    );\n\n    // Clear namespace statement\n    this.statements.set(\n      'clearNamespace',\n      this.db.prepare(`\n      DELETE FROM memory_store WHERE namespace = ?\n    `),\n    );\n\n    // Stats statement\n    this.statements.set(\n      'stats',\n      this.db.prepare(`\n      SELECT \n        namespace,\n        COUNT(*) as count,\n        SUM(size) as total_size,\n        AVG(size) as avg_size,\n        SUM(compressed) as compressed_count\n      FROM memory_store\n      GROUP BY namespace\n    `),\n    );\n\n    // Garbage collection statement\n    this.statements.set(\n      'gc',\n      this.db.prepare(`\n      DELETE FROM memory_store \n      WHERE expires_at IS NOT NULL AND expires_at < strftime('%s', 'now')\n    `),\n    );\n  }\n\n  _startGarbageCollection() {\n    this.gcTimer = setInterval(() => {\n      this._runGarbageCollection();\n    }, this.options.gcInterval);\n  }\n\n  _runGarbageCollection() {\n    try {\n      const result = this.statements.get('gc').run();\n\n      if (result.changes > 0) {\n        this.emit('gc', { expired: result.changes });\n      }\n\n      this.metrics.lastGC = Date.now();\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  _getCacheKey(key, namespace) {\n    return `${namespace}:${key}`;\n  }\n\n  _recordMetric(operation, duration) {\n    if (!this.metrics.operations.has(operation)) {\n      this.metrics.operations.set(operation, []);\n    }\n\n    const metrics = this.metrics.operations.get(operation);\n    metrics.push(duration);\n\n    // Keep only last 100 measurements\n    if (metrics.length > 100) {\n      metrics.shift();\n    }\n\n    this.metrics.totalOperations++;\n  }\n\n  _getMetricsSummary() {\n    const summary = {};\n\n    for (const [operation, durations] of this.metrics.operations) {\n      if (durations.length > 0) {\n        summary[operation] = {\n          count: durations.length,\n          avg: durations.reduce((a, b) => a + b, 0) / durations.length,\n          min: Math.min(...durations),\n          max: Math.max(...durations),\n        };\n      }\n    }\n\n    summary.totalOperations = this.metrics.totalOperations;\n    summary.lastGC = new Date(this.metrics.lastGC).toISOString();\n\n    return summary;\n  }\n}\n\n// Export for backwards compatibility\nexport default SharedMemory;\n"],"names":["Database","path","fs","EventEmitter","performance","getProjectRoot","MIGRATIONS","version","description","sql","LRUCache","maxSize","maxMemoryMB","maxMemory","cache","Map","currentMemory","hits","misses","evictions","get","key","has","value","delete","set","data","size","_estimateSize","_evictLRU","timestamp","Date","now","entry","clear","getStats","total","memoryUsage","memoryUsageMB","hitRate","utilizationPercent","JSON","stringify","length","firstKey","keys","next","undefined","SharedMemory","options","directory","filename","cacheSize","cacheMemoryMB","compressionThreshold","gcInterval","enableWAL","enableVacuum","db","statements","gcTimer","isInitialized","metrics","operations","lastGC","totalOperations","initialize","startTime","projectRoot","fullDirPath","join","mkdir","recursive","dbPath","_configureDatabase","_runMigrations","_prepareStatements","_startGarbageCollection","duration","_recordMetric","emit","error","Error","message","store","_ensureInitialized","namespace","ttl","tags","metadata","serialized","type","compressed","Buffer","byteLength","expiresAt","Math","floor","run","cacheKey","_getCacheKey","success","retrieve","cached","row","expires_at","parse","list","limit","offset","rows","all","map","createdAt","created_at","updatedAt","updated_at","accessedAt","accessed_at","accessCount","access_count","result","changes","startsWith","count","cleared","dbStats","cacheStats","namespaceStats","totalSize","total_size","avgSize","avg_size","compressed_count","namespaces","_getMetricsSummary","database","totalEntries","Object","values","reduce","sum","ns","search","pattern","query","params","push","stmt","prepare","backup","filepath","close","clearInterval","pragma","finalize","exec","currentVersion","pending","filter","m","transaction","migrations","migration","from","to","setInterval","_runGarbageCollection","expired","operation","shift","summary","durations","avg","a","b","min","max","toISOString"],"mappings":"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"}