{"version":3,"sources":["../../../../src/memory/backends/sqlite.ts"],"sourcesContent":["/**\n * SQLite backend implementation for memory storage\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport type { IMemoryBackend } from './base.js';\nimport type { MemoryEntry, MemoryQuery } from '../../utils/types.js';\nimport type { ILogger } from '../../core/logger.js';\nimport { MemoryBackendError } from '../../utils/errors.js';\n\n// Dynamic imports for SQLite\nlet createDatabase: any;\nlet isSQLiteAvailable: any;\n\n/**\n * SQLite-based memory backend\n */\nexport class SQLiteBackend implements IMemoryBackend {\n  private db?: any;\n  private sqliteLoaded: boolean = false;\n\n  constructor(\n    private dbPath: string,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing SQLite backend', { dbPath: this.dbPath });\n\n    try {\n      // Load SQLite wrapper if not loaded\n      if (!this.sqliteLoaded) {\n        const module = await import('../sqlite-wrapper.js');\n        createDatabase = module.createDatabase;\n        isSQLiteAvailable = module.isSQLiteAvailable;\n        this.sqliteLoaded = true;\n      }\n\n      // Check if SQLite is available\n      const sqliteAvailable = await isSQLiteAvailable();\n      if (!sqliteAvailable) {\n        throw new Error('SQLite module not available');\n      }\n\n      // Ensure directory exists\n      const dir = path.dirname(this.dbPath);\n      await fs.mkdir(dir, { recursive: true });\n\n      // Open SQLite connection\n      this.db = await createDatabase(this.dbPath);\n\n      // Enable WAL mode for better performance\n      this.db.pragma('journal_mode = WAL');\n      this.db.pragma('synchronous = NORMAL');\n      this.db.pragma('cache_size = 1000');\n      this.db.pragma('temp_store = memory');\n\n      // Create tables\n      this.createTables();\n\n      // Create indexes\n      this.createIndexes();\n\n      this.logger.info('SQLite backend initialized');\n    } catch (error) {\n      throw new MemoryBackendError('Failed to initialize SQLite backend', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down SQLite backend');\n\n    if (this.db) {\n      this.db.close();\n      delete this.db;\n    }\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = `\n      INSERT OR REPLACE INTO memory_entries (\n        id, agent_id, session_id, type, content, \n        context, timestamp, tags, version, parent_id, metadata\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    const params = [\n      entry.id,\n      entry.agentId,\n      entry.sessionId,\n      entry.type,\n      entry.content,\n      JSON.stringify(entry.context),\n      entry.timestamp.toISOString(),\n      JSON.stringify(entry.tags),\n      entry.version,\n      entry.parentId || null,\n      entry.metadata ? JSON.stringify(entry.metadata) : null,\n    ];\n\n    try {\n      const stmt = this.db.prepare(sql);\n      stmt.run(...params);\n    } catch (error) {\n      throw new MemoryBackendError('Failed to store entry', { error });\n    }\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = 'SELECT * FROM memory_entries WHERE id = ?';\n\n    try {\n      const stmt = this.db.prepare(sql);\n      const row = stmt.get(id);\n\n      if (!row) {\n        return undefined;\n      }\n\n      return this.rowToEntry(row as Record<string, unknown>);\n    } catch (error) {\n      throw new MemoryBackendError('Failed to retrieve entry', { error });\n    }\n  }\n\n  async update(id: string, entry: MemoryEntry): Promise<void> {\n    // SQLite INSERT OR REPLACE handles updates\n    await this.store(entry);\n  }\n\n  async delete(id: string): Promise<void> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = 'DELETE FROM memory_entries WHERE id = ?';\n\n    try {\n      const stmt = this.db.prepare(sql);\n      stmt.run(id);\n    } catch (error) {\n      throw new MemoryBackendError('Failed to delete entry', { error });\n    }\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const conditions: string[] = [];\n    const params: unknown[] = [];\n\n    if (query.agentId) {\n      conditions.push('agent_id = ?');\n      params.push(query.agentId);\n    }\n\n    if (query.sessionId) {\n      conditions.push('session_id = ?');\n      params.push(query.sessionId);\n    }\n\n    if (query.type) {\n      conditions.push('type = ?');\n      params.push(query.type);\n    }\n\n    if (query.startTime) {\n      conditions.push('timestamp >= ?');\n      params.push(query.startTime.toISOString());\n    }\n\n    if (query.endTime) {\n      conditions.push('timestamp <= ?');\n      params.push(query.endTime.toISOString());\n    }\n\n    if (query.search) {\n      conditions.push('(content LIKE ? OR tags LIKE ?)');\n      params.push(`%${query.search}%`, `%${query.search}%`);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      const tagConditions = query.tags.map(() => 'tags LIKE ?');\n      conditions.push(`(${tagConditions.join(' OR ')})`);\n      query.tags.forEach((tag: string) => params.push(`%\"${tag}\"%`));\n    }\n\n    let sql = 'SELECT * FROM memory_entries';\n    if (conditions.length > 0) {\n      sql += ' WHERE ' + conditions.join(' AND ');\n    }\n\n    sql += ' ORDER BY timestamp DESC';\n\n    if (query.limit) {\n      sql += ' LIMIT ?';\n      params.push(query.limit);\n    }\n\n    if (query.offset) {\n      // SQLite requires LIMIT when using OFFSET\n      if (!query.limit) {\n        sql += ' LIMIT -1'; // -1 means no limit in SQLite\n      }\n      sql += ' OFFSET ?';\n      params.push(query.offset);\n    }\n\n    try {\n      const stmt = this.db.prepare(sql);\n      const rows = stmt.all(...params);\n      return rows.map((row: any) => this.rowToEntry(row as Record<string, unknown>));\n    } catch (error) {\n      throw new MemoryBackendError('Failed to query entries', { error });\n    }\n  }\n\n  async getAllEntries(): Promise<MemoryEntry[]> {\n    if (!this.db) {\n      throw new MemoryBackendError('Database not initialized');\n    }\n\n    const sql = 'SELECT * FROM memory_entries ORDER BY timestamp DESC';\n\n    try {\n      const stmt = this.db.prepare(sql);\n      const rows = stmt.all();\n      return rows.map((row: any) => this.rowToEntry(row as Record<string, unknown>));\n    } catch (error) {\n      throw new MemoryBackendError('Failed to get all entries', { error });\n    }\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    if (!this.db) {\n      return {\n        healthy: false,\n        error: 'Database not initialized',\n      };\n    }\n\n    try {\n      // Check database connectivity\n      this.db.prepare('SELECT 1').get();\n\n      // Get metrics\n      const countResult = this.db\n        .prepare('SELECT COUNT(*) as count FROM memory_entries')\n        .get() as any;\n      const entryCount = countResult.count;\n\n      const sizeResult = this.db\n        .prepare(\n          'SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()',\n        )\n        .get() as any;\n      const dbSize = sizeResult.size;\n\n      return {\n        healthy: true,\n        metrics: {\n          entryCount,\n          dbSizeBytes: dbSize,\n        },\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private createTables(): void {\n    const sql = `\n      CREATE TABLE IF NOT EXISTS memory_entries (\n        id TEXT PRIMARY KEY,\n        agent_id TEXT NOT NULL,\n        session_id TEXT NOT NULL,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        context TEXT NOT NULL,\n        timestamp TEXT NOT NULL,\n        tags TEXT NOT NULL,\n        version INTEGER NOT NULL,\n        parent_id TEXT,\n        metadata TEXT,\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP\n      )\n    `;\n\n    this.db!.exec(sql);\n  }\n\n  private createIndexes(): void {\n    const indexes = [\n      'CREATE INDEX IF NOT EXISTS idx_agent_id ON memory_entries(agent_id)',\n      'CREATE INDEX IF NOT EXISTS idx_session_id ON memory_entries(session_id)',\n      'CREATE INDEX IF NOT EXISTS idx_type ON memory_entries(type)',\n      'CREATE INDEX IF NOT EXISTS idx_timestamp ON memory_entries(timestamp)',\n      'CREATE INDEX IF NOT EXISTS idx_parent_id ON memory_entries(parent_id)',\n    ];\n\n    for (const sql of indexes) {\n      this.db!.exec(sql);\n    }\n  }\n\n  private rowToEntry(row: Record<string, unknown>): MemoryEntry {\n    const entry: MemoryEntry = {\n      id: row.id as string,\n      agentId: row.agent_id as string,\n      sessionId: row.session_id as string,\n      type: row.type as MemoryEntry['type'],\n      content: row.content as string,\n      context: JSON.parse(row.context as string),\n      timestamp: new Date(row.timestamp as string),\n      tags: JSON.parse(row.tags as string),\n      version: row.version as number,\n    };\n\n    if (row.parent_id) {\n      entry.parentId = row.parent_id as string;\n    }\n\n    if (row.metadata) {\n      entry.metadata = JSON.parse(row.metadata as string);\n    }\n\n    return entry;\n  }\n}\n"],"names":["promises","fs","path","MemoryBackendError","createDatabase","isSQLiteAvailable","SQLiteBackend","db","sqliteLoaded","dbPath","logger","initialize","info","module","sqliteAvailable","Error","dir","dirname","mkdir","recursive","pragma","createTables","createIndexes","error","shutdown","close","store","entry","sql","params","id","agentId","sessionId","type","content","JSON","stringify","context","timestamp","toISOString","tags","version","parentId","metadata","stmt","prepare","run","retrieve","row","get","undefined","rowToEntry","update","delete","query","conditions","push","startTime","endTime","search","length","tagConditions","map","join","forEach","tag","limit","offset","rows","all","getAllEntries","getHealthStatus","healthy","countResult","entryCount","count","sizeResult","dbSize","size","metrics","dbSizeBytes","message","exec","indexes","agent_id","session_id","parse","Date","parent_id"],"mappings":"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"}