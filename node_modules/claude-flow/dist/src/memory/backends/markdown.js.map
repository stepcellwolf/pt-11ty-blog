{"version":3,"sources":["../../../../src/memory/backends/markdown.ts"],"sourcesContent":["/**\n * Markdown backend implementation for human-readable memory storage\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport type { IMemoryBackend } from './base.js';\nimport type { MemoryEntry, MemoryQuery } from '../../utils/types.js';\nimport type { ILogger } from '../../core/logger.js';\nimport { MemoryBackendError } from '../../utils/errors.js';\n\n/**\n * Markdown-based memory backend\n */\nexport class MarkdownBackend implements IMemoryBackend {\n  private entries = new Map<string, MemoryEntry>();\n  private indexPath: string;\n\n  constructor(\n    private baseDir: string,\n    private logger: ILogger,\n  ) {\n    this.indexPath = path.join(this.baseDir, 'index.json');\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Markdown backend', { baseDir: this.baseDir });\n\n    try {\n      // Ensure directories exist\n      await fs.mkdir(this.baseDir, { recursive: true });\n      await fs.mkdir(path.join(this.baseDir, 'agents'), { recursive: true });\n      await fs.mkdir(path.join(this.baseDir, 'sessions'), { recursive: true });\n\n      // Load index\n      await this.loadIndex();\n\n      this.logger.info('Markdown backend initialized');\n    } catch (error) {\n      throw new MemoryBackendError('Failed to initialize Markdown backend', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Markdown backend');\n\n    // Save index before shutdown\n    await this.saveIndex();\n    this.entries.clear();\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    try {\n      // Store in memory\n      this.entries.set(entry.id, entry);\n\n      // Write to markdown file\n      await this.writeEntryToFile(entry);\n\n      // Update index\n      await this.saveIndex();\n    } catch (error) {\n      throw new MemoryBackendError('Failed to store entry', { error });\n    }\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    return this.entries.get(id);\n  }\n\n  async update(id: string, entry: MemoryEntry): Promise<void> {\n    if (!this.entries.has(id)) {\n      throw new MemoryBackendError(`Entry not found: ${id}`);\n    }\n\n    await this.store(entry);\n  }\n\n  async delete(id: string): Promise<void> {\n    const entry = this.entries.get(id);\n    if (!entry) {\n      return;\n    }\n\n    try {\n      // Delete from memory\n      this.entries.delete(id);\n\n      // Delete file\n      const filePath = this.getEntryFilePath(entry);\n      await fs.unlink(filePath);\n\n      // Update index\n      await this.saveIndex();\n    } catch (error) {\n      throw new MemoryBackendError('Failed to delete entry', { error });\n    }\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    let results = Array.from(this.entries.values());\n\n    // Apply filters\n    if (query.agentId) {\n      results = results.filter((e) => e.agentId === query.agentId);\n    }\n\n    if (query.sessionId) {\n      results = results.filter((e) => e.sessionId === query.sessionId);\n    }\n\n    if (query.type) {\n      results = results.filter((e) => e.type === query.type);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter((e) => query.tags!.some((tag) => e.tags.includes(tag)));\n    }\n\n    if (query.startTime) {\n      results = results.filter((e) => e.timestamp.getTime() >= query.startTime!.getTime());\n    }\n\n    if (query.endTime) {\n      results = results.filter((e) => e.timestamp.getTime() <= query.endTime!.getTime());\n    }\n\n    if (query.search) {\n      const searchLower = query.search.toLowerCase();\n      results = results.filter(\n        (e) =>\n          e.content.toLowerCase().includes(searchLower) ||\n          e.tags.some((tag) => tag.toLowerCase().includes(searchLower)),\n      );\n    }\n\n    // Sort by timestamp (newest first)\n    results.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    // Apply pagination\n    const start = query.offset || 0;\n    const limit = query.limit || results.length;\n    results = results.slice(start, start + limit);\n\n    return results;\n  }\n\n  async getAllEntries(): Promise<MemoryEntry[]> {\n    return Array.from(this.entries.values());\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      // Check if directory is accessible\n      await fs.stat(this.baseDir);\n\n      const entryCount = this.entries.size;\n      let totalSizeBytes = 0;\n\n      // Calculate total size\n      for (const entry of this.entries.values()) {\n        const filePath = this.getEntryFilePath(entry);\n        try {\n          const stat = await fs.stat(filePath);\n          totalSizeBytes += stat.size;\n        } catch {\n          // File might not exist yet\n        }\n      }\n\n      return {\n        healthy: true,\n        metrics: {\n          entryCount,\n          totalSizeBytes,\n        },\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private async loadIndex(): Promise<void> {\n    try {\n      const content = await fs.readFile(this.indexPath, 'utf-8');\n      const index = JSON.parse(content) as Record<string, MemoryEntry>;\n\n      // Convert and validate entries\n      for (const [id, entry] of Object.entries(index)) {\n        // Reconstruct dates\n        entry.timestamp = new Date(entry.timestamp);\n        this.entries.set(id, entry);\n      }\n\n      this.logger.info('Loaded memory index', { entries: this.entries.size });\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        this.logger.warn('Failed to load index', { error });\n      }\n      // Start with empty index if file doesn't exist\n    }\n  }\n\n  private async saveIndex(): Promise<void> {\n    const index: Record<string, MemoryEntry> = {};\n\n    for (const [id, entry] of this.entries) {\n      index[id] = entry;\n    }\n\n    const content = JSON.stringify(index, null, 2);\n    await fs.writeFile(this.indexPath, content, 'utf-8');\n  }\n\n  private async writeEntryToFile(entry: MemoryEntry): Promise<void> {\n    const filePath = this.getEntryFilePath(entry);\n    const dirPath = path.dirname(filePath);\n\n    // Ensure directory exists\n    await fs.mkdir(dirPath, { recursive: true });\n\n    // Generate markdown content\n    const content = this.entryToMarkdown(entry);\n\n    // Write file\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  private getEntryFilePath(entry: MemoryEntry): string {\n    const date = entry.timestamp.toISOString().split('T')[0];\n    const time = entry.timestamp.toISOString().split('T')[1].replace(/:/g, '-').split('.')[0];\n\n    return path.join(this.baseDir, 'agents', entry.agentId, date, `${time}_${entry.id}.md`);\n  }\n\n  private entryToMarkdown(entry: MemoryEntry): string {\n    const lines: string[] = [\n      `# Memory Entry: ${entry.id}`,\n      '',\n      `**Agent**: ${entry.agentId}`,\n      `**Session**: ${entry.sessionId}`,\n      `**Type**: ${entry.type}`,\n      `**Timestamp**: ${entry.timestamp.toISOString()}`,\n      `**Version**: ${entry.version}`,\n      '',\n    ];\n\n    if (entry.parentId) {\n      lines.push(`**Parent**: ${entry.parentId}`, '');\n    }\n\n    if (entry.tags.length > 0) {\n      lines.push(`**Tags**: ${entry.tags.join(', ')}`, '');\n    }\n\n    lines.push('## Content', '', entry.content, '');\n\n    if (Object.keys(entry.context).length > 0) {\n      lines.push('## Context', '', '```json');\n      lines.push(JSON.stringify(entry.context, null, 2));\n      lines.push('```', '');\n    }\n\n    if (entry.metadata && Object.keys(entry.metadata).length > 0) {\n      lines.push('## Metadata', '', '```json');\n      lines.push(JSON.stringify(entry.metadata, null, 2));\n      lines.push('```', '');\n    }\n\n    return lines.join('\\n');\n  }\n}\n"],"names":["promises","fs","path","MemoryBackendError","MarkdownBackend","entries","Map","indexPath","baseDir","logger","join","initialize","info","mkdir","recursive","loadIndex","error","shutdown","saveIndex","clear","store","entry","set","id","writeEntryToFile","retrieve","get","update","has","delete","filePath","getEntryFilePath","unlink","query","results","Array","from","values","agentId","filter","e","sessionId","type","tags","length","some","tag","includes","startTime","timestamp","getTime","endTime","search","searchLower","toLowerCase","content","sort","a","b","start","offset","limit","slice","getAllEntries","getHealthStatus","stat","entryCount","size","totalSizeBytes","healthy","metrics","Error","message","readFile","index","JSON","parse","Object","Date","code","warn","stringify","writeFile","dirPath","dirname","entryToMarkdown","date","toISOString","split","time","replace","lines","version","parentId","push","keys","context","metadata"],"mappings":"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"}