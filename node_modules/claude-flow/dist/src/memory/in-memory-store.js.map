{"version":3,"sources":["../../../src/memory/in-memory-store.js"],"sourcesContent":["/**\n * In-memory store for environments where SQLite is not available\n * Provides the same API as SQLite store but data is not persistent\n */\n\nimport { sessionSerializer } from './enhanced-session-serializer.js';\n\nclass InMemoryStore {\n  constructor(options = {}) {\n    this.options = options;\n    this.data = new Map(); // namespace -> Map(key -> entry)\n    this.isInitialized = false;\n    this.cleanupInterval = null;\n  }\n\n  async initialize() {\n    if (this.isInitialized) return;\n\n    // Initialize default namespace\n    this.data.set('default', new Map());\n\n    // Start cleanup interval for expired entries\n    this.cleanupInterval = setInterval(() => {\n      this.cleanup().catch((err) =>\n        console.error(`[${new Date().toISOString()}] ERROR [in-memory-store] Cleanup failed:`, err),\n      );\n    }, 60000); // Run cleanup every minute\n\n    this.isInitialized = true;\n    console.error(\n      `[${new Date().toISOString()}] INFO [in-memory-store] Initialized in-memory store`,\n    );\n  }\n\n  _getNamespaceMap(namespace) {\n    if (!this.data.has(namespace)) {\n      this.data.set(namespace, new Map());\n    }\n    return this.data.get(namespace);\n  }\n\n  async store(key, value, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const namespaceMap = this._getNamespaceMap(namespace);\n\n    const now = Date.now();\n    const ttl = options.ttl || null;\n    const expiresAt = ttl ? now + ttl * 1000 : null;\n    const valueStr = typeof value === 'string' ? value : sessionSerializer.serializer.serialize(value);\n\n    const entry = {\n      key,\n      value: valueStr,\n      namespace,\n      metadata: options.metadata || null,\n      createdAt: namespaceMap.has(key) ? namespaceMap.get(key).createdAt : now,\n      updatedAt: now,\n      accessedAt: now,\n      accessCount: namespaceMap.has(key) ? namespaceMap.get(key).accessCount + 1 : 1,\n      ttl,\n      expiresAt,\n    };\n\n    namespaceMap.set(key, entry);\n\n    return {\n      success: true,\n      id: `${namespace}:${key}`,\n      size: valueStr.length,\n    };\n  }\n\n  async retrieve(key, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const namespaceMap = this._getNamespaceMap(namespace);\n\n    const entry = namespaceMap.get(key);\n\n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (entry.expiresAt && entry.expiresAt < Date.now()) {\n      namespaceMap.delete(key);\n      return null;\n    }\n\n    // Update access stats\n    entry.accessedAt = Date.now();\n    entry.accessCount++;\n\n    // Try to deserialize, fall back to raw string\n    try {\n      return sessionSerializer.serializer.deserialize(entry.value);\n    } catch {\n      return entry.value;\n    }\n  }\n\n  async list(options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const limit = options.limit || 100;\n    const namespaceMap = this._getNamespaceMap(namespace);\n\n    const entries = Array.from(namespaceMap.values())\n      .filter((entry) => !entry.expiresAt || entry.expiresAt > Date.now())\n      .sort((a, b) => b.updatedAt - a.updatedAt)\n      .slice(0, limit);\n\n    return entries.map((entry) => ({\n      key: entry.key,\n      value: this._tryParseJson(entry.value),\n      namespace: entry.namespace,\n      metadata: entry.metadata,\n      createdAt: new Date(entry.createdAt),\n      updatedAt: new Date(entry.updatedAt),\n      accessCount: entry.accessCount,\n    }));\n  }\n\n  async delete(key, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const namespaceMap = this._getNamespaceMap(namespace);\n\n    return namespaceMap.delete(key);\n  }\n\n  async search(pattern, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const limit = options.limit || 50;\n    const namespaceMap = this._getNamespaceMap(namespace);\n\n    const searchLower = pattern.toLowerCase();\n    const results = [];\n\n    for (const [key, entry] of namespaceMap.entries()) {\n      // Skip expired entries\n      if (entry.expiresAt && entry.expiresAt < Date.now()) {\n        continue;\n      }\n\n      // Search in key and value\n      if (\n        key.toLowerCase().includes(searchLower) ||\n        entry.value.toLowerCase().includes(searchLower)\n      ) {\n        results.push({\n          key: entry.key,\n          value: this._tryParseJson(entry.value),\n          namespace: entry.namespace,\n          score: entry.accessCount,\n          updatedAt: new Date(entry.updatedAt),\n        });\n      }\n\n      if (results.length >= limit) {\n        break;\n      }\n    }\n\n    // Sort by score (access count) and updated time\n    return results.sort((a, b) => {\n      if (a.score !== b.score) return b.score - a.score;\n      return b.updatedAt - a.updatedAt;\n    });\n  }\n\n  async cleanup() {\n    await this.initialize();\n\n    let cleaned = 0;\n    const now = Date.now();\n\n    for (const [namespace, namespaceMap] of this.data.entries()) {\n      for (const [key, entry] of namespaceMap.entries()) {\n        if (entry.expiresAt && entry.expiresAt <= now) {\n          namespaceMap.delete(key);\n          cleaned++;\n        }\n      }\n    }\n\n    return cleaned;\n  }\n\n  _tryParseJson(value) {\n    try {\n      return sessionSerializer.serializer.deserialize(value);\n    } catch {\n      return value;\n    }\n  }\n\n  close() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    this.data.clear();\n    this.isInitialized = false;\n  }\n}\n\nexport { InMemoryStore };\nexport default InMemoryStore;\n"],"names":["sessionSerializer","InMemoryStore","options","data","Map","isInitialized","cleanupInterval","initialize","set","setInterval","cleanup","catch","err","console","error","Date","toISOString","_getNamespaceMap","namespace","has","get","store","key","value","namespaceMap","now","ttl","expiresAt","valueStr","serializer","serialize","entry","metadata","createdAt","updatedAt","accessedAt","accessCount","success","id","size","length","retrieve","delete","deserialize","list","limit","entries","Array","from","values","filter","sort","a","b","slice","map","_tryParseJson","search","pattern","searchLower","toLowerCase","results","includes","push","score","cleaned","close","clearInterval","clear"],"mappings":"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"}