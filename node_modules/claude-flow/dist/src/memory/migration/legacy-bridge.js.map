{"version":3,"sources":["../../../../src/memory/migration/legacy-bridge.js"],"sourcesContent":["/**\n * Legacy Data Bridge - Migration utilities for AgentDB integration\n * Provides safe migration from legacy memory stores to AgentDB\n */\n\nimport { writeFileSync, readFileSync, existsSync } from 'fs';\nimport { join } from 'path';\n\nexport class LegacyDataBridge {\n  constructor(options = {}) {\n    this.backupDir = options.backupDir || '.agentdb/backups';\n    this.verbose = options.verbose || false;\n  }\n\n  /**\n   * Migrate all data from legacy store to AgentDB\n   * @param {Object} sourceStore - Legacy memory store (EnhancedMemory)\n   * @param {Object} targetAdapter - AgentDB adapter\n   * @param {Object} options - Migration options\n   * @returns {Promise<Object>} Migration results\n   */\n  async migrateToAgentDB(sourceStore, targetAdapter, options = {}) {\n    const startTime = Date.now();\n    const results = {\n      success: false,\n      migrated: 0,\n      errors: 0,\n      skipped: 0,\n      backupPath: null,\n      duration: 0,\n    };\n\n    try {\n      // Step 1: Create backup\n      this._log('Creating backup of legacy data...');\n      const backupPath = await this.createBackup(sourceStore);\n      results.backupPath = backupPath;\n      this._log(`Backup created at: ${backupPath}`);\n\n      // Step 2: Export all legacy data\n      this._log('Exporting legacy data...');\n      const legacyData = await sourceStore.exportData();\n\n      // Step 3: Migrate each namespace\n      for (const [namespace, items] of Object.entries(legacyData)) {\n        this._log(`Migrating namespace: ${namespace} (${items.length} items)`);\n\n        for (const item of items) {\n          try {\n            // Check if item should be migrated with embedding\n            const shouldEmbed = this._shouldEmbed(item, namespace, options);\n\n            if (shouldEmbed && options.generateEmbedding) {\n              // Generate embedding and store with vector\n              const embedding = await options.generateEmbedding(item.value);\n\n              await targetAdapter.storeWithEmbedding(item.key, item.value, {\n                embedding,\n                metadata: item.metadata,\n                namespace,\n                ttl: item.ttl,\n              });\n            } else {\n              // Store without embedding (legacy compatibility)\n              await targetAdapter.store(item.key, item.value, {\n                metadata: item.metadata,\n                namespace,\n                ttl: item.ttl,\n              });\n            }\n\n            results.migrated++;\n          } catch (error) {\n            results.errors++;\n            this._log(`Error migrating ${item.key}: ${error.message}`, 'error');\n\n            if (options.stopOnError) {\n              throw error;\n            }\n          }\n        }\n      }\n\n      // Step 4: Validate migration\n      this._log('Validating migration...');\n      const validation = await this.validateMigration(sourceStore, targetAdapter);\n\n      if (!validation.isValid && options.strictValidation) {\n        throw new Error(`Migration validation failed: ${validation.errors.join(', ')}`);\n      }\n\n      results.success = true;\n      results.duration = Date.now() - startTime;\n\n      this._log(`Migration completed in ${results.duration}ms`);\n      this._log(`Migrated: ${results.migrated}, Errors: ${results.errors}, Skipped: ${results.skipped}`);\n\n      return results;\n    } catch (error) {\n      results.success = false;\n      results.duration = Date.now() - startTime;\n      results.error = error.message;\n\n      this._log(`Migration failed: ${error.message}`, 'error');\n      return results;\n    }\n  }\n\n  /**\n   * Validate migration integrity\n   * @param {Object} sourceStore - Source legacy store\n   * @param {Object} targetAdapter - Target AgentDB adapter\n   * @returns {Promise<Object>} Validation results\n   */\n  async validateMigration(sourceStore, targetAdapter) {\n    const validation = {\n      isValid: true,\n      errors: [],\n      warnings: [],\n      stats: {\n        sourceCount: 0,\n        targetCount: 0,\n        matched: 0,\n        mismatched: 0,\n      },\n    };\n\n    try {\n      // Export both stores\n      const sourceData = await sourceStore.exportData();\n      const targetData = await targetAdapter.exportData();\n\n      // Count total items\n      for (const items of Object.values(sourceData)) {\n        validation.stats.sourceCount += items.length;\n      }\n\n      for (const items of Object.values(targetData)) {\n        validation.stats.targetCount += items.length;\n      }\n\n      // Validate each namespace\n      for (const [namespace, sourceItems] of Object.entries(sourceData)) {\n        const targetItems = targetData[namespace] || [];\n        const targetKeys = new Set(targetItems.map(item => item.key));\n\n        for (const sourceItem of sourceItems) {\n          if (targetKeys.has(sourceItem.key)) {\n            // Find matching item\n            const targetItem = targetItems.find(item => item.key === sourceItem.key);\n\n            // Deep compare values\n            if (JSON.stringify(sourceItem.value) === JSON.stringify(targetItem.value)) {\n              validation.stats.matched++;\n            } else {\n              validation.stats.mismatched++;\n              validation.warnings.push(\n                `Value mismatch for key: ${sourceItem.key} in namespace: ${namespace}`,\n              );\n            }\n          } else {\n            validation.errors.push(`Missing key in target: ${sourceItem.key} in namespace: ${namespace}`);\n            validation.isValid = false;\n          }\n        }\n      }\n\n      // Check for count discrepancies\n      if (validation.stats.sourceCount !== validation.stats.targetCount) {\n        validation.warnings.push(\n          `Count mismatch: source=${validation.stats.sourceCount}, target=${validation.stats.targetCount}`,\n        );\n      }\n\n      return validation;\n    } catch (error) {\n      validation.isValid = false;\n      validation.errors.push(`Validation error: ${error.message}`);\n      return validation;\n    }\n  }\n\n  /**\n   * Rollback migration from backup\n   * @param {string} backupPath - Path to backup file\n   * @param {Object} targetStore - Store to restore to\n   * @returns {Promise<Object>} Rollback results\n   */\n  async rollback(backupPath, targetStore) {\n    const startTime = Date.now();\n    const results = {\n      success: false,\n      restored: 0,\n      errors: 0,\n      duration: 0,\n    };\n\n    try {\n      // Check if backup exists\n      if (!existsSync(backupPath)) {\n        throw new Error(`Backup file not found: ${backupPath}`);\n      }\n\n      // Read backup\n      this._log(`Reading backup from: ${backupPath}`);\n      const backupData = JSON.parse(readFileSync(backupPath, 'utf-8'));\n\n      // Restore data\n      this._log('Restoring data from backup...');\n      await targetStore.importData(backupData);\n\n      results.success = true;\n      results.duration = Date.now() - startTime;\n\n      this._log(`Rollback completed in ${results.duration}ms`);\n      return results;\n    } catch (error) {\n      results.success = false;\n      results.duration = Date.now() - startTime;\n      results.error = error.message;\n\n      this._log(`Rollback failed: ${error.message}`, 'error');\n      return results;\n    }\n  }\n\n  /**\n   * Create backup of current data\n   * @param {Object} sourceStore - Store to backup\n   * @returns {Promise<string>} Backup file path\n   */\n  async createBackup(sourceStore) {\n    try {\n      // Ensure backup directory exists\n      const fs = await import('fs');\n      if (!fs.existsSync(this.backupDir)) {\n        fs.mkdirSync(this.backupDir, { recursive: true });\n      }\n\n      // Export data\n      const data = await sourceStore.exportData();\n\n      // Create backup file with timestamp\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const backupPath = join(this.backupDir, `backup-${timestamp}.json`);\n\n      // Write backup\n      writeFileSync(backupPath, JSON.stringify(data, null, 2), 'utf-8');\n\n      return backupPath;\n    } catch (error) {\n      throw new Error(`Backup creation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Determine if item should have embedding\n   * @private\n   */\n  _shouldEmbed(item, namespace, options) {\n    // Skip embedding for certain namespaces\n    const skipNamespaces = options.skipEmbedding || ['metrics', 'performance', 'coordination'];\n\n    if (skipNamespaces.includes(namespace)) {\n      return false;\n    }\n\n    // Skip if value is not suitable for embedding\n    if (typeof item.value !== 'object' && typeof item.value !== 'string') {\n      return false;\n    }\n\n    // Embed knowledge, learning, and sessions by default\n    const embedNamespaces = options.embedNamespaces || ['knowledge', 'learning', 'sessions', 'workflows'];\n\n    return embedNamespaces.includes(namespace);\n  }\n\n  /**\n   * Log message\n   * @private\n   */\n  _log(message, level = 'info') {\n    if (!this.verbose && level !== 'error') {\n      return;\n    }\n\n    const timestamp = new Date().toISOString();\n    const prefix = level === 'error' ? 'ERROR' : 'INFO';\n\n    console.error(`[${timestamp}] ${prefix} [legacy-bridge] ${message}`);\n  }\n\n  /**\n   * Generate migration report\n   * @param {Object} results - Migration results\n   * @returns {string} Formatted report\n   */\n  generateReport(results) {\n    const lines = [];\n\n    lines.push('='.repeat(60));\n    lines.push('AgentDB Migration Report');\n    lines.push('='.repeat(60));\n    lines.push('');\n    lines.push(`Status: ${results.success ? 'SUCCESS' : 'FAILED'}`);\n    lines.push(`Duration: ${results.duration}ms`);\n    lines.push('');\n    lines.push('Statistics:');\n    lines.push(`  Migrated: ${results.migrated}`);\n    lines.push(`  Errors: ${results.errors}`);\n    lines.push(`  Skipped: ${results.skipped}`);\n\n    if (results.backupPath) {\n      lines.push('');\n      lines.push(`Backup Location: ${results.backupPath}`);\n    }\n\n    if (results.error) {\n      lines.push('');\n      lines.push(`Error: ${results.error}`);\n    }\n\n    lines.push('='.repeat(60));\n\n    return lines.join('\\n');\n  }\n}\n\nexport default LegacyDataBridge;\n"],"names":["writeFileSync","readFileSync","existsSync","join","LegacyDataBridge","options","backupDir","verbose","migrateToAgentDB","sourceStore","targetAdapter","startTime","Date","now","results","success","migrated","errors","skipped","backupPath","duration","_log","createBackup","legacyData","exportData","namespace","items","Object","entries","length","item","shouldEmbed","_shouldEmbed","generateEmbedding","embedding","value","storeWithEmbedding","key","metadata","ttl","store","error","message","stopOnError","validation","validateMigration","isValid","strictValidation","Error","warnings","stats","sourceCount","targetCount","matched","mismatched","sourceData","targetData","values","sourceItems","targetItems","targetKeys","Set","map","sourceItem","has","targetItem","find","JSON","stringify","push","rollback","targetStore","restored","backupData","parse","importData","fs","mkdirSync","recursive","data","timestamp","toISOString","replace","skipNamespaces","skipEmbedding","includes","embedNamespaces","level","prefix","console","generateReport","lines","repeat"],"mappings":"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"}