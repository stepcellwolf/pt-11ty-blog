{"version":3,"sources":["../../../src/memory/advanced-memory-manager.ts"],"sourcesContent":["/**\n * Advanced Memory Management System with comprehensive capabilities\n * Includes indexing, compression, cross-agent sharing, and intelligent cleanup\n */\n\nimport { EventEmitter } from 'node:events';\nimport { promises as fs } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { join, dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport type { ILogger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\n\n// === INTERFACES ===\n\nexport interface MemoryEntry {\n  id: string;\n  key: string;\n  value: any;\n  type: string;\n  namespace: string;\n  tags: string[];\n  metadata: Record<string, any>;\n  owner: string;\n  accessLevel: 'private' | 'shared' | 'public';\n  createdAt: Date;\n  updatedAt: Date;\n  lastAccessedAt: Date;\n  expiresAt?: Date;\n  version: number;\n  size: number;\n  compressed: boolean;\n  checksum: string;\n  references: string[];\n  dependencies: string[];\n}\n\nexport interface MemoryIndex {\n  keys: Map<string, string[]>; // key -> entryIds\n  tags: Map<string, string[]>; // tag -> entryIds\n  types: Map<string, string[]>; // type -> entryIds\n  namespaces: Map<string, string[]>; // namespace -> entryIds\n  owners: Map<string, string[]>; // owner -> entryIds\n  fullText: Map<string, string[]>; // word -> entryIds\n}\n\nexport interface QueryOptions {\n  namespace?: string;\n  type?: string;\n  tags?: string[];\n  owner?: string;\n  accessLevel?: 'private' | 'shared' | 'public';\n  keyPattern?: string;\n  valueSearch?: string;\n  fullTextSearch?: string;\n  createdAfter?: Date;\n  createdBefore?: Date;\n  updatedAfter?: Date;\n  updatedBefore?: Date;\n  lastAccessedAfter?: Date;\n  lastAccessedBefore?: Date;\n  sizeGreaterThan?: number;\n  sizeLessThan?: number;\n  includeExpired?: boolean;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'key' | 'createdAt' | 'updatedAt' | 'lastAccessedAt' | 'size' | 'type';\n  sortOrder?: 'asc' | 'desc';\n  aggregateBy?: 'namespace' | 'type' | 'owner' | 'tags';\n  includeMetadata?: boolean;\n}\n\nexport interface ExportOptions {\n  format: 'json' | 'csv' | 'xml' | 'yaml';\n  namespace?: string;\n  type?: string;\n  includeMetadata?: boolean;\n  compression?: boolean;\n  encryption?: {\n    enabled: boolean;\n    algorithm?: string;\n    key?: string;\n  };\n  filtering?: QueryOptions;\n}\n\nexport interface ImportOptions {\n  format: 'json' | 'csv' | 'xml' | 'yaml';\n  namespace?: string;\n  conflictResolution: 'overwrite' | 'skip' | 'merge' | 'rename';\n  validation?: boolean;\n  transformation?: {\n    keyMapping?: Record<string, string>;\n    valueTransformation?: (value: any) => any;\n    metadataExtraction?: (entry: any) => Record<string, any>;\n  };\n  dryRun?: boolean;\n}\n\nexport interface MemoryStatistics {\n  overview: {\n    totalEntries: number;\n    totalSize: number;\n    compressedEntries: number;\n    compressionRatio: number;\n    indexSize: number;\n    memoryUsage: number;\n    diskUsage: number;\n  };\n  distribution: {\n    byNamespace: Record<string, { count: number; size: number }>;\n    byType: Record<string, { count: number; size: number }>;\n    byOwner: Record<string, { count: number; size: number }>;\n    byAccessLevel: Record<string, { count: number; size: number }>;\n  };\n  temporal: {\n    entriesCreatedLast24h: number;\n    entriesUpdatedLast24h: number;\n    entriesAccessedLast24h: number;\n    oldestEntry?: Date;\n    newestEntry?: Date;\n  };\n  performance: {\n    averageQueryTime: number;\n    averageWriteTime: number;\n    cacheHitRatio: number;\n    indexEfficiency: number;\n  };\n  health: {\n    expiredEntries: number;\n    orphanedReferences: number;\n    duplicateKeys: number;\n    corruptedEntries: number;\n    recommendedCleanup: boolean;\n  };\n  optimization: {\n    suggestions: string[];\n    potentialSavings: {\n      compression: number;\n      cleanup: number;\n      deduplication: number;\n    };\n    indexOptimization: string[];\n  };\n}\n\nexport interface CleanupOptions {\n  dryRun?: boolean;\n  removeExpired?: boolean;\n  removeOlderThan?: number; // days\n  removeUnaccessed?: number; // days since last access\n  removeOrphaned?: boolean;\n  removeDuplicates?: boolean;\n  compressEligible?: boolean;\n  archiveOld?: {\n    enabled: boolean;\n    olderThan: number; // days\n    archivePath: string;\n  };\n  retentionPolicies?: {\n    namespace: string;\n    maxAge?: number; // days\n    maxCount?: number;\n    sizeLimit?: number; // bytes\n  }[];\n}\n\nexport interface RetentionPolicy {\n  id: string;\n  name: string;\n  namespace?: string;\n  type?: string;\n  tags?: string[];\n  maxAge?: number; // days\n  maxCount?: number;\n  sizeLimit?: number; // bytes\n  priority: number;\n  enabled: boolean;\n}\n\n// === MAIN CLASS ===\n\nexport class AdvancedMemoryManager extends EventEmitter {\n  private readonly dataPath: string;\n  private readonly indexPath: string;\n  private readonly backupPath: string;\n  private readonly archivePath: string;\n\n  private entries = new Map<string, MemoryEntry>();\n  private index: MemoryIndex;\n  private cache = new Map<string, { entry: MemoryEntry; expiry: number }>();\n  private retentionPolicies = new Map<string, RetentionPolicy>();\n\n  private logger: ILogger;\n  private config: {\n    maxMemorySize: number;\n    cacheSize: number;\n    cacheTtl: number;\n    autoCompress: boolean;\n    autoCleanup: boolean;\n    cleanupInterval: number;\n    indexingEnabled: boolean;\n    persistenceEnabled: boolean;\n    compressionThreshold: number;\n    backupRetention: number;\n  };\n\n  private statistics: MemoryStatistics;\n  private operationMetrics = new Map<string, { count: number; totalTime: number }>();\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(\n    config: Partial<typeof AdvancedMemoryManager.prototype.config> = {},\n    logger: ILogger,\n  ) {\n    super();\n\n    this.logger = logger;\n    this.config = {\n      maxMemorySize: 1024 * 1024 * 1024, // 1GB\n      cacheSize: 10000,\n      cacheTtl: 300000, // 5 minutes\n      autoCompress: true,\n      autoCleanup: true,\n      cleanupInterval: 3600000, // 1 hour\n      indexingEnabled: true,\n      persistenceEnabled: true,\n      compressionThreshold: 1024, // 1KB\n      backupRetention: 7, // days\n      ...config,\n    };\n\n    // Setup file paths\n    const __dirname = dirname(fileURLToPath(import.meta.url));\n    this.dataPath = join(process.cwd(), 'memory', 'data');\n    this.indexPath = join(process.cwd(), 'memory', 'index');\n    this.backupPath = join(process.cwd(), 'memory', 'backups');\n    this.archivePath = join(process.cwd(), 'memory', 'archive');\n\n    this.index = this.createEmptyIndex();\n    this.statistics = this.initializeStatistics();\n  }\n\n  // === INITIALIZATION ===\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Advanced Memory Manager');\n\n    // Create directories\n    await Promise.all([\n      fs.mkdir(this.dataPath, { recursive: true }),\n      fs.mkdir(this.indexPath, { recursive: true }),\n      fs.mkdir(this.backupPath, { recursive: true }),\n      fs.mkdir(this.archivePath, { recursive: true }),\n    ]);\n\n    // Load persisted data\n    if (this.config.persistenceEnabled) {\n      await this.loadPersistedData();\n    }\n\n    // Start automatic cleanup if enabled\n    if (this.config.autoCleanup) {\n      this.startAutoCleanup();\n    }\n\n    this.emit('memory:initialized');\n    this.logger.info('Advanced Memory Manager initialized successfully');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Advanced Memory Manager');\n\n    // Stop cleanup interval\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    // Persist data\n    if (this.config.persistenceEnabled) {\n      await this.persistData();\n    }\n\n    // Create backup\n    await this.createBackup();\n\n    this.emit('memory:shutdown');\n  }\n\n  // === CORE OPERATIONS ===\n\n  async store(\n    key: string,\n    value: any,\n    options: {\n      namespace?: string;\n      type?: string;\n      tags?: string[];\n      metadata?: Record<string, any>;\n      owner?: string;\n      accessLevel?: 'private' | 'shared' | 'public';\n      ttl?: number;\n      compress?: boolean;\n    } = {},\n  ): Promise<string> {\n    const startTime = Date.now();\n\n    try {\n      const entryId = generateId('entry');\n      const now = new Date();\n\n      // Process value (compression, serialization)\n      const processedValue = await this.processValue(value, options.compress);\n      const size = this.calculateSize(processedValue);\n\n      // Create entry\n      const entry: MemoryEntry = {\n        id: entryId,\n        key,\n        value: processedValue.value,\n        type: options.type || this.inferType(value),\n        namespace: options.namespace || 'default',\n        tags: options.tags || [],\n        metadata: options.metadata || {},\n        owner: options.owner || 'system',\n        accessLevel: options.accessLevel || 'shared',\n        createdAt: now,\n        updatedAt: now,\n        lastAccessedAt: now,\n        expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n        version: 1,\n        size,\n        compressed: processedValue.compressed,\n        checksum: this.calculateChecksum(processedValue.value),\n        references: [],\n        dependencies: [],\n      };\n\n      // Store entry\n      this.entries.set(entryId, entry);\n\n      // Update index\n      if (this.config.indexingEnabled) {\n        this.updateIndex(entry, 'create');\n      }\n\n      // Update cache\n      this.updateCache(key, entry);\n\n      // Apply retention policies\n      await this.applyRetentionPolicies(entry);\n\n      this.logger.debug('Memory entry stored', { entryId, key, namespace: entry.namespace });\n      this.emit('memory:entry-stored', { entry });\n\n      this.recordMetric('store', Date.now() - startTime);\n      return entryId;\n    } catch (error) {\n      this.recordMetric('store-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async retrieve(\n    key: string,\n    options: {\n      namespace?: string;\n      updateLastAccessed?: boolean;\n    } = {},\n  ): Promise<MemoryEntry | null> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const cached = this.cache.get(key);\n      if (cached && cached.expiry > Date.now()) {\n        this.recordMetric('retrieve-cache', Date.now() - startTime);\n        return cached.entry;\n      }\n\n      // Search in entries\n      const entry = this.findEntryByKey(key, options.namespace);\n      if (!entry) {\n        this.recordMetric('retrieve-miss', Date.now() - startTime);\n        return null;\n      }\n\n      // Check if expired\n      if (entry.expiresAt && entry.expiresAt < new Date()) {\n        await this.deleteEntry(entry.id);\n        this.recordMetric('retrieve-expired', Date.now() - startTime);\n        return null;\n      }\n\n      // Update last accessed\n      if (options.updateLastAccessed !== false) {\n        entry.lastAccessedAt = new Date();\n      }\n\n      // Decompress if needed\n      if (entry.compressed) {\n        entry.value = await this.decompressValue(entry.value);\n      }\n\n      // Update cache\n      this.updateCache(key, entry);\n\n      this.recordMetric('retrieve', Date.now() - startTime);\n      return entry;\n    } catch (error) {\n      this.recordMetric('retrieve-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async update(\n    key: string,\n    value: any,\n    options: {\n      namespace?: string;\n      merge?: boolean;\n      updateMetadata?: Record<string, any>;\n    } = {},\n  ): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = await this.retrieve(key, { namespace: options.namespace });\n      if (!entry) {\n        this.recordMetric('update-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Process new value\n      const processedValue = await this.processValue(value, entry.compressed);\n\n      // Update entry\n      if (options.merge && typeof entry.value === 'object' && typeof value === 'object') {\n        entry.value = { ...entry.value, ...processedValue.value };\n      } else {\n        entry.value = processedValue.value;\n      }\n\n      entry.updatedAt = new Date();\n      entry.lastAccessedAt = new Date();\n      entry.version++;\n      entry.size = this.calculateSize(entry.value);\n      entry.checksum = this.calculateChecksum(entry.value);\n\n      if (options.updateMetadata) {\n        entry.metadata = { ...entry.metadata, ...options.updateMetadata };\n      }\n\n      // Update index\n      if (this.config.indexingEnabled) {\n        this.updateIndex(entry, 'update');\n      }\n\n      // Update cache\n      this.updateCache(key, entry);\n\n      this.logger.debug('Memory entry updated', { entryId: entry.id, key });\n      this.emit('memory:entry-updated', { entry });\n\n      this.recordMetric('update', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('update-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async deleteEntry(entryId: string): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = this.entries.get(entryId);\n      if (!entry) {\n        this.recordMetric('delete-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Remove from storage\n      this.entries.delete(entryId);\n\n      // Update index\n      if (this.config.indexingEnabled) {\n        this.updateIndex(entry, 'delete');\n      }\n\n      // Remove from cache\n      this.cache.delete(entry.key);\n\n      this.logger.debug('Memory entry deleted', { entryId, key: entry.key });\n      this.emit('memory:entry-deleted', { entryId });\n\n      this.recordMetric('delete', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('delete-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === ADVANCED QUERY OPERATIONS ===\n\n  async query(options: QueryOptions = {}): Promise<{\n    entries: MemoryEntry[];\n    total: number;\n    aggregations?: Record<string, any>;\n  }> {\n    const startTime = Date.now();\n\n    try {\n      let candidateEntries: MemoryEntry[] = [];\n\n      // Use index for efficient querying if enabled\n      if (this.config.indexingEnabled) {\n        candidateEntries = this.queryWithIndex(options);\n      } else {\n        candidateEntries = Array.from(this.entries.values());\n      }\n\n      // Apply filters\n      let filteredEntries = candidateEntries.filter((entry) => {\n        return this.matchesQuery(entry, options);\n      });\n\n      // Remove expired entries\n      if (!options.includeExpired) {\n        filteredEntries = filteredEntries.filter((entry) => {\n          if (entry.expiresAt && entry.expiresAt < new Date()) {\n            // Schedule for deletion\n            setTimeout(() => this.deleteEntry(entry.id), 0);\n            return false;\n          }\n          return true;\n        });\n      }\n\n      const total = filteredEntries.length;\n\n      // Apply sorting\n      if (options.sortBy) {\n        filteredEntries.sort((a, b) => {\n          const aVal = this.getPropertyValue(a, options.sortBy!);\n          const bVal = this.getPropertyValue(b, options.sortBy!);\n          const multiplier = options.sortOrder === 'desc' ? -1 : 1;\n\n          if (aVal < bVal) return -1 * multiplier;\n          if (aVal > bVal) return 1 * multiplier;\n          return 0;\n        });\n      }\n\n      // Apply pagination\n      const offset = options.offset || 0;\n      const limit = options.limit || filteredEntries.length;\n      const paginatedEntries = filteredEntries.slice(offset, offset + limit);\n\n      // Update last accessed times\n      paginatedEntries.forEach((entry) => {\n        entry.lastAccessedAt = new Date();\n      });\n\n      // Generate aggregations if requested\n      let aggregations: Record<string, any> | undefined;\n      if (options.aggregateBy) {\n        aggregations = this.generateAggregations(filteredEntries, options.aggregateBy);\n      }\n\n      this.recordMetric('query', Date.now() - startTime);\n\n      return {\n        entries: paginatedEntries,\n        total,\n        aggregations,\n      };\n    } catch (error) {\n      this.recordMetric('query-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === EXPORT OPERATIONS ===\n\n  async export(\n    filePath: string,\n    options: ExportOptions,\n  ): Promise<{\n    entriesExported: number;\n    fileSize: number;\n    checksum: string;\n  }> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Starting memory export', { filePath, format: options.format });\n\n      // Query entries to export\n      const queryResult = await this.query(options.filtering || {});\n      const entries = queryResult.entries;\n\n      if (entries.length === 0) {\n        throw new Error('No entries found matching export criteria');\n      }\n\n      // Prepare export data\n      let exportData: any;\n\n      switch (options.format) {\n        case 'json':\n          exportData = this.prepareJsonExport(entries, options);\n          break;\n        case 'csv':\n          exportData = this.prepareCsvExport(entries, options);\n          break;\n        case 'xml':\n          exportData = this.prepareXmlExport(entries, options);\n          break;\n        case 'yaml':\n          exportData = this.prepareYamlExport(entries, options);\n          break;\n        default:\n          throw new Error(`Unsupported export format: ${options.format}`);\n      }\n\n      // Apply compression if requested\n      if (options.compression) {\n        exportData = await this.compressData(exportData);\n      }\n\n      // Apply encryption if requested\n      if (options.encryption?.enabled) {\n        exportData = await this.encryptData(exportData, options.encryption);\n      }\n\n      // Write to file\n      await fs.mkdir(dirname(filePath), { recursive: true });\n      await fs.writeFile(filePath, exportData);\n\n      // Calculate file stats\n      const stats = await fs.stat(filePath);\n      const checksum = this.calculateChecksum(exportData);\n\n      this.logger.info('Memory export completed', {\n        entriesExported: entries.length,\n        fileSize: stats.size,\n        checksum,\n      });\n\n      this.emit('memory:exported', {\n        filePath,\n        entriesExported: entries.length,\n        fileSize: stats.size,\n      });\n\n      this.recordMetric('export', Date.now() - startTime);\n\n      return {\n        entriesExported: entries.length,\n        fileSize: stats.size,\n        checksum,\n      };\n    } catch (error) {\n      this.recordMetric('export-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === IMPORT OPERATIONS ===\n\n  async import(\n    filePath: string,\n    options: ImportOptions,\n  ): Promise<{\n    entriesImported: number;\n    entriesSkipped: number;\n    entriesUpdated: number;\n    conflicts: string[];\n  }> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Starting memory import', { filePath, format: options.format });\n\n      // Read and parse file\n      const fileContent = await fs.readFile(filePath, 'utf-8');\n      let importData: any[];\n\n      switch (options.format) {\n        case 'json':\n          importData = this.parseJsonImport(fileContent);\n          break;\n        case 'csv':\n          importData = this.parseCsvImport(fileContent);\n          break;\n        case 'xml':\n          importData = this.parseXmlImport(fileContent);\n          break;\n        case 'yaml':\n          importData = this.parseYamlImport(fileContent);\n          break;\n        default:\n          throw new Error(`Unsupported import format: ${options.format}`);\n      }\n\n      // Validate data if requested\n      if (options.validation) {\n        importData = this.validateImportData(importData);\n      }\n\n      // Apply transformations if provided\n      if (options.transformation) {\n        importData = this.transformImportData(importData, options.transformation);\n      }\n\n      // Process imports\n      const results = {\n        entriesImported: 0,\n        entriesSkipped: 0,\n        entriesUpdated: 0,\n        conflicts: [] as string[],\n      };\n\n      for (const item of importData) {\n        if (options.dryRun) {\n          // Dry run - just check for conflicts\n          const existing = this.findEntryByKey(item.key, item.namespace);\n          if (existing) {\n            results.conflicts.push(\n              `Key '${item.key}' already exists in namespace '${item.namespace}'`,\n            );\n          }\n          continue;\n        }\n\n        try {\n          const result = await this.importSingleEntry(item, options);\n\n          switch (result.action) {\n            case 'imported':\n              results.entriesImported++;\n              break;\n            case 'updated':\n              results.entriesUpdated++;\n              break;\n            case 'skipped':\n              results.entriesSkipped++;\n              break;\n            case 'conflict':\n              results.conflicts.push(result.message || 'Unknown conflict');\n              break;\n          }\n        } catch (error) {\n          results.conflicts.push(\n            `Error importing '${item.key}': ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n\n      this.logger.info('Memory import completed', results);\n      this.emit('memory:imported', results);\n\n      this.recordMetric('import', Date.now() - startTime);\n      return results;\n    } catch (error) {\n      this.recordMetric('import-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === STATISTICS AND ANALYTICS ===\n\n  async getStatistics(): Promise<MemoryStatistics> {\n    const startTime = Date.now();\n\n    try {\n      const stats = this.calculateStatistics();\n      this.recordMetric('stats', Date.now() - startTime);\n      return stats;\n    } catch (error) {\n      this.recordMetric('stats-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === CLEANUP OPERATIONS ===\n\n  async cleanup(options: CleanupOptions = {}): Promise<{\n    entriesRemoved: number;\n    entriesArchived: number;\n    entriesCompressed: number;\n    spaceSaved: number;\n    actions: string[];\n  }> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Starting memory cleanup', options);\n\n      const results = {\n        entriesRemoved: 0,\n        entriesArchived: 0,\n        entriesCompressed: 0,\n        spaceSaved: 0,\n        actions: [] as string[],\n      };\n\n      // Get all entries for processing\n      const allEntries = Array.from(this.entries.values());\n      const now = new Date();\n\n      // Phase 1: Remove expired entries\n      if (options.removeExpired !== false) {\n        const expiredEntries = allEntries.filter(\n          (entry) => entry.expiresAt && entry.expiresAt < now,\n        );\n\n        for (const entry of expiredEntries) {\n          if (!options.dryRun) {\n            await this.deleteEntry(entry.id);\n          }\n          results.entriesRemoved++;\n          results.spaceSaved += entry.size;\n        }\n\n        if (expiredEntries.length > 0) {\n          results.actions.push(`Removed ${expiredEntries.length} expired entries`);\n        }\n      }\n\n      // Phase 2: Remove old entries\n      if (options.removeOlderThan) {\n        const cutoffDate = new Date(now.getTime() - options.removeOlderThan * 24 * 60 * 60 * 1000);\n        const oldEntries = allEntries.filter((entry) => entry.createdAt < cutoffDate);\n\n        for (const entry of oldEntries) {\n          if (!options.dryRun) {\n            await this.deleteEntry(entry.id);\n          }\n          results.entriesRemoved++;\n          results.spaceSaved += entry.size;\n        }\n\n        if (oldEntries.length > 0) {\n          results.actions.push(\n            `Removed ${oldEntries.length} entries older than ${options.removeOlderThan} days`,\n          );\n        }\n      }\n\n      // Phase 3: Remove unaccessed entries\n      if (options.removeUnaccessed) {\n        const cutoffDate = new Date(now.getTime() - options.removeUnaccessed * 24 * 60 * 60 * 1000);\n        const unaccessedEntries = allEntries.filter((entry) => entry.lastAccessedAt < cutoffDate);\n\n        for (const entry of unaccessedEntries) {\n          if (!options.dryRun) {\n            await this.deleteEntry(entry.id);\n          }\n          results.entriesRemoved++;\n          results.spaceSaved += entry.size;\n        }\n\n        if (unaccessedEntries.length > 0) {\n          results.actions.push(\n            `Removed ${unaccessedEntries.length} entries not accessed in ${options.removeUnaccessed} days`,\n          );\n        }\n      }\n\n      // Phase 4: Archive old entries\n      if (options.archiveOld?.enabled) {\n        const cutoffDate = new Date(\n          now.getTime() - options.archiveOld.olderThan * 24 * 60 * 60 * 1000,\n        );\n        const archiveEntries = allEntries.filter(\n          (entry) => entry.createdAt < cutoffDate && !entry.expiresAt, // Don't archive entries that will expire\n        );\n\n        if (archiveEntries.length > 0 && !options.dryRun) {\n          await this.archiveEntries(archiveEntries, options.archiveOld.archivePath);\n        }\n\n        results.entriesArchived = archiveEntries.length;\n        if (archiveEntries.length > 0) {\n          results.actions.push(`Archived ${archiveEntries.length} old entries`);\n        }\n      }\n\n      // Phase 5: Compress eligible entries\n      if (options.compressEligible !== false && this.config.autoCompress) {\n        const uncompressedEntries = allEntries.filter(\n          (entry) => !entry.compressed && entry.size > this.config.compressionThreshold,\n        );\n\n        for (const entry of uncompressedEntries) {\n          if (!options.dryRun) {\n            const originalSize = entry.size;\n            const compressedValue = await this.compressValue(entry.value);\n            entry.value = compressedValue;\n            entry.compressed = true;\n            entry.size = this.calculateSize(compressedValue);\n            results.spaceSaved += originalSize - entry.size;\n          }\n          results.entriesCompressed++;\n        }\n\n        if (uncompressedEntries.length > 0) {\n          results.actions.push(`Compressed ${uncompressedEntries.length} entries`);\n        }\n      }\n\n      // Phase 6: Apply retention policies\n      if (options.retentionPolicies) {\n        for (const policy of options.retentionPolicies) {\n          const policyResults = await this.applyRetentionPolicy(policy, options.dryRun);\n          results.entriesRemoved += policyResults.removed;\n          results.spaceSaved += policyResults.spaceSaved;\n          if (policyResults.removed > 0) {\n            results.actions.push(\n              `Retention policy '${policy.namespace}': removed ${policyResults.removed} entries`,\n            );\n          }\n        }\n      }\n\n      // Phase 7: Remove orphaned references\n      if (options.removeOrphaned !== false) {\n        const orphanedCount = await this.cleanupOrphanedReferences(options.dryRun);\n        if (orphanedCount > 0) {\n          results.actions.push(`Cleaned up ${orphanedCount} orphaned references`);\n        }\n      }\n\n      // Phase 8: Remove duplicates\n      if (options.removeDuplicates) {\n        const duplicatesResults = await this.removeDuplicateEntries(options.dryRun);\n        results.entriesRemoved += duplicatesResults.removed;\n        results.spaceSaved += duplicatesResults.spaceSaved;\n        if (duplicatesResults.removed > 0) {\n          results.actions.push(`Removed ${duplicatesResults.removed} duplicate entries`);\n        }\n      }\n\n      // Rebuild index if significant changes\n      if (results.entriesRemoved + results.entriesArchived > 100 && !options.dryRun) {\n        await this.rebuildIndex();\n        results.actions.push('Rebuilt search index');\n      }\n\n      this.logger.info('Memory cleanup completed', results);\n      this.emit('memory:cleanup-completed', results);\n\n      this.recordMetric('cleanup', Date.now() - startTime);\n      return results;\n    } catch (error) {\n      this.recordMetric('cleanup-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private createEmptyIndex(): MemoryIndex {\n    return {\n      keys: new Map(),\n      tags: new Map(),\n      types: new Map(),\n      namespaces: new Map(),\n      owners: new Map(),\n      fullText: new Map(),\n    };\n  }\n\n  private async processValue(\n    value: any,\n    compress?: boolean,\n  ): Promise<{ value: any; compressed: boolean }> {\n    let processedValue = value;\n    let isCompressed = false;\n\n    // Auto-compress if enabled and value is large enough\n    if (\n      (compress || this.config.autoCompress) &&\n      this.calculateSize(value) > this.config.compressionThreshold\n    ) {\n      processedValue = await this.compressValue(value);\n      isCompressed = true;\n    }\n\n    return { value: processedValue, compressed: isCompressed };\n  }\n\n  private async compressValue(value: any): Promise<any> {\n    // Placeholder for compression implementation\n    // In a real implementation, you would use a compression library like zlib\n    return JSON.stringify(value);\n  }\n\n  private async decompressValue(value: any): Promise<any> {\n    // Placeholder for decompression implementation\n    try {\n      return JSON.parse(value);\n    } catch {\n      return value;\n    }\n  }\n\n  private calculateSize(value: any): number {\n    return JSON.stringify(value).length;\n  }\n\n  private calculateChecksum(value: any): string {\n    return createHash('sha256').update(JSON.stringify(value)).digest('hex');\n  }\n\n  private inferType(value: any): string {\n    if (Array.isArray(value)) return 'array';\n    if (value === null) return 'null';\n    return typeof value;\n  }\n\n  private findEntryByKey(key: string, namespace?: string): MemoryEntry | undefined {\n    for (const entry of this.entries.values()) {\n      if (entry.key === key && (!namespace || entry.namespace === namespace)) {\n        return entry;\n      }\n    }\n    return undefined;\n  }\n\n  private updateIndex(entry: MemoryEntry, operation: 'create' | 'update' | 'delete'): void {\n    if (!this.config.indexingEnabled) return;\n\n    const { id, key, tags, type, namespace, owner, value } = entry;\n\n    if (operation === 'delete') {\n      // Remove from all indices\n      this.removeFromIndex(this.index.keys, key, id);\n      tags.forEach((tag) => this.removeFromIndex(this.index.tags, tag, id));\n      this.removeFromIndex(this.index.types, type, id);\n      this.removeFromIndex(this.index.namespaces, namespace, id);\n      this.removeFromIndex(this.index.owners, owner, id);\n\n      // Remove from full-text index\n      const words = this.extractWords(value);\n      words.forEach((word) => this.removeFromIndex(this.index.fullText, word, id));\n    } else {\n      // Add to indices\n      this.addToIndex(this.index.keys, key, id);\n      tags.forEach((tag) => this.addToIndex(this.index.tags, tag, id));\n      this.addToIndex(this.index.types, type, id);\n      this.addToIndex(this.index.namespaces, namespace, id);\n      this.addToIndex(this.index.owners, owner, id);\n\n      // Add to full-text index\n      const words = this.extractWords(value);\n      words.forEach((word) => this.addToIndex(this.index.fullText, word, id));\n    }\n  }\n\n  private addToIndex(indexMap: Map<string, string[]>, key: string, entryId: string): void {\n    if (!indexMap.has(key)) {\n      indexMap.set(key, []);\n    }\n    const entries = indexMap.get(key)!;\n    if (!entries.includes(entryId)) {\n      entries.push(entryId);\n    }\n  }\n\n  private removeFromIndex(indexMap: Map<string, string[]>, key: string, entryId: string): void {\n    const entries = indexMap.get(key);\n    if (entries) {\n      const index = entries.indexOf(entryId);\n      if (index > -1) {\n        entries.splice(index, 1);\n      }\n      if (entries.length === 0) {\n        indexMap.delete(key);\n      }\n    }\n  }\n\n  private extractWords(value: any): string[] {\n    const text = typeof value === 'string' ? value : JSON.stringify(value);\n    return text\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter((word) => word.length > 2);\n  }\n\n  private updateCache(key: string, entry: MemoryEntry): void {\n    if (this.cache.size >= this.config.cacheSize) {\n      this.evictCache();\n    }\n\n    this.cache.set(key, {\n      entry: { ...entry },\n      expiry: Date.now() + this.config.cacheTtl,\n    });\n  }\n\n  private evictCache(): void {\n    const entries = Array.from(this.cache.entries());\n    entries.sort((a, b) => a[1].expiry - b[1].expiry);\n\n    const toRemove = entries.slice(0, Math.floor(this.config.cacheSize * 0.1));\n    toRemove.forEach(([key]) => this.cache.delete(key));\n  }\n\n  private recordMetric(operation: string, duration: number): void {\n    const current = this.operationMetrics.get(operation) || { count: 0, totalTime: 0 };\n    current.count++;\n    current.totalTime += duration;\n    this.operationMetrics.set(operation, current);\n  }\n\n  private initializeStatistics(): MemoryStatistics {\n    return {\n      overview: {\n        totalEntries: 0,\n        totalSize: 0,\n        compressedEntries: 0,\n        compressionRatio: 0,\n        indexSize: 0,\n        memoryUsage: 0,\n        diskUsage: 0,\n      },\n      distribution: {\n        byNamespace: {},\n        byType: {},\n        byOwner: {},\n        byAccessLevel: {},\n      },\n      temporal: {\n        entriesCreatedLast24h: 0,\n        entriesUpdatedLast24h: 0,\n        entriesAccessedLast24h: 0,\n      },\n      performance: {\n        averageQueryTime: 0,\n        averageWriteTime: 0,\n        cacheHitRatio: 0,\n        indexEfficiency: 0,\n      },\n      health: {\n        expiredEntries: 0,\n        orphanedReferences: 0,\n        duplicateKeys: 0,\n        corruptedEntries: 0,\n        recommendedCleanup: false,\n      },\n      optimization: {\n        suggestions: [],\n        potentialSavings: {\n          compression: 0,\n          cleanup: 0,\n          deduplication: 0,\n        },\n        indexOptimization: [],\n      },\n    };\n  }\n\n  // === COMPLEX IMPLEMENTATION METHODS ===\n  // These would be fully implemented in a production system\n\n  private queryWithIndex(options: QueryOptions): MemoryEntry[] {\n    // Implementation would use the index for efficient querying\n    return Array.from(this.entries.values());\n  }\n\n  private matchesQuery(entry: MemoryEntry, options: QueryOptions): boolean {\n    // Comprehensive query matching logic\n    if (options.namespace && entry.namespace !== options.namespace) return false;\n    if (options.type && entry.type !== options.type) return false;\n    if (options.owner && entry.owner !== options.owner) return false;\n    if (options.accessLevel && entry.accessLevel !== options.accessLevel) return false;\n\n    if (options.tags && options.tags.length > 0) {\n      const hasAllTags = options.tags.every((tag) => entry.tags.includes(tag));\n      if (!hasAllTags) return false;\n    }\n\n    if (options.keyPattern) {\n      const regex = new RegExp(options.keyPattern, 'i');\n      if (!regex.test(entry.key)) return false;\n    }\n\n    if (options.valueSearch) {\n      const valueStr = JSON.stringify(entry.value).toLowerCase();\n      if (!valueStr.includes(options.valueSearch.toLowerCase())) return false;\n    }\n\n    // Date range checks\n    if (options.createdAfter && entry.createdAt < options.createdAfter) return false;\n    if (options.createdBefore && entry.createdAt > options.createdBefore) return false;\n    if (options.updatedAfter && entry.updatedAt < options.updatedAfter) return false;\n    if (options.updatedBefore && entry.updatedAt > options.updatedBefore) return false;\n\n    // Size checks\n    if (options.sizeGreaterThan && entry.size <= options.sizeGreaterThan) return false;\n    if (options.sizeLessThan && entry.size >= options.sizeLessThan) return false;\n\n    return true;\n  }\n\n  private getPropertyValue(entry: MemoryEntry, property: string): any {\n    switch (property) {\n      case 'key':\n        return entry.key;\n      case 'createdAt':\n        return entry.createdAt.getTime();\n      case 'updatedAt':\n        return entry.updatedAt.getTime();\n      case 'lastAccessedAt':\n        return entry.lastAccessedAt.getTime();\n      case 'size':\n        return entry.size;\n      case 'type':\n        return entry.type;\n      default:\n        return entry.key;\n    }\n  }\n\n  private generateAggregations(entries: MemoryEntry[], aggregateBy: string): Record<string, any> {\n    const aggregations: Record<string, any> = {};\n\n    switch (aggregateBy) {\n      case 'namespace':\n        aggregations.namespaces = this.aggregateByProperty(entries, 'namespace');\n        break;\n      case 'type':\n        aggregations.types = this.aggregateByProperty(entries, 'type');\n        break;\n      case 'owner':\n        aggregations.owners = this.aggregateByProperty(entries, 'owner');\n        break;\n      case 'tags':\n        aggregations.tags = this.aggregateByTags(entries);\n        break;\n    }\n\n    return aggregations;\n  }\n\n  private aggregateByProperty(\n    entries: MemoryEntry[],\n    property: keyof MemoryEntry,\n  ): Record<string, { count: number; totalSize: number }> {\n    const result: Record<string, { count: number; totalSize: number }> = {};\n\n    for (const entry of entries) {\n      const value = String(entry[property]);\n      if (!result[value]) {\n        result[value] = { count: 0, totalSize: 0 };\n      }\n      result[value].count++;\n      result[value].totalSize += entry.size;\n    }\n\n    return result;\n  }\n\n  private aggregateByTags(\n    entries: MemoryEntry[],\n  ): Record<string, { count: number; totalSize: number }> {\n    const result: Record<string, { count: number; totalSize: number }> = {};\n\n    for (const entry of entries) {\n      for (const tag of entry.tags) {\n        if (!result[tag]) {\n          result[tag] = { count: 0, totalSize: 0 };\n        }\n        result[tag].count++;\n        result[tag].totalSize += entry.size;\n      }\n    }\n\n    return result;\n  }\n\n  // === EXPORT/IMPORT HELPERS ===\n\n  private prepareJsonExport(entries: MemoryEntry[], options: ExportOptions): string {\n    const exportData = {\n      metadata: {\n        exportedAt: new Date().toISOString(),\n        version: '1.0',\n        totalEntries: entries.length,\n        format: 'json',\n      },\n      entries: options.includeMetadata\n        ? entries\n        : entries.map((entry) => ({\n            key: entry.key,\n            value: entry.value,\n            type: entry.type,\n            namespace: entry.namespace,\n            tags: entry.tags,\n          })),\n    };\n\n    return JSON.stringify(exportData, null, 2);\n  }\n\n  private prepareCsvExport(entries: MemoryEntry[], options: ExportOptions): string {\n    // CSV export implementation\n    const headers = ['key', 'value', 'type', 'namespace', 'tags'];\n    const rows = entries.map((entry) => [\n      entry.key,\n      JSON.stringify(entry.value),\n      entry.type,\n      entry.namespace,\n      entry.tags.join(';'),\n    ]);\n\n    return [headers, ...rows].map((row) => row.join(',')).join('\\n');\n  }\n\n  private prepareXmlExport(entries: MemoryEntry[], options: ExportOptions): string {\n    // XML export implementation\n    let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<memory>\\n';\n\n    for (const entry of entries) {\n      xml += `  <entry>\\n`;\n      xml += `    <key>${this.escapeXml(entry.key)}</key>\\n`;\n      xml += `    <value>${this.escapeXml(JSON.stringify(entry.value))}</value>\\n`;\n      xml += `    <type>${this.escapeXml(entry.type)}</type>\\n`;\n      xml += `    <namespace>${this.escapeXml(entry.namespace)}</namespace>\\n`;\n      xml += `    <tags>${this.escapeXml(entry.tags.join(','))}</tags>\\n`;\n      xml += `  </entry>\\n`;\n    }\n\n    xml += '</memory>';\n    return xml;\n  }\n\n  private prepareYamlExport(entries: MemoryEntry[], options: ExportOptions): string {\n    // YAML export implementation - simplified\n    let yaml = 'memory:\\n';\n\n    for (const entry of entries) {\n      yaml += `  - key: \"${entry.key}\"\\n`;\n      yaml += `    value: ${JSON.stringify(entry.value)}\\n`;\n      yaml += `    type: \"${entry.type}\"\\n`;\n      yaml += `    namespace: \"${entry.namespace}\"\\n`;\n      yaml += `    tags: [${entry.tags.map((t) => `\"${t}\"`).join(', ')}]\\n`;\n    }\n\n    return yaml;\n  }\n\n  private escapeXml(str: string): string {\n    return str\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;');\n  }\n\n  private parseJsonImport(content: string): any[] {\n    const data = JSON.parse(content);\n    return data.entries || data;\n  }\n\n  private parseCsvImport(content: string): any[] {\n    // Simple CSV parsing\n    const lines = content.split('\\n');\n    const headers = lines[0].split(',');\n    const entries = [];\n\n    for (let i = 1; i < lines.length; i++) {\n      const values = lines[i].split(',');\n      const entry: any = {};\n\n      for (let j = 0; j < headers.length; j++) {\n        entry[headers[j]] = values[j];\n      }\n\n      entries.push(entry);\n    }\n\n    return entries;\n  }\n\n  private parseXmlImport(content: string): any[] {\n    // XML parsing would require a proper XML parser\n    throw new Error('XML import not implemented in this example');\n  }\n\n  private parseYamlImport(content: string): any[] {\n    // YAML parsing would require a YAML parser\n    throw new Error('YAML import not implemented in this example');\n  }\n\n  private validateImportData(data: any[]): any[] {\n    return data.filter((item) => {\n      return item.key && item.value !== undefined;\n    });\n  }\n\n  private transformImportData(\n    data: any[],\n    transformation: NonNullable<ImportOptions['transformation']>,\n  ): any[] {\n    return data.map((item) => {\n      const transformed = { ...item };\n\n      // Apply key mapping\n      if (transformation.keyMapping) {\n        for (const [oldKey, newKey] of Object.entries(transformation.keyMapping)) {\n          if (transformed[oldKey] !== undefined) {\n            transformed[newKey] = transformed[oldKey];\n            delete transformed[oldKey];\n          }\n        }\n      }\n\n      // Apply value transformation\n      if (transformation.valueTransformation) {\n        transformed.value = transformation.valueTransformation(transformed.value);\n      }\n\n      // Extract metadata\n      if (transformation.metadataExtraction) {\n        transformed.metadata = transformation.metadataExtraction(transformed);\n      }\n\n      return transformed;\n    });\n  }\n\n  private async importSingleEntry(\n    item: any,\n    options: ImportOptions,\n  ): Promise<{\n    action: 'imported' | 'updated' | 'skipped' | 'conflict';\n    message?: string;\n  }> {\n    const existing = this.findEntryByKey(item.key, item.namespace || options.namespace);\n\n    if (existing) {\n      switch (options.conflictResolution) {\n        case 'skip':\n          return { action: 'skipped' };\n        case 'overwrite':\n          await this.update(item.key, item.value, { namespace: item.namespace });\n          return { action: 'updated' };\n        case 'merge':\n          await this.update(item.key, item.value, {\n            namespace: item.namespace,\n            merge: true,\n          });\n          return { action: 'updated' };\n        case 'rename':\n          const newKey = `${item.key}_imported_${Date.now()}`;\n          await this.store(newKey, item.value, {\n            namespace: item.namespace,\n            type: item.type,\n            tags: item.tags,\n            metadata: item.metadata,\n          });\n          return { action: 'imported' };\n        default:\n          return {\n            action: 'conflict',\n            message: `Key '${item.key}' already exists`,\n          };\n      }\n    } else {\n      await this.store(item.key, item.value, {\n        namespace: item.namespace || options.namespace,\n        type: item.type,\n        tags: item.tags,\n        metadata: item.metadata,\n      });\n      return { action: 'imported' };\n    }\n  }\n\n  // === STATISTICS CALCULATION ===\n\n  private calculateStatistics(): MemoryStatistics {\n    const entries = Array.from(this.entries.values());\n    const now = new Date();\n    const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    const stats: MemoryStatistics = {\n      overview: {\n        totalEntries: entries.length,\n        totalSize: entries.reduce((sum, entry) => sum + entry.size, 0),\n        compressedEntries: entries.filter((entry) => entry.compressed).length,\n        compressionRatio: 0,\n        indexSize: this.calculateIndexSize(),\n        memoryUsage: process.memoryUsage().heapUsed,\n        diskUsage: 0, // Would be calculated from actual file system\n      },\n      distribution: {\n        byNamespace: this.calculateDistribution(entries, 'namespace'),\n        byType: this.calculateDistribution(entries, 'type'),\n        byOwner: this.calculateDistribution(entries, 'owner'),\n        byAccessLevel: this.calculateDistribution(entries, 'accessLevel'),\n      },\n      temporal: {\n        entriesCreatedLast24h: entries.filter((e) => e.createdAt >= last24h).length,\n        entriesUpdatedLast24h: entries.filter((e) => e.updatedAt >= last24h).length,\n        entriesAccessedLast24h: entries.filter((e) => e.lastAccessedAt >= last24h).length,\n        oldestEntry:\n          entries.length > 0\n            ? entries.reduce((oldest, entry) =>\n                entry.createdAt < oldest.createdAt ? entry : oldest,\n              ).createdAt\n            : undefined,\n        newestEntry:\n          entries.length > 0\n            ? entries.reduce((newest, entry) =>\n                entry.createdAt > newest.createdAt ? entry : newest,\n              ).createdAt\n            : undefined,\n      },\n      performance: this.calculatePerformanceMetrics(),\n      health: this.calculateHealthMetrics(entries, now),\n      optimization: this.generateOptimizationSuggestions(entries),\n    };\n\n    // Calculate compression ratio\n    const uncompressedSize = entries\n      .filter((e) => !e.compressed)\n      .reduce((sum, e) => sum + e.size, 0);\n    const compressedSize = entries.filter((e) => e.compressed).reduce((sum, e) => sum + e.size, 0);\n    stats.overview.compressionRatio =\n      uncompressedSize > 0 ? (uncompressedSize - compressedSize) / uncompressedSize : 0;\n\n    return stats;\n  }\n\n  private calculateDistribution(\n    entries: MemoryEntry[],\n    property: keyof MemoryEntry,\n  ): Record<string, { count: number; size: number }> {\n    const distribution: Record<string, { count: number; size: number }> = {};\n\n    for (const entry of entries) {\n      const value = String(entry[property]);\n      if (!distribution[value]) {\n        distribution[value] = { count: 0, size: 0 };\n      }\n      distribution[value].count++;\n      distribution[value].size += entry.size;\n    }\n\n    return distribution;\n  }\n\n  private calculateIndexSize(): number {\n    let size = 0;\n    for (const [, entries] of this.index.keys) {\n      size += entries.length * 50; // Rough estimate\n    }\n    return size;\n  }\n\n  private calculatePerformanceMetrics(): MemoryStatistics['performance'] {\n    const queryMetrics = this.operationMetrics.get('query') || { count: 0, totalTime: 0 };\n    const writeMetrics = this.operationMetrics.get('store') || { count: 0, totalTime: 0 };\n    const cacheMetrics = this.operationMetrics.get('retrieve-cache') || { count: 0, totalTime: 0 };\n    const totalRetrieves =\n      (this.operationMetrics.get('retrieve') || { count: 0 }).count + cacheMetrics.count;\n\n    return {\n      averageQueryTime: queryMetrics.count > 0 ? queryMetrics.totalTime / queryMetrics.count : 0,\n      averageWriteTime: writeMetrics.count > 0 ? writeMetrics.totalTime / writeMetrics.count : 0,\n      cacheHitRatio: totalRetrieves > 0 ? cacheMetrics.count / totalRetrieves : 0,\n      indexEfficiency: this.config.indexingEnabled ? 0.95 : 0, // Placeholder\n    };\n  }\n\n  private calculateHealthMetrics(entries: MemoryEntry[], now: Date): MemoryStatistics['health'] {\n    const expiredEntries = entries.filter((e) => e.expiresAt && e.expiresAt < now).length;\n    const duplicateKeys = this.findDuplicateKeys(entries);\n\n    return {\n      expiredEntries,\n      orphanedReferences: 0, // Would be calculated by checking references\n      duplicateKeys: duplicateKeys.length,\n      corruptedEntries: 0, // Would be calculated by validating checksums\n      recommendedCleanup: expiredEntries > 10 || duplicateKeys.length > 5,\n    };\n  }\n\n  private generateOptimizationSuggestions(\n    entries: MemoryEntry[],\n  ): MemoryStatistics['optimization'] {\n    const suggestions: string[] = [];\n    const potentialSavings = { compression: 0, cleanup: 0, deduplication: 0 };\n\n    // Compression suggestions\n    const uncompressedLarge = entries.filter(\n      (e) => !e.compressed && e.size > this.config.compressionThreshold,\n    );\n    if (uncompressedLarge.length > 0) {\n      suggestions.push(`${uncompressedLarge.length} entries could benefit from compression`);\n      potentialSavings.compression = uncompressedLarge.reduce((sum, e) => sum + e.size * 0.6, 0);\n    }\n\n    // Cleanup suggestions\n    const now = new Date();\n    const oldEntries = entries.filter(\n      (e) => now.getTime() - e.lastAccessedAt.getTime() > 30 * 24 * 60 * 60 * 1000,\n    );\n    if (oldEntries.length > 0) {\n      suggestions.push(`${oldEntries.length} entries haven't been accessed in 30+ days`);\n      potentialSavings.cleanup = oldEntries.reduce((sum, e) => sum + e.size, 0);\n    }\n\n    // Deduplication suggestions\n    const duplicates = this.findDuplicateKeys(entries);\n    if (duplicates.length > 0) {\n      suggestions.push(`${duplicates.length} duplicate keys found`);\n      potentialSavings.deduplication = duplicates.reduce(\n        (sum, group) => sum + group.entries.slice(1).reduce((s, e) => s + e.size, 0),\n        0,\n      );\n    }\n\n    return {\n      suggestions,\n      potentialSavings,\n      indexOptimization: this.config.indexingEnabled\n        ? ['Consider periodic index rebuilding for optimal performance']\n        : ['Enable indexing for better query performance'],\n    };\n  }\n\n  private findDuplicateKeys(\n    entries: MemoryEntry[],\n  ): Array<{ key: string; namespace: string; entries: MemoryEntry[] }> {\n    const keyMap = new Map<string, MemoryEntry[]>();\n\n    for (const entry of entries) {\n      const compositeKey = `${entry.namespace}:${entry.key}`;\n      if (!keyMap.has(compositeKey)) {\n        keyMap.set(compositeKey, []);\n      }\n      keyMap.get(compositeKey)!.push(entry);\n    }\n\n    const duplicates: Array<{ key: string; namespace: string; entries: MemoryEntry[] }> = [];\n    for (const [compositeKey, entryList] of keyMap) {\n      if (entryList.length > 1) {\n        const [namespace, key] = compositeKey.split(':', 2);\n        duplicates.push({ key, namespace, entries: entryList });\n      }\n    }\n\n    return duplicates;\n  }\n\n  // === CLEANUP IMPLEMENTATION ===\n\n  private async applyRetentionPolicies(entry: MemoryEntry): Promise<void> {\n    // Apply matching retention policies to the entry\n    for (const policy of this.retentionPolicies.values()) {\n      if (this.policyMatches(policy, entry)) {\n        await this.enforceRetentionPolicy(policy, entry);\n      }\n    }\n  }\n\n  private policyMatches(policy: RetentionPolicy, entry: MemoryEntry): boolean {\n    if (policy.namespace && entry.namespace !== policy.namespace) return false;\n    if (policy.type && entry.type !== policy.type) return false;\n    if (policy.tags && !policy.tags.every((tag) => entry.tags.includes(tag))) return false;\n    return true;\n  }\n\n  private async enforceRetentionPolicy(policy: RetentionPolicy, entry: MemoryEntry): Promise<void> {\n    const now = new Date();\n\n    // Check age limit\n    if (policy.maxAge) {\n      const ageInDays = (now.getTime() - entry.createdAt.getTime()) / (24 * 60 * 60 * 1000);\n      if (ageInDays > policy.maxAge) {\n        await this.deleteEntry(entry.id);\n        return;\n      }\n    }\n\n    // Count and size limits would require more complex logic\n    // This is a simplified implementation\n  }\n\n  private async applyRetentionPolicy(\n    policy: CleanupOptions['retentionPolicies'][0],\n    dryRun?: boolean,\n  ): Promise<{ removed: number; spaceSaved: number }> {\n    const matchingEntries = Array.from(this.entries.values()).filter((entry) => {\n      if (policy.namespace && entry.namespace !== policy.namespace) return false;\n      return true;\n    });\n\n    let toRemove: MemoryEntry[] = [];\n    const now = new Date();\n\n    // Apply age limit\n    if (policy.maxAge) {\n      const cutoffDate = new Date(now.getTime() - policy.maxAge * 24 * 60 * 60 * 1000);\n      toRemove = matchingEntries.filter((entry) => entry.createdAt < cutoffDate);\n    }\n\n    // Apply count limit\n    if (policy.maxCount && matchingEntries.length > policy.maxCount) {\n      const sorted = matchingEntries.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n      toRemove = sorted.slice(0, matchingEntries.length - policy.maxCount);\n    }\n\n    // Apply size limit\n    if (policy.sizeLimit) {\n      const totalSize = matchingEntries.reduce((sum, entry) => sum + entry.size, 0);\n      if (totalSize > policy.sizeLimit) {\n        const sorted = matchingEntries.sort(\n          (a, b) => a.lastAccessedAt.getTime() - b.lastAccessedAt.getTime(),\n        );\n        let currentSize = totalSize;\n        toRemove = [];\n\n        for (const entry of sorted) {\n          if (currentSize <= policy.sizeLimit) break;\n          toRemove.push(entry);\n          currentSize -= entry.size;\n        }\n      }\n    }\n\n    const spaceSaved = toRemove.reduce((sum, entry) => sum + entry.size, 0);\n\n    if (!dryRun) {\n      for (const entry of toRemove) {\n        await this.deleteEntry(entry.id);\n      }\n    }\n\n    return { removed: toRemove.length, spaceSaved };\n  }\n\n  private async cleanupOrphanedReferences(dryRun?: boolean): Promise<number> {\n    // Implementation would check for broken references between entries\n    return 0;\n  }\n\n  private async removeDuplicateEntries(\n    dryRun?: boolean,\n  ): Promise<{ removed: number; spaceSaved: number }> {\n    const duplicates = this.findDuplicateKeys(Array.from(this.entries.values()));\n    let removed = 0;\n    let spaceSaved = 0;\n\n    for (const duplicate of duplicates) {\n      // Keep the newest entry, remove others\n      const sorted = duplicate.entries.sort(\n        (a, b) => b.updatedAt.getTime() - a.updatedAt.getTime(),\n      );\n      const toRemove = sorted.slice(1);\n\n      for (const entry of toRemove) {\n        spaceSaved += entry.size;\n        removed++;\n\n        if (!dryRun) {\n          await this.deleteEntry(entry.id);\n        }\n      }\n    }\n\n    return { removed, spaceSaved };\n  }\n\n  private async archiveEntries(entries: MemoryEntry[], archivePath: string): Promise<void> {\n    const archiveData = {\n      archivedAt: new Date().toISOString(),\n      entries: entries,\n    };\n\n    const archiveFile = join(archivePath, `archive-${Date.now()}.json`);\n    await fs.mkdir(dirname(archiveFile), { recursive: true });\n    await fs.writeFile(archiveFile, JSON.stringify(archiveData, null, 2));\n\n    // Remove archived entries from active memory\n    for (const entry of entries) {\n      await this.deleteEntry(entry.id);\n    }\n  }\n\n  private async rebuildIndex(): Promise<void> {\n    this.logger.info('Rebuilding memory index');\n\n    this.index = this.createEmptyIndex();\n\n    for (const entry of this.entries.values()) {\n      this.updateIndex(entry, 'create');\n    }\n\n    this.logger.info('Memory index rebuilt successfully');\n  }\n\n  private startAutoCleanup(): void {\n    this.cleanupInterval = setInterval(async () => {\n      try {\n        await this.cleanup({\n          removeExpired: true,\n          removeUnaccessed: 7, // Remove entries not accessed in 7 days\n          compressEligible: true,\n        });\n      } catch (error) {\n        this.logger.error('Auto cleanup failed', error);\n      }\n    }, this.config.cleanupInterval);\n  }\n\n  // === PERSISTENCE ===\n\n  private async loadPersistedData(): Promise<void> {\n    try {\n      const dataFile = join(this.dataPath, 'entries.json');\n      const indexFile = join(this.indexPath, 'index.json');\n\n      // Load entries\n      try {\n        const entriesData = await fs.readFile(dataFile, 'utf-8');\n        const entriesArray = JSON.parse(entriesData);\n\n        for (const entryData of entriesArray) {\n          // Convert date strings back to Date objects\n          entryData.createdAt = new Date(entryData.createdAt);\n          entryData.updatedAt = new Date(entryData.updatedAt);\n          entryData.lastAccessedAt = new Date(entryData.lastAccessedAt);\n          if (entryData.expiresAt) {\n            entryData.expiresAt = new Date(entryData.expiresAt);\n          }\n\n          this.entries.set(entryData.id, entryData);\n        }\n\n        this.logger.info(`Loaded ${entriesArray.length} entries from persistence`);\n      } catch (error) {\n        // File doesn't exist or is corrupted\n        this.logger.info('No persisted entries found, starting fresh');\n      }\n\n      // Rebuild index\n      if (this.config.indexingEnabled) {\n        await this.rebuildIndex();\n      }\n    } catch (error) {\n      this.logger.error('Failed to load persisted data', error);\n    }\n  }\n\n  private async persistData(): Promise<void> {\n    try {\n      const dataFile = join(this.dataPath, 'entries.json');\n      const entriesArray = Array.from(this.entries.values());\n\n      await fs.writeFile(dataFile, JSON.stringify(entriesArray, null, 2));\n      this.logger.info(`Persisted ${entriesArray.length} entries`);\n    } catch (error) {\n      this.logger.error('Failed to persist data', error);\n    }\n  }\n\n  private async createBackup(): Promise<void> {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const backupFile = join(this.backupPath, `backup-${timestamp}.json`);\n\n      const backup = {\n        timestamp: new Date().toISOString(),\n        version: '1.0',\n        entries: Array.from(this.entries.values()),\n        statistics: await this.getStatistics(),\n      };\n\n      await fs.writeFile(backupFile, JSON.stringify(backup, null, 2));\n      this.logger.info(`Created backup: ${backupFile}`);\n\n      // Clean old backups\n      await this.cleanOldBackups();\n    } catch (error) {\n      this.logger.error('Failed to create backup', error);\n    }\n  }\n\n  private async cleanOldBackups(): Promise<void> {\n    try {\n      const files = await fs.readdir(this.backupPath);\n      const backupFiles = files.filter((f) => f.startsWith('backup-') && f.endsWith('.json'));\n\n      if (backupFiles.length <= this.config.backupRetention) {\n        return;\n      }\n\n      // Sort by creation time and remove oldest\n      const fileStats = await Promise.all(\n        backupFiles.map(async (file) => ({\n          file,\n          stat: await fs.stat(join(this.backupPath, file)),\n        })),\n      );\n\n      fileStats.sort((a, b) => a.stat.mtime.getTime() - b.stat.mtime.getTime());\n\n      const toDelete = fileStats.slice(0, fileStats.length - this.config.backupRetention);\n\n      for (const { file } of toDelete) {\n        await fs.unlink(join(this.backupPath, file));\n        this.logger.debug(`Deleted old backup: ${file}`);\n      }\n    } catch (error) {\n      this.logger.error('Failed to clean old backups', error);\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private async compressData(data: string): Promise<string> {\n    // In a real implementation, you would use a compression library\n    return data;\n  }\n\n  private async encryptData(\n    data: string,\n    encryption: NonNullable<ExportOptions['encryption']>,\n  ): Promise<string> {\n    // In a real implementation, you would use a proper encryption library\n    return data;\n  }\n\n  // === PUBLIC API ===\n\n  async listNamespaces(): Promise<string[]> {\n    const namespaces = new Set<string>();\n    for (const entry of this.entries.values()) {\n      namespaces.add(entry.namespace);\n    }\n    return Array.from(namespaces).sort();\n  }\n\n  async listTypes(): Promise<string[]> {\n    const types = new Set<string>();\n    for (const entry of this.entries.values()) {\n      types.add(entry.type);\n    }\n    return Array.from(types).sort();\n  }\n\n  async listTags(): Promise<string[]> {\n    const tags = new Set<string>();\n    for (const entry of this.entries.values()) {\n      entry.tags.forEach((tag) => tags.add(tag));\n    }\n    return Array.from(tags).sort();\n  }\n\n  async getEntryById(id: string): Promise<MemoryEntry | null> {\n    return this.entries.get(id) || null;\n  }\n\n  async exists(key: string, namespace?: string): Promise<boolean> {\n    return this.findEntryByKey(key, namespace) !== undefined;\n  }\n\n  async count(options: Partial<QueryOptions> = {}): Promise<number> {\n    const result = await this.query({ ...options, limit: 0 });\n    return result.total;\n  }\n\n  async clear(namespace?: string): Promise<number> {\n    const entries = Array.from(this.entries.values());\n    const toDelete = namespace ? entries.filter((entry) => entry.namespace === namespace) : entries;\n\n    for (const entry of toDelete) {\n      await this.deleteEntry(entry.id);\n    }\n\n    return toDelete.length;\n  }\n\n  getConfiguration(): typeof this.config {\n    return { ...this.config };\n  }\n\n  async updateConfiguration(updates: Partial<typeof this.config>): Promise<void> {\n    this.config = { ...this.config, ...updates };\n\n    // Apply configuration changes\n    if (updates.autoCleanup !== undefined) {\n      if (updates.autoCleanup && !this.cleanupInterval) {\n        this.startAutoCleanup();\n      } else if (!updates.autoCleanup && this.cleanupInterval) {\n        clearInterval(this.cleanupInterval);\n        this.cleanupInterval = undefined;\n      }\n    }\n\n    this.emit('memory:configuration-updated', { config: this.config });\n  }\n}\n"],"names":["EventEmitter","promises","fs","createHash","join","dirname","fileURLToPath","generateId","AdvancedMemoryManager","dataPath","indexPath","backupPath","archivePath","entries","Map","index","cache","retentionPolicies","logger","config","statistics","operationMetrics","cleanupInterval","maxMemorySize","cacheSize","cacheTtl","autoCompress","autoCleanup","indexingEnabled","persistenceEnabled","compressionThreshold","backupRetention","__dirname","url","process","cwd","createEmptyIndex","initializeStatistics","initialize","info","Promise","all","mkdir","recursive","loadPersistedData","startAutoCleanup","emit","shutdown","clearInterval","persistData","createBackup","store","key","value","options","startTime","Date","now","entryId","processedValue","processValue","compress","size","calculateSize","entry","id","type","inferType","namespace","tags","metadata","owner","accessLevel","createdAt","updatedAt","lastAccessedAt","expiresAt","ttl","getTime","undefined","version","compressed","checksum","calculateChecksum","references","dependencies","set","updateIndex","updateCache","applyRetentionPolicies","debug","recordMetric","error","retrieve","cached","get","expiry","findEntryByKey","deleteEntry","updateLastAccessed","decompressValue","update","merge","updateMetadata","delete","query","candidateEntries","queryWithIndex","Array","from","values","filteredEntries","filter","matchesQuery","includeExpired","setTimeout","total","length","sortBy","sort","a","b","aVal","getPropertyValue","bVal","multiplier","sortOrder","offset","limit","paginatedEntries","slice","forEach","aggregations","aggregateBy","generateAggregations","export","filePath","format","queryResult","filtering","Error","exportData","prepareJsonExport","prepareCsvExport","prepareXmlExport","prepareYamlExport","compression","compressData","encryption","enabled","encryptData","writeFile","stats","stat","entriesExported","fileSize","import","fileContent","readFile","importData","parseJsonImport","parseCsvImport","parseXmlImport","parseYamlImport","validation","validateImportData","transformation","transformImportData","results","entriesImported","entriesSkipped","entriesUpdated","conflicts","item","dryRun","existing","push","result","importSingleEntry","action","message","String","getStatistics","calculateStatistics","cleanup","entriesRemoved","entriesArchived","entriesCompressed","spaceSaved","actions","allEntries","removeExpired","expiredEntries","removeOlderThan","cutoffDate","oldEntries","removeUnaccessed","unaccessedEntries","archiveOld","olderThan","archiveEntries","compressEligible","uncompressedEntries","originalSize","compressedValue","compressValue","policy","policyResults","applyRetentionPolicy","removed","removeOrphaned","orphanedCount","cleanupOrphanedReferences","removeDuplicates","duplicatesResults","removeDuplicateEntries","rebuildIndex","keys","types","namespaces","owners","fullText","isCompressed","JSON","stringify","parse","digest","isArray","operation","removeFromIndex","tag","words","extractWords","word","addToIndex","indexMap","has","includes","indexOf","splice","text","toLowerCase","replace","split","evictCache","toRemove","Math","floor","duration","current","count","totalTime","overview","totalEntries","totalSize","compressedEntries","compressionRatio","indexSize","memoryUsage","diskUsage","distribution","byNamespace","byType","byOwner","byAccessLevel","temporal","entriesCreatedLast24h","entriesUpdatedLast24h","entriesAccessedLast24h","performance","averageQueryTime","averageWriteTime","cacheHitRatio","indexEfficiency","health","orphanedReferences","duplicateKeys","corruptedEntries","recommendedCleanup","optimization","suggestions","potentialSavings","deduplication","indexOptimization","hasAllTags","every","keyPattern","regex","RegExp","test","valueSearch","valueStr","createdAfter","createdBefore","updatedAfter","updatedBefore","sizeGreaterThan","sizeLessThan","property","aggregateByProperty","aggregateByTags","exportedAt","toISOString","includeMetadata","map","headers","rows","row","xml","escapeXml","yaml","t","str","content","data","lines","i","j","transformed","keyMapping","oldKey","newKey","Object","valueTransformation","metadataExtraction","conflictResolution","last24h","reduce","sum","calculateIndexSize","heapUsed","calculateDistribution","e","oldestEntry","oldest","newestEntry","newest","calculatePerformanceMetrics","calculateHealthMetrics","generateOptimizationSuggestions","uncompressedSize","compressedSize","queryMetrics","writeMetrics","cacheMetrics","totalRetrieves","findDuplicateKeys","uncompressedLarge","duplicates","group","s","keyMap","compositeKey","entryList","policyMatches","enforceRetentionPolicy","maxAge","ageInDays","matchingEntries","maxCount","sorted","sizeLimit","currentSize","duplicate","archiveData","archivedAt","archiveFile","setInterval","dataFile","indexFile","entriesData","entriesArray","entryData","timestamp","backupFile","backup","cleanOldBackups","files","readdir","backupFiles","f","startsWith","endsWith","fileStats","file","mtime","toDelete","unlink","listNamespaces","Set","add","listTypes","listTags","getEntryById","exists","clear","getConfiguration","updateConfiguration","updates"],"mappings":"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"}