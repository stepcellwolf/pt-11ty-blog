{"version":3,"sources":["../../../src/memory/enhanced-memory.js"],"sourcesContent":["/**\n * Enhanced Memory Functions for Comprehensive Swarm Coordination\n * Version 2: Works with both SQLite and in-memory fallback stores\n */\n\nimport { FallbackMemoryStore } from './fallback-store.js';\n\nexport class EnhancedMemory extends FallbackMemoryStore {\n  constructor(options = {}) {\n    super(options);\n  }\n\n  async initialize() {\n    await super.initialize();\n\n    // If using SQLite, try to apply enhanced schema\n    if (!this.isUsingFallback() && this.primaryStore?.db) {\n      try {\n        const { readFileSync } = await import('fs');\n        const schemaPath = new URL('./enhanced-schema.sql', import.meta.url);\n        const schema = readFileSync(schemaPath, 'utf-8');\n        this.primaryStore.db.exec(schema);\n        console.error(\n          `[${new Date().toISOString()}] INFO [enhanced-memory] Applied enhanced schema to SQLite`,\n        );\n      } catch (error) {\n        console.error(\n          `[${new Date().toISOString()}] WARN [enhanced-memory] Could not apply enhanced schema:`,\n          error.message,\n        );\n      }\n    }\n  }\n\n  // === SESSION MANAGEMENT ===\n\n  async saveSessionState(sessionId, state) {\n    const sessionData = {\n      sessionId,\n      userId: state.userId || process.env.USER,\n      projectPath: state.projectPath || process.cwd(),\n      activeBranch: state.activeBranch || 'main',\n      lastActivity: Date.now(),\n      state: state.state || 'active',\n      context: state.context || {},\n      environment: state.environment || process.env,\n    };\n\n    return this.store(`session:${sessionId}`, sessionData, {\n      namespace: 'sessions',\n      metadata: { type: 'session_state' },\n    });\n  }\n\n  async resumeSession(sessionId) {\n    return this.retrieve(`session:${sessionId}`, { namespace: 'sessions' });\n  }\n\n  async getActiveSessions() {\n    const sessions = await this.list({ namespace: 'sessions', limit: 100 });\n    return sessions.map((item) => item.value).filter((session) => session.state === 'active');\n  }\n\n  // === WORKFLOW TRACKING ===\n\n  async trackWorkflow(workflowId, data) {\n    const workflowData = {\n      workflowId,\n      name: data.name,\n      steps: data.steps || [],\n      status: data.status || 'pending',\n      progress: data.progress || 0,\n      startTime: data.startTime || Date.now(),\n      endTime: data.endTime,\n      results: data.results || {},\n    };\n\n    return this.store(`workflow:${workflowId}`, workflowData, {\n      namespace: 'workflows',\n      metadata: { type: 'workflow' },\n    });\n  }\n\n  async getWorkflowStatus(workflowId) {\n    return this.retrieve(`workflow:${workflowId}`, { namespace: 'workflows' });\n  }\n\n  // === METRICS COLLECTION ===\n\n  async recordMetric(metricName, value, metadata = {}) {\n    const timestamp = Date.now();\n    const metricKey = `metric:${metricName}:${timestamp}`;\n\n    return this.store(\n      metricKey,\n      {\n        name: metricName,\n        value,\n        timestamp,\n        metadata,\n      },\n      {\n        namespace: 'metrics',\n        ttl: 86400, // 24 hours\n      },\n    );\n  }\n\n  async getMetrics(metricName, timeRange = 3600000) {\n    // Default 1 hour\n    const cutoff = Date.now() - timeRange;\n    const metrics = await this.search(`metric:${metricName}`, {\n      namespace: 'metrics',\n      limit: 1000,\n    });\n\n    return metrics\n      .map((item) => item.value)\n      .filter((metric) => metric.timestamp >= cutoff)\n      .sort((a, b) => a.timestamp - b.timestamp);\n  }\n\n  // === AGENT COORDINATION ===\n\n  async registerAgent(agentId, config) {\n    const agentData = {\n      agentId,\n      type: config.type,\n      capabilities: config.capabilities || [],\n      status: 'active',\n      createdAt: Date.now(),\n      lastHeartbeat: Date.now(),\n      metrics: {\n        tasksCompleted: 0,\n        successRate: 1.0,\n        avgResponseTime: 0,\n      },\n    };\n\n    return this.store(`agent:${agentId}`, agentData, {\n      namespace: 'agents',\n      metadata: { type: 'agent_registration' },\n    });\n  }\n\n  async updateAgentStatus(agentId, status, metrics = {}) {\n    const agent = await this.retrieve(`agent:${agentId}`, { namespace: 'agents' });\n    if (!agent) return null;\n\n    agent.status = status;\n    agent.lastHeartbeat = Date.now();\n\n    if (metrics) {\n      Object.assign(agent.metrics, metrics);\n    }\n\n    return this.store(`agent:${agentId}`, agent, {\n      namespace: 'agents',\n      metadata: { type: 'agent_update' },\n    });\n  }\n\n  async getActiveAgents() {\n    const agents = await this.list({ namespace: 'agents', limit: 100 });\n    const cutoff = Date.now() - 300000; // 5 minutes\n\n    return agents\n      .map((item) => item.value)\n      .filter((agent) => agent.lastHeartbeat > cutoff && agent.status === 'active');\n  }\n\n  // === KNOWLEDGE MANAGEMENT ===\n\n  async storeKnowledge(domain, key, value, metadata = {}) {\n    return this.store(\n      `knowledge:${domain}:${key}`,\n      {\n        domain,\n        key,\n        value,\n        metadata,\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      },\n      {\n        namespace: 'knowledge',\n        metadata: { domain },\n      },\n    );\n  }\n\n  async retrieveKnowledge(domain, key) {\n    return this.retrieve(`knowledge:${domain}:${key}`, { namespace: 'knowledge' });\n  }\n\n  async searchKnowledge(domain, pattern) {\n    const results = await this.search(`knowledge:${domain}:${pattern}`, {\n      namespace: 'knowledge',\n      limit: 50,\n    });\n\n    return results.map((item) => item.value);\n  }\n\n  // === LEARNING & ADAPTATION ===\n\n  async recordLearning(agentId, learning) {\n    const learningData = {\n      agentId,\n      timestamp: Date.now(),\n      type: learning.type,\n      input: learning.input,\n      output: learning.output,\n      feedback: learning.feedback,\n      improvement: learning.improvement,\n    };\n\n    return this.store(`learning:${agentId}:${Date.now()}`, learningData, {\n      namespace: 'learning',\n      ttl: 604800, // 7 days\n    });\n  }\n\n  async getLearnings(agentId, limit = 100) {\n    const learnings = await this.search(`learning:${agentId}`, {\n      namespace: 'learning',\n      limit,\n    });\n\n    return learnings.map((item) => item.value).sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  // === PERFORMANCE TRACKING ===\n\n  async trackPerformance(operation, duration, success = true, metadata = {}) {\n    const perfData = {\n      operation,\n      duration,\n      success,\n      timestamp: Date.now(),\n      metadata,\n    };\n\n    // Store individual performance record\n    await this.store(`perf:${operation}:${Date.now()}`, perfData, {\n      namespace: 'performance',\n      ttl: 86400, // 24 hours\n    });\n\n    // Update aggregated stats\n    const statsKey = `stats:${operation}`;\n    const stats = (await this.retrieve(statsKey, { namespace: 'performance' })) || {\n      count: 0,\n      successCount: 0,\n      totalDuration: 0,\n      avgDuration: 0,\n      minDuration: Infinity,\n      maxDuration: 0,\n    };\n\n    stats.count++;\n    if (success) stats.successCount++;\n    stats.totalDuration += duration;\n    stats.avgDuration = stats.totalDuration / stats.count;\n    stats.minDuration = Math.min(stats.minDuration, duration);\n    stats.maxDuration = Math.max(stats.maxDuration, duration);\n    stats.successRate = stats.successCount / stats.count;\n\n    return this.store(statsKey, stats, { namespace: 'performance' });\n  }\n\n  async getPerformanceStats(operation) {\n    return this.retrieve(`stats:${operation}`, { namespace: 'performance' });\n  }\n\n  // === COORDINATION CACHE ===\n\n  async cacheCoordination(key, value, ttl = 300) {\n    // 5 minutes default\n    return this.store(`cache:${key}`, value, {\n      namespace: 'coordination',\n      ttl,\n    });\n  }\n\n  async getCachedCoordination(key) {\n    return this.retrieve(`cache:${key}`, { namespace: 'coordination' });\n  }\n\n  // === UTILITY METHODS ===\n\n  async cleanupExpired() {\n    // Base cleanup handles TTL expiration\n    const cleaned = await this.cleanup();\n\n    // Additional cleanup for old performance data\n    if (!this.isUsingFallback()) {\n      // SQLite-specific cleanup can be added here\n    }\n\n    return cleaned;\n  }\n\n  async exportData(namespace = null) {\n    const namespaces = namespace\n      ? [namespace]\n      : [\n          'sessions',\n          'workflows',\n          'metrics',\n          'agents',\n          'knowledge',\n          'learning',\n          'performance',\n          'coordination',\n        ];\n\n    const exportData = {};\n\n    for (const ns of namespaces) {\n      exportData[ns] = await this.list({ namespace: ns, limit: 10000 });\n    }\n\n    return exportData;\n  }\n\n  async importData(data) {\n    for (const [namespace, items] of Object.entries(data)) {\n      for (const item of items) {\n        await this.store(item.key, item.value, {\n          namespace,\n          metadata: item.metadata,\n        });\n      }\n    }\n  }\n}\n\nexport default EnhancedMemory;\n"],"names":["FallbackMemoryStore","EnhancedMemory","options","initialize","isUsingFallback","primaryStore","db","readFileSync","schemaPath","URL","url","schema","exec","console","error","Date","toISOString","message","saveSessionState","sessionId","state","sessionData","userId","process","env","USER","projectPath","cwd","activeBranch","lastActivity","now","context","environment","store","namespace","metadata","type","resumeSession","retrieve","getActiveSessions","sessions","list","limit","map","item","value","filter","session","trackWorkflow","workflowId","data","workflowData","name","steps","status","progress","startTime","endTime","results","getWorkflowStatus","recordMetric","metricName","timestamp","metricKey","ttl","getMetrics","timeRange","cutoff","metrics","search","metric","sort","a","b","registerAgent","agentId","config","agentData","capabilities","createdAt","lastHeartbeat","tasksCompleted","successRate","avgResponseTime","updateAgentStatus","agent","Object","assign","getActiveAgents","agents","storeKnowledge","domain","key","updatedAt","retrieveKnowledge","searchKnowledge","pattern","recordLearning","learning","learningData","input","output","feedback","improvement","getLearnings","learnings","trackPerformance","operation","duration","success","perfData","statsKey","stats","count","successCount","totalDuration","avgDuration","minDuration","Infinity","maxDuration","Math","min","max","getPerformanceStats","cacheCoordination","getCachedCoordination","cleanupExpired","cleaned","cleanup","exportData","namespaces","ns","importData","items","entries"],"mappings":"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"}