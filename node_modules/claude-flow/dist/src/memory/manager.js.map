{"version":3,"sources":["../../../src/memory/manager.ts"],"sourcesContent":["/**\n * Memory manager interface and implementation\n */\n\nimport type { MemoryEntry, MemoryQuery, MemoryConfig } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MemoryError } from '../utils/errors.js';\nimport type { IMemoryBackend } from './backends/base.js';\nimport { SQLiteBackend } from './backends/sqlite.js';\nimport { MarkdownBackend } from './backends/markdown.js';\nimport { MemoryCache } from './cache.js';\nimport { MemoryIndexer } from './indexer.js';\n\nexport interface IMemoryManager {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  createBank(agentId: string): Promise<string>;\n  closeBank(bankId: string): Promise<void>;\n  store(entry: MemoryEntry): Promise<void>;\n  retrieve(id: string): Promise<MemoryEntry | undefined>;\n  query(query: MemoryQuery): Promise<MemoryEntry[]>;\n  update(id: string, updates: Partial<MemoryEntry>): Promise<void>;\n  delete(id: string): Promise<void>;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  performMaintenance(): Promise<void>;\n}\n\n/**\n * Memory bank for agent-specific storage\n */\ninterface MemoryBank {\n  id: string;\n  agentId: string;\n  createdAt: Date;\n  lastAccessed: Date;\n  entryCount: number;\n}\n\n/**\n * Memory manager implementation\n */\nexport class MemoryManager implements IMemoryManager {\n  private backend: IMemoryBackend;\n  private cache: MemoryCache;\n  private indexer: MemoryIndexer;\n  private banks = new Map<string, MemoryBank>();\n  private initialized = false;\n  private syncInterval?: number;\n\n  constructor(\n    private config: MemoryConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    // Initialize backend based on configuration\n    this.backend = this.createBackend();\n\n    // Initialize cache\n    this.cache = new MemoryCache(\n      this.config.cacheSizeMB * 1024 * 1024, // Convert MB to bytes\n      this.logger,\n    );\n\n    // Initialize indexer\n    this.indexer = new MemoryIndexer(this.logger);\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    this.logger.info('Initializing memory manager...');\n\n    try {\n      // Initialize backend\n      await this.backend.initialize();\n\n      // Initialize indexer with existing entries\n      const allEntries = await this.backend.getAllEntries();\n      await this.indexer.buildIndex(allEntries);\n\n      // Start sync interval\n      this.startSyncInterval();\n\n      this.initialized = true;\n      this.logger.info('Memory manager initialized');\n    } catch (error) {\n      this.logger.error('Failed to initialize memory manager', error);\n      throw new MemoryError('Memory manager initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down memory manager...');\n\n    try {\n      // Stop sync interval\n      if (this.syncInterval) {\n        clearInterval(this.syncInterval);\n      }\n\n      // Flush cache\n      await this.flushCache();\n\n      // Close all banks\n      const bankIds = Array.from(this.banks.keys());\n      await Promise.all(bankIds.map((id) => this.closeBank(id)));\n\n      // Shutdown backend\n      await this.backend.shutdown();\n\n      this.initialized = false;\n      this.logger.info('Memory manager shutdown complete');\n    } catch (error) {\n      this.logger.error('Error during memory manager shutdown', error);\n      throw error;\n    }\n  }\n\n  async createBank(agentId: string): Promise<string> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    const bank: MemoryBank = {\n      id: `bank_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      agentId,\n      createdAt: new Date(),\n      lastAccessed: new Date(),\n      entryCount: 0,\n    };\n\n    this.banks.set(bank.id, bank);\n\n    this.logger.info('Memory bank created', { bankId: bank.id, agentId });\n\n    return bank.id;\n  }\n\n  async closeBank(bankId: string): Promise<void> {\n    const bank = this.banks.get(bankId);\n    if (!bank) {\n      throw new MemoryError(`Memory bank not found: ${bankId}`);\n    }\n\n    // Flush any cached entries for this bank\n    const bankEntries = this.cache.getByPrefix(`${bank.agentId}:`);\n    for (const entry of bankEntries) {\n      await this.backend.store(entry);\n    }\n\n    this.banks.delete(bankId);\n\n    this.logger.info('Memory bank closed', { bankId });\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    this.logger.debug('Storing memory entry', {\n      id: entry.id,\n      type: entry.type,\n      agentId: entry.agentId,\n    });\n\n    try {\n      // Add to cache\n      this.cache.set(entry.id, entry);\n\n      // Add to index\n      this.indexer.addEntry(entry);\n\n      // Store in backend (async, don't wait)\n      this.backend.store(entry).catch((error) => {\n        this.logger.error('Failed to store entry in backend', {\n          id: entry.id,\n          error,\n        });\n      });\n\n      // Update bank stats\n      const bank = Array.from(this.banks.values()).find((b) => b.agentId === entry.agentId);\n      if (bank) {\n        bank.entryCount++;\n        bank.lastAccessed = new Date();\n      }\n\n      // Emit event\n      this.eventBus.emit('memory:created', { entry });\n    } catch (error) {\n      this.logger.error('Failed to store memory entry', error);\n      throw new MemoryError('Failed to store memory entry', { error });\n    }\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    // Check cache first\n    const cached = this.cache.get(id);\n    if (cached) {\n      return cached;\n    }\n\n    // Retrieve from backend\n    const entry = await this.backend.retrieve(id);\n    if (entry) {\n      // Add to cache\n      this.cache.set(id, entry);\n    }\n\n    return entry;\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    this.logger.debug('Querying memory', query);\n\n    try {\n      // Use index for fast querying\n      let results = this.indexer.search(query);\n\n      // Apply additional filters if needed\n      if (query.search) {\n        results = results.filter(\n          (entry) =>\n            entry.content.toLowerCase().includes(query.search!.toLowerCase()) ||\n            entry.tags.some((tag) => tag.toLowerCase().includes(query.search!.toLowerCase())),\n        );\n      }\n\n      // Apply time range filter\n      if (query.startTime || query.endTime) {\n        results = results.filter((entry) => {\n          const timestamp = entry.timestamp.getTime();\n          if (query.startTime && timestamp < query.startTime.getTime()) {\n            return false;\n          }\n          if (query.endTime && timestamp > query.endTime.getTime()) {\n            return false;\n          }\n          return true;\n        });\n      }\n\n      // Apply pagination\n      const start = query.offset || 0;\n      const limit = query.limit || 100;\n      results = results.slice(start, start + limit);\n\n      return results;\n    } catch (error) {\n      this.logger.error('Failed to query memory', error);\n      throw new MemoryError('Failed to query memory', { error });\n    }\n  }\n\n  async update(id: string, updates: Partial<MemoryEntry>): Promise<void> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    const existing = await this.retrieve(id);\n    if (!existing) {\n      throw new MemoryError(`Memory entry not found: ${id}`);\n    }\n\n    // Create updated entry\n    const updated: MemoryEntry = {\n      ...existing,\n      ...updates,\n      id: existing.id, // Ensure ID doesn't change\n      version: existing.version + 1,\n      timestamp: new Date(),\n    };\n\n    // Update in cache\n    this.cache.set(id, updated);\n\n    // Update in index\n    this.indexer.updateEntry(updated);\n\n    // Update in backend\n    await this.backend.update(id, updated);\n\n    // Emit event\n    this.eventBus.emit('memory:updated', {\n      entry: updated,\n      previousVersion: existing.version,\n    });\n  }\n\n  async delete(id: string): Promise<void> {\n    if (!this.initialized) {\n      throw new MemoryError('Memory manager not initialized');\n    }\n\n    // Remove from cache\n    this.cache.delete(id);\n\n    // Remove from index\n    this.indexer.removeEntry(id);\n\n    // Delete from backend\n    await this.backend.delete(id);\n\n    // Emit event\n    this.eventBus.emit('memory:deleted', { entryId: id });\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const backendHealth = await this.backend.getHealthStatus();\n      const cacheMetrics = this.cache.getMetrics();\n      const indexMetrics = this.indexer.getMetrics();\n\n      const metrics = {\n        totalEntries: indexMetrics.totalEntries,\n        cacheSize: cacheMetrics.size,\n        cacheHitRate: cacheMetrics.hitRate,\n        activeBanks: this.banks.size,\n        ...backendHealth.metrics,\n      };\n\n      return {\n        healthy: backendHealth.healthy,\n        metrics,\n        ...(backendHealth.error && { error: backendHealth.error }),\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  async performMaintenance(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.debug('Performing memory manager maintenance');\n\n    try {\n      // Clean up old entries based on retention policy\n      if (this.config.retentionDays > 0) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - this.config.retentionDays);\n\n        const oldEntries = await this.query({\n          endTime: cutoffDate,\n        });\n\n        for (const entry of oldEntries) {\n          await this.delete(entry.id);\n        }\n\n        this.logger.info(`Cleaned up ${oldEntries.length} old memory entries`);\n      }\n\n      // Perform cache maintenance\n      this.cache.performMaintenance();\n\n      // Perform backend maintenance\n      if (this.backend.performMaintenance) {\n        await this.backend.performMaintenance();\n      }\n\n      // Update bank statistics\n      for (const bank of this.banks.values()) {\n        const entries = await this.query({ agentId: bank.agentId });\n        bank.entryCount = entries.length;\n        bank.lastAccessed = new Date();\n      }\n\n      this.logger.debug('Memory manager maintenance completed');\n    } catch (error) {\n      this.logger.error('Error during memory manager maintenance', error);\n    }\n  }\n\n  private createBackend(): IMemoryBackend {\n    switch (this.config.backend) {\n      case 'sqlite':\n        return new SQLiteBackend(this.config.sqlitePath || './claude-flow.db', this.logger);\n      case 'markdown':\n        return new MarkdownBackend(this.config.markdownDir || './memory', this.logger);\n      case 'hybrid':\n        // Use SQLite for structured data and Markdown for human-readable backup\n        return new HybridBackend(\n          new SQLiteBackend(this.config.sqlitePath || './claude-flow.db', this.logger),\n          new MarkdownBackend(this.config.markdownDir || './memory', this.logger),\n          this.logger,\n        );\n      default:\n        throw new MemoryError(`Unknown memory backend: ${this.config.backend}`);\n    }\n  }\n\n  private startSyncInterval(): void {\n    this.syncInterval = setInterval(async () => {\n      try {\n        await this.syncCache();\n      } catch (error) {\n        this.logger.error('Cache sync error', error);\n      }\n    }, this.config.syncInterval);\n  }\n\n  private async syncCache(): Promise<void> {\n    const dirtyEntries = this.cache.getDirtyEntries();\n\n    if (dirtyEntries.length === 0) {\n      return;\n    }\n\n    this.logger.debug('Syncing cache to backend', { count: dirtyEntries.length });\n\n    const promises = dirtyEntries.map((entry) =>\n      this.backend.store(entry).catch((error) => {\n        this.logger.error('Failed to sync entry', { id: entry.id, error });\n      }),\n    );\n\n    await Promise.all(promises);\n    this.cache.markClean(dirtyEntries.map((e) => e.id));\n\n    // Emit sync event\n    this.eventBus.emit('memory:synced', { entries: dirtyEntries });\n  }\n\n  private async flushCache(): Promise<void> {\n    const allEntries = this.cache.getAllEntries();\n\n    if (allEntries.length === 0) {\n      return;\n    }\n\n    this.logger.info('Flushing cache to backend', { count: allEntries.length });\n\n    const promises = allEntries.map((entry) =>\n      this.backend.store(entry).catch((error) => {\n        this.logger.error('Failed to flush entry', { id: entry.id, error });\n      }),\n    );\n\n    await Promise.all(promises);\n  }\n}\n\n/**\n * Hybrid backend that uses both SQLite and Markdown\n */\nclass HybridBackend implements IMemoryBackend {\n  constructor(\n    private primary: IMemoryBackend,\n    private secondary: IMemoryBackend,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    await Promise.all([this.primary.initialize(), this.secondary.initialize()]);\n  }\n\n  async shutdown(): Promise<void> {\n    await Promise.all([this.primary.shutdown(), this.secondary.shutdown()]);\n  }\n\n  async store(entry: MemoryEntry): Promise<void> {\n    // Store in both backends\n    await Promise.all([\n      this.primary.store(entry),\n      this.secondary.store(entry).catch((error) => {\n        this.logger.warn('Failed to store in secondary backend', { error });\n      }),\n    ]);\n  }\n\n  async retrieve(id: string): Promise<MemoryEntry | undefined> {\n    // Try primary first\n    const entry = await this.primary.retrieve(id);\n    if (entry) {\n      return entry;\n    }\n\n    // Fall back to secondary\n    return await this.secondary.retrieve(id);\n  }\n\n  async update(id: string, entry: MemoryEntry): Promise<void> {\n    await Promise.all([\n      this.primary.update(id, entry),\n      this.secondary.update(id, entry).catch((error) => {\n        this.logger.warn('Failed to update in secondary backend', { error });\n      }),\n    ]);\n  }\n\n  async delete(id: string): Promise<void> {\n    await Promise.all([\n      this.primary.delete(id),\n      this.secondary.delete(id).catch((error) => {\n        this.logger.warn('Failed to delete from secondary backend', { error });\n      }),\n    ]);\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    // Use primary for querying (faster)\n    return await this.primary.query(query);\n  }\n\n  async getAllEntries(): Promise<MemoryEntry[]> {\n    return await this.primary.getAllEntries();\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const [primaryHealth, secondaryHealth] = await Promise.all([\n      this.primary.getHealthStatus(),\n      this.secondary.getHealthStatus(),\n    ]);\n\n    const error = primaryHealth.error || secondaryHealth.error;\n    return {\n      healthy: primaryHealth.healthy && secondaryHealth.healthy,\n      ...(error && { error }),\n      metrics: {\n        ...primaryHealth.metrics,\n        ...secondaryHealth.metrics,\n      },\n    };\n  }\n}\n"],"names":["MemoryError","SQLiteBackend","MarkdownBackend","MemoryCache","MemoryIndexer","MemoryManager","backend","cache","indexer","banks","Map","initialized","syncInterval","config","eventBus","logger","createBackend","cacheSizeMB","initialize","info","allEntries","getAllEntries","buildIndex","startSyncInterval","error","shutdown","clearInterval","flushCache","bankIds","Array","from","keys","Promise","all","map","id","closeBank","createBank","agentId","bank","Date","now","Math","random","toString","substr","createdAt","lastAccessed","entryCount","set","bankId","get","bankEntries","getByPrefix","entry","store","delete","debug","type","addEntry","catch","values","find","b","emit","retrieve","cached","query","results","search","filter","content","toLowerCase","includes","tags","some","tag","startTime","endTime","timestamp","getTime","start","offset","limit","slice","update","updates","existing","updated","version","updateEntry","previousVersion","removeEntry","entryId","getHealthStatus","backendHealth","cacheMetrics","getMetrics","indexMetrics","metrics","totalEntries","cacheSize","size","cacheHitRate","hitRate","activeBanks","healthy","Error","message","performMaintenance","retentionDays","cutoffDate","setDate","getDate","oldEntries","length","entries","sqlitePath","markdownDir","HybridBackend","setInterval","syncCache","dirtyEntries","getDirtyEntries","count","promises","markClean","e","primary","secondary","warn","primaryHealth","secondaryHealth"],"mappings":"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"}