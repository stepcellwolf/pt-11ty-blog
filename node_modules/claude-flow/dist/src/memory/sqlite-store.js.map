{"version":3,"sources":["../../../src/memory/sqlite-store.js"],"sourcesContent":["/**\n * SQLite-based memory store for MCP server\n * Provides persistent storage that works with both local and remote npx execution\n */\n\nimport path from 'path';\nimport { promises as fs } from 'fs';\nimport { fileURLToPath } from 'url';\nimport os from 'os';\nimport { createDatabase } from './sqlite-wrapper.js';\nimport { getSwarmDir } from '../utils/project-root.js';\nimport { sessionSerializer } from './enhanced-session-serializer.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nclass SqliteMemoryStore {\n  constructor(options = {}) {\n    this.options = {\n      dbName: options.dbName || 'memory.db',\n      directory: options.directory || this._getMemoryDirectory(),\n      ...options,\n    };\n\n    this.db = null;\n    this.statements = new Map();\n    this.isInitialized = false;\n  }\n\n  /**\n   * Determine the best directory for memory storage\n   * Uses .swarm directory in project root (consistent with hive-mind approach)\n   */\n  _getMemoryDirectory() {\n    // Always use .swarm directory in the project root\n    // This ensures consistency whether running locally or via npx\n    return getSwarmDir();\n  }\n\n  _directoryExists(dir) {\n    try {\n      const stats = require('fs').statSync(dir);\n      return stats.isDirectory();\n    } catch {\n      return false;\n    }\n  }\n\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      // Ensure directory exists\n      await fs.mkdir(this.options.directory, { recursive: true });\n\n      // Open database\n      const dbPath = path.join(this.options.directory, this.options.dbName);\n      this.db = await createDatabase(dbPath);\n\n      // Enable WAL mode for better concurrency\n      this.db.pragma('journal_mode = WAL');\n      this.db.pragma('synchronous = NORMAL');\n\n      // Create tables\n      this._createTables();\n\n      // Prepare statements\n      this._prepareStatements();\n\n      this.isInitialized = true;\n\n      console.error(\n        `[${new Date().toISOString()}] INFO [memory-store] Initialized SQLite at: ${dbPath}`,\n      );\n    } catch (error) {\n      console.error(\n        `[${new Date().toISOString()}] ERROR [memory-store] Failed to initialize:`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  _createTables() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS memory_entries (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        key TEXT NOT NULL,\n        value TEXT NOT NULL,\n        namespace TEXT NOT NULL DEFAULT 'default',\n        metadata TEXT,\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\n        updated_at INTEGER DEFAULT (strftime('%s', 'now')),\n        accessed_at INTEGER DEFAULT (strftime('%s', 'now')),\n        access_count INTEGER DEFAULT 0,\n        ttl INTEGER,\n        expires_at INTEGER,\n        UNIQUE(key, namespace)\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_memory_namespace ON memory_entries(namespace);\n      CREATE INDEX IF NOT EXISTS idx_memory_expires ON memory_entries(expires_at) WHERE expires_at IS NOT NULL;\n      CREATE INDEX IF NOT EXISTS idx_memory_accessed ON memory_entries(accessed_at);\n    `);\n  }\n\n  _prepareStatements() {\n    // Store/update statement\n    this.statements.set(\n      'upsert',\n      this.db.prepare(`\n      INSERT INTO memory_entries (key, value, namespace, metadata, ttl, expires_at)\n      VALUES (?, ?, ?, ?, ?, ?)\n      ON CONFLICT(key, namespace) DO UPDATE SET\n        value = excluded.value,\n        metadata = excluded.metadata,\n        ttl = excluded.ttl,\n        expires_at = excluded.expires_at,\n        updated_at = strftime('%s', 'now'),\n        access_count = memory_entries.access_count + 1\n    `),\n    );\n\n    // Retrieve statement\n    this.statements.set(\n      'get',\n      this.db.prepare(`\n      SELECT * FROM memory_entries \n      WHERE key = ? AND namespace = ? AND (expires_at IS NULL OR expires_at > strftime('%s', 'now'))\n    `),\n    );\n\n    // List statement\n    this.statements.set(\n      'list',\n      this.db.prepare(`\n      SELECT * FROM memory_entries \n      WHERE namespace = ? AND (expires_at IS NULL OR expires_at > strftime('%s', 'now'))\n      ORDER BY updated_at DESC\n      LIMIT ?\n    `),\n    );\n\n    // Delete statement\n    this.statements.set(\n      'delete',\n      this.db.prepare(`\n      DELETE FROM memory_entries WHERE key = ? AND namespace = ?\n    `),\n    );\n\n    // Search statement\n    this.statements.set(\n      'search',\n      this.db.prepare(`\n      SELECT * FROM memory_entries \n      WHERE namespace = ? AND (key LIKE ? OR value LIKE ?) \n      AND (expires_at IS NULL OR expires_at > strftime('%s', 'now'))\n      ORDER BY access_count DESC, updated_at DESC\n      LIMIT ?\n    `),\n    );\n\n    // Cleanup statement\n    this.statements.set(\n      'cleanup',\n      this.db.prepare(`\n      DELETE FROM memory_entries WHERE expires_at IS NOT NULL AND expires_at <= strftime('%s', 'now')\n    `),\n    );\n\n    // Update access statement\n    this.statements.set(\n      'updateAccess',\n      this.db.prepare(`\n      UPDATE memory_entries \n      SET accessed_at = strftime('%s', 'now'), access_count = access_count + 1\n      WHERE key = ? AND namespace = ?\n    `),\n    );\n  }\n\n  async store(key, value, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const metadata = options.metadata ? JSON.stringify(options.metadata) : null;\n    const ttl = options.ttl || null;\n    const expiresAt = ttl ? Math.floor(Date.now() / 1000) + ttl : null;\n    const valueStr = typeof value === 'string' ? value : sessionSerializer.serializer.serialize(value);\n\n    try {\n      const result = this.statements\n        .get('upsert')\n        .run(key, valueStr, namespace, metadata, ttl, expiresAt);\n\n      return {\n        success: true,\n        id: result.lastInsertRowid,\n        size: valueStr.length,\n      };\n    } catch (error) {\n      console.error(`[${new Date().toISOString()}] ERROR [memory-store] Store failed:`, error);\n      throw error;\n    }\n  }\n\n  async retrieve(key, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n\n    try {\n      const row = this.statements.get('get').get(key, namespace);\n\n      if (!row) {\n        return null;\n      }\n\n      // Update access stats\n      this.statements.get('updateAccess').run(key, namespace);\n\n      // Try to deserialize, fall back to raw string\n      try {\n        return sessionSerializer.serializer.deserialize(row.value);\n      } catch {\n        return row.value;\n      }\n    } catch (error) {\n      console.error(`[${new Date().toISOString()}] ERROR [memory-store] Retrieve failed:`, error);\n      throw error;\n    }\n  }\n\n  async list(options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const limit = options.limit || 100;\n\n    try {\n      const rows = this.statements.get('list').all(namespace, limit);\n\n      return rows.map((row) => ({\n        key: row.key,\n        value: this._tryParseJson(row.value),\n        namespace: row.namespace,\n        metadata: row.metadata ? JSON.parse(row.metadata) : null,\n        createdAt: new Date(row.created_at * 1000),\n        updatedAt: new Date(row.updated_at * 1000),\n        accessCount: row.access_count,\n      }));\n    } catch (error) {\n      console.error(`[${new Date().toISOString()}] ERROR [memory-store] List failed:`, error);\n      throw error;\n    }\n  }\n\n  async delete(key, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n\n    try {\n      const result = this.statements.get('delete').run(key, namespace);\n      return result.changes > 0;\n    } catch (error) {\n      console.error(`[${new Date().toISOString()}] ERROR [memory-store] Delete failed:`, error);\n      throw error;\n    }\n  }\n\n  async search(pattern, options = {}) {\n    await this.initialize();\n\n    const namespace = options.namespace || 'default';\n    const limit = options.limit || 50;\n    const searchPattern = `%${pattern}%`;\n\n    try {\n      const rows = this.statements\n        .get('search')\n        .all(namespace, searchPattern, searchPattern, limit);\n\n      return rows.map((row) => ({\n        key: row.key,\n        value: this._tryParseJson(row.value),\n        namespace: row.namespace,\n        score: row.access_count,\n        updatedAt: new Date(row.updated_at * 1000),\n      }));\n    } catch (error) {\n      console.error(`[${new Date().toISOString()}] ERROR [memory-store] Search failed:`, error);\n      throw error;\n    }\n  }\n\n  async cleanup() {\n    await this.initialize();\n\n    try {\n      const result = this.statements.get('cleanup').run();\n      return result.changes;\n    } catch (error) {\n      console.error(`[${new Date().toISOString()}] ERROR [memory-store] Cleanup failed:`, error);\n      throw error;\n    }\n  }\n\n  _tryParseJson(value) {\n    try {\n      return sessionSerializer.serializer.deserialize(value);\n    } catch {\n      return value;\n    }\n  }\n\n  close() {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n      this.isInitialized = false;\n    }\n  }\n}\n\n// Export a singleton instance for MCP server\nexport const memoryStore = new SqliteMemoryStore();\n\nexport { SqliteMemoryStore };\nexport default SqliteMemoryStore;\n"],"names":["path","promises","fs","fileURLToPath","createDatabase","getSwarmDir","sessionSerializer","__filename","url","__dirname","dirname","SqliteMemoryStore","options","dbName","directory","_getMemoryDirectory","db","statements","Map","isInitialized","_directoryExists","dir","stats","require","statSync","isDirectory","initialize","mkdir","recursive","dbPath","join","pragma","_createTables","_prepareStatements","console","error","Date","toISOString","exec","set","prepare","store","key","value","namespace","metadata","JSON","stringify","ttl","expiresAt","Math","floor","now","valueStr","serializer","serialize","result","get","run","success","id","lastInsertRowid","size","length","retrieve","row","deserialize","list","limit","rows","all","map","_tryParseJson","parse","createdAt","created_at","updatedAt","updated_at","accessCount","access_count","delete","changes","search","pattern","searchPattern","score","cleanup","close","memoryStore"],"mappings":"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"}