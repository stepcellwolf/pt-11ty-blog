{"version":3,"sources":["../../../src/memory/swarm-memory.js"],"sourcesContent":["/**\n * SwarmMemory - MCP-specific memory persistence extending SharedMemory\n * Provides swarm-specific features like agent coordination, task tracking, and neural patterns\n *\n * @module swarm-memory\n */\n\nimport { SharedMemory } from './shared-memory.js';\nimport path from 'path';\n\n/**\n * Swarm-specific namespaces\n */\nconst SWARM_NAMESPACES = {\n  AGENTS: 'swarm:agents',\n  TASKS: 'swarm:tasks',\n  COMMUNICATIONS: 'swarm:communications',\n  CONSENSUS: 'swarm:consensus',\n  PATTERNS: 'swarm:patterns',\n  METRICS: 'swarm:metrics',\n  COORDINATION: 'swarm:coordination',\n};\n\n/**\n * SwarmMemory class - Extends SharedMemory with MCP features\n */\nexport class SwarmMemory extends SharedMemory {\n  constructor(options = {}) {\n    // Default to .swarm directory for MCP\n    super({\n      directory: options.directory || '.swarm',\n      filename: options.filename || 'swarm-memory.db',\n      ...options,\n    });\n\n    this.swarmId = options.swarmId || 'default';\n    this.mcpMode = options.mcpMode !== false;\n\n    // Additional swarm-specific caches\n    this.agentCache = new Map();\n    this.taskCache = new Map();\n    this.patternCache = new Map();\n  }\n\n  /**\n   * Initialize with swarm-specific setup\n   */\n  async initialize() {\n    await super.initialize();\n\n    // Initialize swarm-specific namespaces\n    await this._initializeSwarmNamespaces();\n\n    // Load active agents and tasks into cache\n    await this._loadSwarmState();\n\n    this.emit('swarm:initialized', { swarmId: this.swarmId });\n  }\n\n  /**\n   * Store agent information\n   */\n  async storeAgent(agentId, agentData) {\n    const key = `agent:${agentId}`;\n    const enrichedData = {\n      ...agentData,\n      swarmId: this.swarmId,\n      lastUpdated: new Date().toISOString(),\n    };\n\n    await this.store(key, enrichedData, {\n      namespace: SWARM_NAMESPACES.AGENTS,\n      tags: ['agent', agentData.type, agentData.status],\n      metadata: {\n        swarmId: this.swarmId,\n        agentType: agentData.type,\n      },\n    });\n\n    // Update agent cache\n    this.agentCache.set(agentId, enrichedData);\n\n    this.emit('swarm:agentStored', { agentId, type: agentData.type });\n\n    return { agentId, stored: true };\n  }\n\n  /**\n   * Retrieve agent information\n   */\n  async getAgent(agentId) {\n    // Check cache first\n    if (this.agentCache.has(agentId)) {\n      return this.agentCache.get(agentId);\n    }\n\n    const key = `agent:${agentId}`;\n    const agent = await this.retrieve(key, SWARM_NAMESPACES.AGENTS);\n\n    if (agent) {\n      this.agentCache.set(agentId, agent);\n    }\n\n    return agent;\n  }\n\n  /**\n   * List all agents in swarm\n   */\n  async listAgents(filter = {}) {\n    const agents = await this.list(SWARM_NAMESPACES.AGENTS, {\n      limit: filter.limit || 100,\n    });\n\n    return agents\n      .map((entry) => entry.value)\n      .filter((agent) => {\n        if (filter.type && agent.type !== filter.type) return false;\n        if (filter.status && agent.status !== filter.status) return false;\n        if (filter.swarmId && agent.swarmId !== filter.swarmId) return false;\n        return true;\n      });\n  }\n\n  /**\n   * Store task information\n   */\n  async storeTask(taskId, taskData) {\n    const key = `task:${taskId}`;\n    const enrichedData = {\n      ...taskData,\n      swarmId: this.swarmId,\n      createdAt: taskData.createdAt || new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n\n    await this.store(key, enrichedData, {\n      namespace: SWARM_NAMESPACES.TASKS,\n      tags: ['task', taskData.status, taskData.priority],\n      metadata: {\n        swarmId: this.swarmId,\n        assignedAgents: taskData.assignedAgents || [],\n      },\n    });\n\n    // Update task cache\n    this.taskCache.set(taskId, enrichedData);\n\n    this.emit('swarm:taskStored', { taskId, status: taskData.status });\n\n    return { taskId, stored: true };\n  }\n\n  /**\n   * Update task status\n   */\n  async updateTaskStatus(taskId, status, result = null) {\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task ${taskId} not found`);\n    }\n\n    task.status = status;\n    task.updatedAt = new Date().toISOString();\n\n    if (result) {\n      task.result = result;\n    }\n\n    if (status === 'completed') {\n      task.completedAt = new Date().toISOString();\n    }\n\n    await this.storeTask(taskId, task);\n\n    this.emit('swarm:taskStatusUpdated', { taskId, status });\n\n    return { taskId, status, updated: true };\n  }\n\n  /**\n   * Get task information\n   */\n  async getTask(taskId) {\n    // Check cache first\n    if (this.taskCache.has(taskId)) {\n      return this.taskCache.get(taskId);\n    }\n\n    const key = `task:${taskId}`;\n    const task = await this.retrieve(key, SWARM_NAMESPACES.TASKS);\n\n    if (task) {\n      this.taskCache.set(taskId, task);\n    }\n\n    return task;\n  }\n\n  /**\n   * Store inter-agent communication\n   */\n  async storeCommunication(fromAgent, toAgent, message) {\n    const commId = `comm:${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const communication = {\n      id: commId,\n      fromAgent,\n      toAgent,\n      message,\n      swarmId: this.swarmId,\n      timestamp: new Date().toISOString(),\n    };\n\n    await this.store(commId, communication, {\n      namespace: SWARM_NAMESPACES.COMMUNICATIONS,\n      ttl: 86400, // 24 hours\n      tags: ['communication', message.type],\n      metadata: {\n        fromAgent,\n        toAgent,\n        messageType: message.type,\n      },\n    });\n\n    this.emit('swarm:communication', { fromAgent, toAgent, type: message.type });\n\n    return { id: commId, stored: true };\n  }\n\n  /**\n   * Store consensus decision\n   */\n  async storeConsensus(consensusId, decision) {\n    const key = `consensus:${consensusId}`;\n    const consensusData = {\n      ...decision,\n      swarmId: this.swarmId,\n      timestamp: new Date().toISOString(),\n    };\n\n    await this.store(key, consensusData, {\n      namespace: SWARM_NAMESPACES.CONSENSUS,\n      tags: ['consensus', decision.status],\n      metadata: {\n        swarmId: this.swarmId,\n        taskId: decision.taskId,\n        threshold: decision.threshold,\n      },\n    });\n\n    this.emit('swarm:consensus', { consensusId, status: decision.status });\n\n    return { consensusId, stored: true };\n  }\n\n  /**\n   * Store neural pattern\n   */\n  async storePattern(patternId, pattern) {\n    const key = `pattern:${patternId}`;\n    const patternData = {\n      ...pattern,\n      swarmId: this.swarmId,\n      createdAt: new Date().toISOString(),\n      usageCount: 0,\n      successRate: 0,\n    };\n\n    await this.store(key, patternData, {\n      namespace: SWARM_NAMESPACES.PATTERNS,\n      tags: ['pattern', pattern.type],\n      metadata: {\n        swarmId: this.swarmId,\n        patternType: pattern.type,\n        confidence: pattern.confidence || 0,\n      },\n    });\n\n    // Cache frequently used patterns\n    if (pattern.type === 'coordination' || pattern.type === 'optimization') {\n      this.patternCache.set(patternId, patternData);\n    }\n\n    this.emit('swarm:patternStored', { patternId, type: pattern.type });\n\n    return { patternId, stored: true };\n  }\n\n  /**\n   * Update pattern usage and success metrics\n   */\n  async updatePatternMetrics(patternId, success = true) {\n    const pattern = await this.getPattern(patternId);\n    if (!pattern) {\n      throw new Error(`Pattern ${patternId} not found`);\n    }\n\n    pattern.usageCount++;\n    pattern.lastUsedAt = new Date().toISOString();\n\n    // Update success rate with exponential moving average\n    const alpha = 0.1; // Smoothing factor\n    const currentSuccess = success ? 1 : 0;\n    pattern.successRate = alpha * currentSuccess + (1 - alpha) * (pattern.successRate || 0);\n\n    await this.storePattern(patternId, pattern);\n\n    return { patternId, usageCount: pattern.usageCount, successRate: pattern.successRate };\n  }\n\n  /**\n   * Get pattern\n   */\n  async getPattern(patternId) {\n    // Check cache first\n    if (this.patternCache.has(patternId)) {\n      return this.patternCache.get(patternId);\n    }\n\n    const key = `pattern:${patternId}`;\n    return await this.retrieve(key, SWARM_NAMESPACES.PATTERNS);\n  }\n\n  /**\n   * Find best patterns for a given context\n   */\n  async findBestPatterns(context, limit = 5) {\n    const patterns = await this.search({\n      namespace: SWARM_NAMESPACES.PATTERNS,\n      tags: context.tags,\n      limit: 100,\n    });\n\n    // Score patterns based on success rate and relevance\n    const scored = patterns.map((entry) => {\n      const pattern = entry.value;\n      const score =\n        pattern.successRate * 0.7 +\n        (pattern.confidence || 0) * 0.2 +\n        (pattern.usageCount > 0 ? 0.1 : 0);\n\n      return { ...pattern, score };\n    });\n\n    // Sort by score and return top patterns\n    return scored.sort((a, b) => b.score - a.score).slice(0, limit);\n  }\n\n  /**\n   * Store coordination state\n   */\n  async storeCoordination(key, state) {\n    await this.store(key, state, {\n      namespace: SWARM_NAMESPACES.COORDINATION,\n      ttl: 3600, // 1 hour\n      metadata: {\n        swarmId: this.swarmId,\n        timestamp: new Date().toISOString(),\n      },\n    });\n\n    return { key, stored: true };\n  }\n\n  /**\n   * Get coordination state\n   */\n  async getCoordination(key) {\n    return await this.retrieve(key, SWARM_NAMESPACES.COORDINATION);\n  }\n\n  /**\n   * Store performance metrics\n   */\n  async storeMetrics(metricsId, metrics) {\n    const key = `metrics:${metricsId}`;\n    await this.store(key, metrics, {\n      namespace: SWARM_NAMESPACES.METRICS,\n      ttl: 86400 * 7, // 7 days\n      tags: ['metrics', metrics.type],\n      metadata: {\n        swarmId: this.swarmId,\n        agentId: metrics.agentId,\n        timestamp: new Date().toISOString(),\n      },\n    });\n\n    this.emit('swarm:metricsStored', { metricsId, type: metrics.type });\n\n    return { metricsId, stored: true };\n  }\n\n  /**\n   * Get swarm statistics\n   */\n  async getSwarmStats() {\n    const baseStats = await this.getStats();\n\n    // Add swarm-specific stats\n    const agentCount = await this._countNamespace(SWARM_NAMESPACES.AGENTS);\n    const taskCount = await this._countNamespace(SWARM_NAMESPACES.TASKS);\n    const patternCount = await this._countNamespace(SWARM_NAMESPACES.PATTERNS);\n\n    // Get active agents\n    const activeAgents = Array.from(this.agentCache.values()).filter(\n      (agent) => agent.status === 'active' || agent.status === 'busy',\n    ).length;\n\n    // Get task statistics\n    const tasks = Array.from(this.taskCache.values());\n    const taskStats = {\n      total: tasks.length,\n      pending: tasks.filter((t) => t.status === 'pending').length,\n      inProgress: tasks.filter((t) => t.status === 'in_progress').length,\n      completed: tasks.filter((t) => t.status === 'completed').length,\n      failed: tasks.filter((t) => t.status === 'failed').length,\n    };\n\n    return {\n      ...baseStats,\n      swarm: {\n        swarmId: this.swarmId,\n        agents: {\n          total: agentCount,\n          active: activeAgents,\n          cached: this.agentCache.size,\n        },\n        tasks: taskStats,\n        patterns: {\n          total: patternCount,\n          cached: this.patternCache.size,\n        },\n        namespaces: Object.values(SWARM_NAMESPACES),\n      },\n    };\n  }\n\n  /**\n   * Clean up old swarm data\n   */\n  async cleanupSwarmData(options = {}) {\n    const {\n      maxAge = 86400 * 7, // 7 days\n      keepPatterns = true,\n      keepConsensus = true,\n    } = options;\n\n    const cutoffTime = Date.now() - maxAge * 1000;\n    let cleaned = 0;\n\n    // Clean old communications\n    const comms = await this.list(SWARM_NAMESPACES.COMMUNICATIONS);\n    for (const comm of comms) {\n      if (new Date(comm.value.timestamp).getTime() < cutoffTime) {\n        await this.delete(comm.key, SWARM_NAMESPACES.COMMUNICATIONS);\n        cleaned++;\n      }\n    }\n\n    // Clean completed tasks\n    const tasks = await this.list(SWARM_NAMESPACES.TASKS);\n    for (const task of tasks) {\n      if (\n        task.value.status === 'completed' &&\n        new Date(task.value.completedAt).getTime() < cutoffTime\n      ) {\n        await this.delete(task.key, SWARM_NAMESPACES.TASKS);\n        this.taskCache.delete(task.value.id);\n        cleaned++;\n      }\n    }\n\n    // Clean old metrics\n    const metrics = await this.list(SWARM_NAMESPACES.METRICS);\n    for (const metric of metrics) {\n      if (new Date(metric.createdAt).getTime() < cutoffTime) {\n        await this.delete(metric.key, SWARM_NAMESPACES.METRICS);\n        cleaned++;\n      }\n    }\n\n    this.emit('swarm:cleanup', { cleaned, maxAge });\n\n    return { cleaned };\n  }\n\n  /**\n   * Export swarm state\n   */\n  async exportSwarmState() {\n    const agents = await this.listAgents();\n    const tasks = Array.from(this.taskCache.values());\n    const patterns = await this.list(SWARM_NAMESPACES.PATTERNS);\n\n    return {\n      swarmId: this.swarmId,\n      exportedAt: new Date().toISOString(),\n      agents: agents,\n      tasks: tasks,\n      patterns: patterns.map((p) => p.value),\n      statistics: await this.getSwarmStats(),\n    };\n  }\n\n  /**\n   * Import swarm state\n   */\n  async importSwarmState(state) {\n    let imported = {\n      agents: 0,\n      tasks: 0,\n      patterns: 0,\n    };\n\n    // Import agents\n    if (state.agents) {\n      for (const agent of state.agents) {\n        await this.storeAgent(agent.id, agent);\n        imported.agents++;\n      }\n    }\n\n    // Import tasks\n    if (state.tasks) {\n      for (const task of state.tasks) {\n        await this.storeTask(task.id, task);\n        imported.tasks++;\n      }\n    }\n\n    // Import patterns\n    if (state.patterns) {\n      for (const pattern of state.patterns) {\n        await this.storePattern(pattern.id, pattern);\n        imported.patterns++;\n      }\n    }\n\n    this.emit('swarm:imported', imported);\n\n    return imported;\n  }\n\n  /**\n   * Private helper methods\n   */\n\n  async _initializeSwarmNamespaces() {\n    // Create swarm metadata\n    await this.store(\n      'swarm:metadata',\n      {\n        swarmId: this.swarmId,\n        createdAt: new Date().toISOString(),\n        version: '1.0.0',\n        namespaces: Object.values(SWARM_NAMESPACES),\n      },\n      {\n        namespace: 'swarm:system',\n      },\n    );\n  }\n\n  async _loadSwarmState() {\n    // Load active agents\n    const agents = await this.list(SWARM_NAMESPACES.AGENTS, { limit: 100 });\n    for (const entry of agents) {\n      if (entry.value.status === 'active' || entry.value.status === 'busy') {\n        this.agentCache.set(entry.value.id, entry.value);\n      }\n    }\n\n    // Load in-progress tasks\n    const tasks = await this.search({\n      namespace: SWARM_NAMESPACES.TASKS,\n      tags: ['in_progress'],\n      limit: 100,\n    });\n    for (const entry of tasks) {\n      this.taskCache.set(entry.value.id, entry.value);\n    }\n\n    // Load high-confidence patterns\n    const patterns = await this.list(SWARM_NAMESPACES.PATTERNS, { limit: 50 });\n    for (const entry of patterns) {\n      if (entry.value.confidence > 0.7 || entry.value.successRate > 0.8) {\n        this.patternCache.set(entry.value.id, entry.value);\n      }\n    }\n  }\n\n  async _countNamespace(namespace) {\n    const stats = await this.getStats();\n    return stats.namespaces[namespace]?.count || 0;\n  }\n}\n\n// Export factory function for easy creation\nexport function createSwarmMemory(options = {}) {\n  return new SwarmMemory(options);\n}\n\n// Export for backwards compatibility\nexport default SwarmMemory;\n"],"names":["SharedMemory","SWARM_NAMESPACES","AGENTS","TASKS","COMMUNICATIONS","CONSENSUS","PATTERNS","METRICS","COORDINATION","SwarmMemory","options","directory","filename","swarmId","mcpMode","agentCache","Map","taskCache","patternCache","initialize","_initializeSwarmNamespaces","_loadSwarmState","emit","storeAgent","agentId","agentData","key","enrichedData","lastUpdated","Date","toISOString","store","namespace","tags","type","status","metadata","agentType","set","stored","getAgent","has","get","agent","retrieve","listAgents","filter","agents","list","limit","map","entry","value","storeTask","taskId","taskData","createdAt","updatedAt","priority","assignedAgents","updateTaskStatus","result","task","getTask","Error","completedAt","updated","storeCommunication","fromAgent","toAgent","message","commId","now","Math","random","toString","substr","communication","id","timestamp","ttl","messageType","storeConsensus","consensusId","decision","consensusData","threshold","storePattern","patternId","pattern","patternData","usageCount","successRate","patternType","confidence","updatePatternMetrics","success","getPattern","lastUsedAt","alpha","currentSuccess","findBestPatterns","context","patterns","search","scored","score","sort","a","b","slice","storeCoordination","state","getCoordination","storeMetrics","metricsId","metrics","getSwarmStats","baseStats","getStats","agentCount","_countNamespace","taskCount","patternCount","activeAgents","Array","from","values","length","tasks","taskStats","total","pending","t","inProgress","completed","failed","swarm","active","cached","size","namespaces","Object","cleanupSwarmData","maxAge","keepPatterns","keepConsensus","cutoffTime","cleaned","comms","comm","getTime","delete","metric","exportSwarmState","exportedAt","p","statistics","importSwarmState","imported","version","stats","count","createSwarmMemory"],"mappings":"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"}