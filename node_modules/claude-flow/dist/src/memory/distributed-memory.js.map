{"version":3,"sources":["../../../src/memory/distributed-memory.ts"],"sourcesContent":["/**\n * Distributed memory system with sharing capabilities\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  SwarmMemory,\n  MemoryPartition,\n  MemoryEntry,\n  MemoryType,\n  AccessLevel,\n  ConsistencyLevel,\n  MemoryPermissions,\n  AgentId,\n} from '../swarm/types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface DistributedMemoryConfig {\n  namespace: string;\n  distributed: boolean;\n  consistency: ConsistencyLevel;\n  replicationFactor: number;\n  syncInterval: number;\n  maxMemorySize: number;\n  compressionEnabled: boolean;\n  encryptionEnabled: boolean;\n  backupEnabled: boolean;\n  persistenceEnabled: boolean;\n  shardingEnabled: boolean;\n  cacheSize: number;\n  cacheTtl: number;\n  backend?: string;\n  timeout?: number;\n  retryAttempts?: number;\n}\n\nexport interface MemoryNode {\n  id: string;\n  address: string;\n  port: number;\n  status: 'online' | 'offline' | 'syncing' | 'failed';\n  lastSeen: Date;\n  partitions: string[];\n  load: number;\n  capacity: number;\n}\n\nexport interface SyncOperation {\n  id: string;\n  type: 'create' | 'update' | 'delete' | 'batch';\n  partition: string;\n  entry?: MemoryEntry;\n  entries?: MemoryEntry[];\n  timestamp: Date;\n  version: number;\n  origin: string;\n  targets: string[];\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n}\n\nexport interface MemoryQuery {\n  namespace?: string;\n  partition?: string;\n  type?: MemoryType;\n  tags?: string[];\n  owner?: AgentId;\n  accessLevel?: AccessLevel;\n  createdAfter?: Date;\n  updatedAfter?: Date;\n  limit?: number;\n  offset?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface MemoryStatistics {\n  totalEntries: number;\n  totalSize: number;\n  partitionCount: number;\n  nodeCount: number;\n  replicationHealth: number;\n  syncOperations: {\n    pending: number;\n    completed: number;\n    failed: number;\n  };\n  performance: {\n    readLatency: number;\n    writeLatency: number;\n    syncLatency: number;\n    throughput: number;\n  };\n  utilization: {\n    memoryUsage: number;\n    diskUsage: number;\n    networkUsage: number;\n  };\n}\n\n/**\n * Distributed memory system for sharing data across swarm agents\n */\nexport class DistributedMemorySystem extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: DistributedMemoryConfig;\n\n  // Storage\n  private partitions = new Map<string, MemoryPartition>();\n  private entries = new Map<string, MemoryEntry>();\n  private cache = new Map<string, { entry: MemoryEntry; expiry: number }>();\n\n  // Distribution\n  private nodes = new Map<string, MemoryNode>();\n  private localNodeId: string;\n  private syncQueue: SyncOperation[] = [];\n  private replicationMap = new Map<string, string[]>(); // entryId -> nodeIds\n\n  // Synchronization\n  private syncInterval?: NodeJS.Timeout;\n  private vectorClock = new Map<string, number>();\n  private conflictResolver?: (local: MemoryEntry, remote: MemoryEntry) => MemoryEntry;\n\n  // Performance tracking\n  private statistics: MemoryStatistics;\n  private operationMetrics = new Map<string, { count: number; totalTime: number }>();\n\n  constructor(config: Partial<DistributedMemoryConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      namespace: 'default',\n      distributed: true,\n      consistency: 'eventual',\n      replicationFactor: 3,\n      syncInterval: 5000,\n      maxMemorySize: 1024 * 1024 * 1024, // 1GB\n      compressionEnabled: true,\n      encryptionEnabled: false,\n      backupEnabled: true,\n      persistenceEnabled: true,\n      shardingEnabled: true,\n      cacheSize: 10000,\n      cacheTtl: 300000, // 5 minutes\n      ...config,\n    };\n\n    this.localNodeId = generateId('memory-node');\n    this.statistics = this.initializeStatistics();\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('memory:sync-request', (data) => {\n      this.handleSyncRequest(data);\n    });\n\n    this.eventBus.on('memory:node-joined', (data) => {\n      this.handleNodeJoined(data);\n    });\n\n    this.eventBus.on('memory:node-left', (data) => {\n      this.handleNodeLeft(data);\n    });\n\n    this.eventBus.on('memory:conflict-detected', (data) => {\n      this.handleConflict(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing distributed memory system', {\n      nodeId: this.localNodeId,\n      namespace: this.config.namespace,\n      distributed: this.config.distributed,\n    });\n\n    // Register local node\n    const localNode: MemoryNode = {\n      id: this.localNodeId,\n      address: 'localhost',\n      port: 8080,\n      status: 'online',\n      lastSeen: new Date(),\n      partitions: [],\n      load: 0,\n      capacity: this.config.maxMemorySize,\n    };\n\n    this.nodes.set(this.localNodeId, localNode);\n\n    // Initialize default partitions\n    await this.createPartition('knowledge', 'knowledge');\n    await this.createPartition('state', 'state');\n    await this.createPartition('cache', 'cache');\n    await this.createPartition('results', 'results');\n\n    // Start synchronization if distributed\n    if (this.config.distributed) {\n      this.startSynchronization();\n    }\n\n    // Load persisted data if enabled\n    if (this.config.persistenceEnabled) {\n      await this.loadPersistedData();\n    }\n\n    this.emit('memory:initialized', { nodeId: this.localNodeId });\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down distributed memory system');\n\n    // Stop synchronization\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n    }\n\n    // Complete pending sync operations\n    await this.completePendingSyncOperations();\n\n    // Persist data if enabled\n    if (this.config.persistenceEnabled) {\n      await this.persistData();\n    }\n\n    // Clear caches\n    this.cache.clear();\n    this.partitions.clear();\n    this.entries.clear();\n\n    this.emit('memory:shutdown', { nodeId: this.localNodeId });\n  }\n\n  // === PARTITION MANAGEMENT ===\n\n  async createPartition(\n    name: string,\n    type: MemoryType,\n    options: {\n      maxSize?: number;\n      ttl?: number;\n      readOnly?: boolean;\n      shared?: boolean;\n      indexed?: boolean;\n      compressed?: boolean;\n    } = {},\n  ): Promise<string> {\n    const partitionId = generateId('partition');\n\n    const partition: MemoryPartition = {\n      id: partitionId,\n      name,\n      type,\n      entries: [],\n      maxSize: options.maxSize || this.config.maxMemorySize / 10,\n      ttl: options.ttl,\n      readOnly: options.readOnly || false,\n      shared: options.shared !== false, // Default to shared\n      indexed: options.indexed || false,\n      compressed: options.compressed || this.config.compressionEnabled,\n    };\n\n    this.partitions.set(partitionId, partition);\n\n    // Update local node partition list\n    const localNode = this.nodes.get(this.localNodeId)!;\n    localNode.partitions.push(partitionId);\n\n    this.logger.info('Created partition', { partitionId, name, type });\n    this.emit('memory:partition-created', { partition });\n\n    // Sync with other nodes if distributed\n    if (this.config.distributed) {\n      await this.syncPartitionCreation(partition);\n    }\n\n    return partitionId;\n  }\n\n  async deletePartition(partitionId: string): Promise<void> {\n    const partition = this.partitions.get(partitionId);\n    if (!partition) {\n      throw new Error(`Partition ${partitionId} not found`);\n    }\n\n    // Delete all entries in partition\n    const entriesToDelete = Array.from(this.entries.values()).filter(\n      (entry) => this.getEntryPartition(entry.id) === partitionId,\n    );\n\n    for (const entry of entriesToDelete) {\n      await this.deleteEntry(entry.id);\n    }\n\n    // Remove partition\n    this.partitions.delete(partitionId);\n\n    // Update local node\n    const localNode = this.nodes.get(this.localNodeId)!;\n    localNode.partitions = localNode.partitions.filter((p) => p !== partitionId);\n\n    this.logger.info('Deleted partition', { partitionId });\n    this.emit('memory:partition-deleted', { partitionId });\n\n    // Sync with other nodes if distributed\n    if (this.config.distributed) {\n      await this.syncPartitionDeletion(partitionId);\n    }\n  }\n\n  // === ENTRY OPERATIONS ===\n\n  async store(\n    key: string,\n    value: any,\n    options: {\n      type?: string;\n      tags?: string[];\n      owner?: AgentId;\n      accessLevel?: AccessLevel;\n      partition?: string;\n      ttl?: number;\n      replicate?: boolean;\n    } = {},\n  ): Promise<string> {\n    const startTime = Date.now();\n\n    try {\n      const entryId = generateId('entry');\n      const now = new Date();\n\n      // Determine partition\n      const partitionId = options.partition || this.selectPartition(options.type || 'knowledge');\n      const partition = this.partitions.get(partitionId);\n\n      if (!partition) {\n        throw new Error(`Partition ${partitionId} not found`);\n      }\n\n      if (partition.readOnly) {\n        throw new Error('Cannot write to read-only partition');\n      }\n\n      // Check partition capacity\n      if (this.getPartitionSize(partitionId) >= partition.maxSize) {\n        await this.evictOldEntries(partitionId);\n      }\n\n      // Create entry\n      const entry: MemoryEntry = {\n        id: entryId,\n        key,\n        value: await this.processValue(value, partition),\n        type: options.type || 'data',\n        tags: options.tags || [],\n        owner: options.owner || { id: 'system', swarmId: '', type: 'coordinator', instance: 0 },\n        accessLevel: options.accessLevel || 'swarm',\n        createdAt: now,\n        updatedAt: now,\n        expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n        version: 1,\n        references: [],\n        dependencies: [],\n      };\n\n      // Store entry\n      this.entries.set(entryId, entry);\n      partition.entries.push(entry);\n\n      // Update cache\n      this.updateCache(entryId, entry);\n\n      // Update vector clock\n      this.incrementVectorClock(this.localNodeId);\n\n      this.logger.debug('Stored entry', { entryId, key, partition: partitionId });\n      this.emit('memory:entry-stored', { entry });\n\n      // Replicate if distributed and requested\n      if (this.config.distributed && options.replicate !== false) {\n        await this.replicateEntry(entry);\n      }\n\n      this.recordMetric('store', Date.now() - startTime);\n      return entryId;\n    } catch (error) {\n      this.recordMetric('store-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async retrieve(\n    key: string,\n    options: {\n      partition?: string;\n      consistency?: ConsistencyLevel;\n      maxAge?: number;\n    } = {},\n  ): Promise<MemoryEntry | null> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first\n      const cached = this.getCachedEntry(key);\n      if (cached && this.isCacheValid(cached)) {\n        this.recordMetric('retrieve-cache', Date.now() - startTime);\n        return cached.entry;\n      }\n\n      // Search in specified partition or all partitions\n      const partitions = options.partition\n        ? [this.partitions.get(options.partition)].filter(Boolean)\n        : Array.from(this.partitions.values());\n\n      for (const partition of partitions) {\n        const entry = partition!.entries.find((e) => e.key === key);\n        if (entry) {\n          // Check if entry is expired\n          if (entry.expiresAt && entry.expiresAt < new Date()) {\n            await this.deleteEntry(entry.id);\n            continue;\n          }\n\n          // Check access permissions\n          if (!this.checkAccess(entry, 'read')) {\n            continue;\n          }\n\n          // Apply consistency model\n          if (this.config.distributed && options.consistency === 'strong') {\n            const latestEntry = await this.ensureConsistency(entry);\n            this.updateCache(latestEntry.id, latestEntry);\n            this.recordMetric('retrieve', Date.now() - startTime);\n            return latestEntry;\n          }\n\n          this.updateCache(entry.id, entry);\n          this.recordMetric('retrieve', Date.now() - startTime);\n          return entry;\n        }\n      }\n\n      // Not found locally, try remote nodes if distributed\n      if (this.config.distributed) {\n        const remoteEntry = await this.retrieveFromRemote(key, options);\n        if (remoteEntry) {\n          this.recordMetric('retrieve-remote', Date.now() - startTime);\n          return remoteEntry;\n        }\n      }\n\n      this.recordMetric('retrieve-miss', Date.now() - startTime);\n      return null;\n    } catch (error) {\n      this.recordMetric('retrieve-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async update(\n    key: string,\n    value: any,\n    options: {\n      partition?: string;\n      merge?: boolean;\n      version?: number;\n    } = {},\n  ): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = await this.retrieve(key, { partition: options.partition });\n      if (!entry) {\n        this.recordMetric('update-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Check access permissions\n      if (!this.checkAccess(entry, 'write')) {\n        throw new Error('Access denied for update operation');\n      }\n\n      // Version check for optimistic locking\n      if (options.version && entry.version !== options.version) {\n        throw new Error('Version conflict: entry has been modified');\n      }\n\n      // Update entry\n      const partition = this.partitions.get(this.getEntryPartition(entry.id))!;\n\n      entry.value = options.merge\n        ? await this.mergeValues(entry.value, value, partition)\n        : await this.processValue(value, partition);\n\n      entry.updatedAt = new Date();\n      entry.version++;\n\n      // Update cache\n      this.updateCache(entry.id, entry);\n\n      // Update vector clock\n      this.incrementVectorClock(this.localNodeId);\n\n      this.logger.debug('Updated entry', { entryId: entry.id, key });\n      this.emit('memory:entry-updated', { entry });\n\n      // Sync with other nodes if distributed\n      if (this.config.distributed) {\n        await this.syncEntryUpdate(entry);\n      }\n\n      this.recordMetric('update', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('update-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  async deleteEntry(entryId: string): Promise<boolean> {\n    const startTime = Date.now();\n\n    try {\n      const entry = this.entries.get(entryId);\n      if (!entry) {\n        this.recordMetric('delete-not-found', Date.now() - startTime);\n        return false;\n      }\n\n      // Check access permissions\n      if (!this.checkAccess(entry, 'delete')) {\n        throw new Error('Access denied for delete operation');\n      }\n\n      // Remove from partition\n      const partitionId = this.getEntryPartition(entryId);\n      const partition = this.partitions.get(partitionId);\n      if (partition) {\n        partition.entries = partition.entries.filter((e) => e.id !== entryId);\n      }\n\n      // Remove from storage\n      this.entries.delete(entryId);\n\n      // Remove from cache\n      this.removeFromCache(entry.key);\n\n      // Update vector clock\n      this.incrementVectorClock(this.localNodeId);\n\n      this.logger.debug('Deleted entry', { entryId, key: entry.key });\n      this.emit('memory:entry-deleted', { entryId });\n\n      // Sync with other nodes if distributed\n      if (this.config.distributed) {\n        await this.syncEntryDeletion(entryId);\n      }\n\n      this.recordMetric('delete', Date.now() - startTime);\n      return true;\n    } catch (error) {\n      this.recordMetric('delete-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  // === QUERY OPERATIONS ===\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    const startTime = Date.now();\n\n    try {\n      let results: MemoryEntry[] = [];\n\n      // Get relevant partitions\n      const partitions = query.partition\n        ? [this.partitions.get(query.partition)].filter(Boolean)\n        : Array.from(this.partitions.values());\n\n      for (const partition of partitions) {\n        for (const entry of partition!.entries) {\n          if (this.matchesQuery(entry, query)) {\n            results.push(entry);\n          }\n        }\n      }\n\n      // Apply sorting\n      if (query.sortBy) {\n        results.sort((a, b) => {\n          const aVal = this.getNestedProperty(a, query.sortBy!);\n          const bVal = this.getNestedProperty(b, query.sortBy!);\n          const order = query.sortOrder === 'desc' ? -1 : 1;\n\n          if (aVal < bVal) return -1 * order;\n          if (aVal > bVal) return 1 * order;\n          return 0;\n        });\n      }\n\n      // Apply pagination\n      const offset = query.offset || 0;\n      const limit = query.limit || results.length;\n      results = results.slice(offset, offset + limit);\n\n      this.recordMetric('query', Date.now() - startTime);\n      return results;\n    } catch (error) {\n      this.recordMetric('query-error', Date.now() - startTime);\n      throw error;\n    }\n  }\n\n  /**\n   * Query entries by type\n   */\n  async queryByType(type: string, namespace?: string): Promise<MemoryEntry[]> {\n    return this.query({\n      filter: { type },\n      namespace,\n    });\n  }\n\n  // === SYNCHRONIZATION ===\n\n  private startSynchronization(): void {\n    this.syncInterval = setInterval(() => {\n      this.performSync();\n    }, this.config.syncInterval);\n\n    this.logger.info('Started synchronization', {\n      interval: this.config.syncInterval,\n      consistency: this.config.consistency,\n    });\n  }\n\n  private async performSync(): Promise<void> {\n    try {\n      // Process pending sync operations\n      await this.processSyncQueue();\n\n      // Send heartbeat to other nodes\n      await this.sendHeartbeat();\n\n      // Check for conflicts and resolve them\n      await this.detectAndResolveConflicts();\n\n      // Update statistics\n      this.updateStatistics();\n    } catch (error) {\n      this.logger.error('Sync error', error);\n    }\n  }\n\n  private async processSyncQueue(): Promise<void> {\n    const pendingOps = this.syncQueue.filter((op) => op.status === 'pending');\n\n    for (const operation of pendingOps) {\n      try {\n        operation.status = 'in_progress';\n        await this.executeSyncOperation(operation);\n        operation.status = 'completed';\n\n        this.statistics.syncOperations.completed++;\n      } catch (error) {\n        operation.status = 'failed';\n        this.statistics.syncOperations.failed++;\n        this.logger.error('Sync operation failed', { operation, error });\n      }\n    }\n\n    // Remove completed/failed operations older than 1 hour\n    const cutoff = new Date(Date.now() - 3600000);\n    this.syncQueue = this.syncQueue.filter(\n      (op) => op.status === 'pending' || op.timestamp > cutoff,\n    );\n  }\n\n  // === UTILITY METHODS ===\n\n  private async processValue(value: any, partition: MemoryPartition): Promise<any> {\n    if (partition.compressed && this.config.compressionEnabled) {\n      return this.compressValue(value);\n    }\n    return value;\n  }\n\n  private async mergeValues(\n    oldValue: any,\n    newValue: any,\n    partition: MemoryPartition,\n  ): Promise<any> {\n    // Simple merge strategy - can be enhanced\n    if (typeof oldValue === 'object' && typeof newValue === 'object') {\n      return { ...oldValue, ...newValue };\n    }\n    return newValue;\n  }\n\n  private compressValue(value: any): any {\n    // Placeholder for compression logic\n    return value;\n  }\n\n  private checkAccess(entry: MemoryEntry, operation: 'read' | 'write' | 'delete'): boolean {\n    // Simplified access control - can be enhanced\n    return true;\n  }\n\n  private selectPartition(type: string): string {\n    // Simple partition selection based on type\n    for (const [id, partition] of this.partitions) {\n      if (partition.type === type) {\n        return id;\n      }\n    }\n\n    // Default to first available partition\n    return Array.from(this.partitions.keys())[0] || '';\n  }\n\n  private getPartitionSize(partitionId: string): number {\n    const partition = this.partitions.get(partitionId);\n    if (!partition) return 0;\n\n    return partition.entries.reduce((size, entry) => {\n      return size + JSON.stringify(entry).length;\n    }, 0);\n  }\n\n  private getEntryPartition(entryId: string): string {\n    for (const [partitionId, partition] of this.partitions) {\n      if (partition.entries.some((e) => e.id === entryId)) {\n        return partitionId;\n      }\n    }\n    return '';\n  }\n\n  private updateCache(entryId: string, entry: MemoryEntry): void {\n    if (this.cache.size >= this.config.cacheSize) {\n      this.evictCache();\n    }\n\n    this.cache.set(entry.key, {\n      entry: { ...entry },\n      expiry: Date.now() + this.config.cacheTtl,\n    });\n  }\n\n  private getCachedEntry(key: string): { entry: MemoryEntry; expiry: number } | null {\n    return this.cache.get(key) || null;\n  }\n\n  private isCacheValid(cached: { entry: MemoryEntry; expiry: number }): boolean {\n    return cached.expiry > Date.now();\n  }\n\n  private removeFromCache(key: string): void {\n    this.cache.delete(key);\n  }\n\n  private evictCache(): void {\n    // Simple LRU eviction - remove oldest entries\n    const entries = Array.from(this.cache.entries());\n    entries.sort((a, b) => a[1].expiry - b[1].expiry);\n\n    const toRemove = entries.slice(0, Math.floor(this.config.cacheSize * 0.1));\n    toRemove.forEach(([key]) => this.cache.delete(key));\n  }\n\n  private async evictOldEntries(partitionId: string): Promise<void> {\n    const partition = this.partitions.get(partitionId);\n    if (!partition) return;\n\n    // Sort by last access time and remove oldest 10%\n    const entries = partition.entries.sort((a, b) => a.updatedAt.getTime() - b.updatedAt.getTime());\n\n    const toRemove = entries.slice(0, Math.floor(entries.length * 0.1));\n    for (const entry of toRemove) {\n      await this.deleteEntry(entry.id);\n    }\n  }\n\n  private matchesQuery(entry: MemoryEntry, query: MemoryQuery): boolean {\n    if (query.type && entry.type !== query.type) return false;\n    if (query.owner && entry.owner.id !== query.owner.id) return false;\n    if (query.accessLevel && entry.accessLevel !== query.accessLevel) return false;\n    if (query.createdAfter && entry.createdAt < query.createdAfter) return false;\n    if (query.updatedAfter && entry.updatedAt < query.updatedAfter) return false;\n\n    if (query.tags && query.tags.length > 0) {\n      const hasAllTags = query.tags.every((tag) => entry.tags.includes(tag));\n      if (!hasAllTags) return false;\n    }\n\n    return true;\n  }\n\n  private getNestedProperty(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n\n  private incrementVectorClock(nodeId: string): void {\n    const current = this.vectorClock.get(nodeId) || 0;\n    this.vectorClock.set(nodeId, current + 1);\n  }\n\n  private recordMetric(operation: string, duration: number): void {\n    const current = this.operationMetrics.get(operation) || { count: 0, totalTime: 0 };\n    current.count++;\n    current.totalTime += duration;\n    this.operationMetrics.set(operation, current);\n  }\n\n  private initializeStatistics(): MemoryStatistics {\n    return {\n      totalEntries: 0,\n      totalSize: 0,\n      partitionCount: 0,\n      nodeCount: 1,\n      replicationHealth: 1.0,\n      syncOperations: {\n        pending: 0,\n        completed: 0,\n        failed: 0,\n      },\n      performance: {\n        readLatency: 0,\n        writeLatency: 0,\n        syncLatency: 0,\n        throughput: 0,\n      },\n      utilization: {\n        memoryUsage: 0,\n        diskUsage: 0,\n        networkUsage: 0,\n      },\n    };\n  }\n\n  private updateStatistics(): void {\n    this.statistics.totalEntries = this.entries.size;\n    this.statistics.partitionCount = this.partitions.size;\n    this.statistics.nodeCount = this.nodes.size;\n\n    // Calculate performance metrics\n    const readMetrics = this.operationMetrics.get('retrieve') || { count: 0, totalTime: 0 };\n    const writeMetrics = this.operationMetrics.get('store') || { count: 0, totalTime: 0 };\n\n    this.statistics.performance.readLatency =\n      readMetrics.count > 0 ? readMetrics.totalTime / readMetrics.count : 0;\n    this.statistics.performance.writeLatency =\n      writeMetrics.count > 0 ? writeMetrics.totalTime / writeMetrics.count : 0;\n  }\n\n  // === DISTRIBUTED OPERATIONS (Placeholders) ===\n\n  private async replicateEntry(entry: MemoryEntry): Promise<void> {\n    // Implementation for replication to other nodes\n  }\n\n  private async syncPartitionCreation(partition: MemoryPartition): Promise<void> {\n    // Implementation for syncing partition creation\n  }\n\n  private async syncPartitionDeletion(partitionId: string): Promise<void> {\n    // Implementation for syncing partition deletion\n  }\n\n  private async syncEntryUpdate(entry: MemoryEntry): Promise<void> {\n    // Implementation for syncing entry updates\n  }\n\n  private async syncEntryDeletion(entryId: string): Promise<void> {\n    // Implementation for syncing entry deletion\n  }\n\n  private async retrieveFromRemote(key: string, options: any): Promise<MemoryEntry | null> {\n    // Implementation for retrieving from remote nodes\n    return null;\n  }\n\n  private async ensureConsistency(entry: MemoryEntry): Promise<MemoryEntry> {\n    // Implementation for ensuring strong consistency\n    return entry;\n  }\n\n  private async sendHeartbeat(): Promise<void> {\n    // Implementation for sending heartbeat to other nodes\n  }\n\n  private async detectAndResolveConflicts(): Promise<void> {\n    // Implementation for conflict detection and resolution\n  }\n\n  private async executeSyncOperation(operation: SyncOperation): Promise<void> {\n    // Implementation for executing sync operations\n  }\n\n  private async completePendingSyncOperations(): Promise<void> {\n    // Implementation for completing pending operations\n  }\n\n  private async loadPersistedData(): Promise<void> {\n    // Implementation for loading persisted data\n  }\n\n  private async persistData(): Promise<void> {\n    // Implementation for persisting data\n  }\n\n  private handleSyncRequest(data: any): void {\n    // Handle sync requests from other nodes\n  }\n\n  private handleNodeJoined(data: any): void {\n    // Handle new node joining\n  }\n\n  private handleNodeLeft(data: any): void {\n    // Handle node leaving\n  }\n\n  private handleConflict(data: any): void {\n    // Handle conflict resolution\n  }\n\n  // === PUBLIC API ===\n\n  getStatistics(): MemoryStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n\n  getPartitions(): MemoryPartition[] {\n    return Array.from(this.partitions.values());\n  }\n\n  getNodes(): MemoryNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  async backup(): Promise<string> {\n    // Create backup of all data\n    const backup = {\n      timestamp: new Date(),\n      partitions: Array.from(this.partitions.values()),\n      entries: Array.from(this.entries.values()),\n      metadata: {\n        version: '1.0',\n        nodeId: this.localNodeId,\n        config: this.config,\n      },\n    };\n\n    return JSON.stringify(backup);\n  }\n\n  async restore(backupData: string): Promise<void> {\n    // Restore from backup\n    const backup = JSON.parse(backupData);\n\n    // Clear current data\n    this.partitions.clear();\n    this.entries.clear();\n    this.cache.clear();\n\n    // Restore partitions\n    for (const partition of backup.partitions) {\n      this.partitions.set(partition.id, partition);\n    }\n\n    // Restore entries\n    for (const entry of backup.entries) {\n      this.entries.set(entry.id, entry);\n    }\n\n    this.logger.info('Restored from backup', {\n      partitions: backup.partitions.length,\n      entries: backup.entries.length,\n    });\n  }\n\n  async clear(): Promise<void> {\n    this.partitions.clear();\n    this.entries.clear();\n    this.cache.clear();\n    this.syncQueue = [];\n    this.statistics = this.initializeStatistics();\n\n    this.logger.info('Cleared all memory data');\n    this.emit('memory:cleared');\n  }\n}\n"],"names":["EventEmitter","generateId","DistributedMemorySystem","logger","eventBus","config","partitions","Map","entries","cache","nodes","localNodeId","syncQueue","replicationMap","syncInterval","vectorClock","conflictResolver","statistics","operationMetrics","namespace","distributed","consistency","replicationFactor","maxMemorySize","compressionEnabled","encryptionEnabled","backupEnabled","persistenceEnabled","shardingEnabled","cacheSize","cacheTtl","initializeStatistics","setupEventHandlers","on","data","handleSyncRequest","handleNodeJoined","handleNodeLeft","handleConflict","initialize","info","nodeId","localNode","id","address","port","status","lastSeen","Date","load","capacity","set","createPartition","startSynchronization","loadPersistedData","emit","shutdown","clearInterval","completePendingSyncOperations","persistData","clear","name","type","options","partitionId","partition","maxSize","ttl","readOnly","shared","indexed","compressed","get","push","syncPartitionCreation","deletePartition","Error","entriesToDelete","Array","from","values","filter","entry","getEntryPartition","deleteEntry","delete","p","syncPartitionDeletion","store","key","value","startTime","now","entryId","selectPartition","getPartitionSize","evictOldEntries","processValue","tags","owner","swarmId","instance","accessLevel","createdAt","updatedAt","expiresAt","getTime","undefined","version","references","dependencies","updateCache","incrementVectorClock","debug","replicate","replicateEntry","recordMetric","error","retrieve","cached","getCachedEntry","isCacheValid","Boolean","find","e","checkAccess","latestEntry","ensureConsistency","remoteEntry","retrieveFromRemote","update","merge","mergeValues","syncEntryUpdate","removeFromCache","syncEntryDeletion","query","results","matchesQuery","sortBy","sort","a","b","aVal","getNestedProperty","bVal","order","sortOrder","offset","limit","length","slice","queryByType","setInterval","performSync","interval","processSyncQueue","sendHeartbeat","detectAndResolveConflicts","updateStatistics","pendingOps","op","operation","executeSyncOperation","syncOperations","completed","failed","cutoff","timestamp","compressValue","oldValue","newValue","keys","reduce","size","JSON","stringify","some","evictCache","expiry","toRemove","Math","floor","forEach","createdAfter","updatedAfter","hasAllTags","every","tag","includes","obj","path","split","current","duration","count","totalTime","totalEntries","totalSize","partitionCount","nodeCount","replicationHealth","pending","performance","readLatency","writeLatency","syncLatency","throughput","utilization","memoryUsage","diskUsage","networkUsage","readMetrics","writeMetrics","getStatistics","getPartitions","getNodes","backup","metadata","restore","backupData","parse"],"mappings":"AAIA,SAASA,YAAY,QAAQ,cAAc;AAa3C,SAASC,UAAU,QAAQ,sBAAsB;AAuFjD,OAAO,MAAMC,gCAAgCF;IACnCG,OAAgB;IAChBC,SAAoB;IACpBC,OAAgC;IAGhCC,aAAa,IAAIC,MAA+B;IAChDC,UAAU,IAAID,MAA2B;IACzCE,QAAQ,IAAIF,MAAsD;IAGlEG,QAAQ,IAAIH,MAA0B;IACtCI,YAAoB;IACpBC,YAA6B,EAAE,CAAC;IAChCC,iBAAiB,IAAIN,MAAwB;IAG7CO,aAA8B;IAC9BC,cAAc,IAAIR,MAAsB;IACxCS,iBAA4E;IAG5EC,WAA6B;IAC7BC,mBAAmB,IAAIX,MAAoD;IAEnF,YAAYF,MAAwC,EAAEF,MAAe,EAAEC,QAAmB,CAAE;QAC1F,KAAK;QACL,IAAI,CAACD,MAAM,GAAGA;QACd,IAAI,CAACC,QAAQ,GAAGA;QAEhB,IAAI,CAACC,MAAM,GAAG;YACZc,WAAW;YACXC,aAAa;YACbC,aAAa;YACbC,mBAAmB;YACnBR,cAAc;YACdS,eAAe,OAAO,OAAO;YAC7BC,oBAAoB;YACpBC,mBAAmB;YACnBC,eAAe;YACfC,oBAAoB;YACpBC,iBAAiB;YACjBC,WAAW;YACXC,UAAU;YACV,GAAGzB,MAAM;QACX;QAEA,IAAI,CAACM,WAAW,GAAGV,WAAW;QAC9B,IAAI,CAACgB,UAAU,GAAG,IAAI,CAACc,oBAAoB;QAE3C,IAAI,CAACC,kBAAkB;IACzB;IAEQA,qBAA2B;QACjC,IAAI,CAAC5B,QAAQ,CAAC6B,EAAE,CAAC,uBAAuB,CAACC;YACvC,IAAI,CAACC,iBAAiB,CAACD;QACzB;QAEA,IAAI,CAAC9B,QAAQ,CAAC6B,EAAE,CAAC,sBAAsB,CAACC;YACtC,IAAI,CAACE,gBAAgB,CAACF;QACxB;QAEA,IAAI,CAAC9B,QAAQ,CAAC6B,EAAE,CAAC,oBAAoB,CAACC;YACpC,IAAI,CAACG,cAAc,CAACH;QACtB;QAEA,IAAI,CAAC9B,QAAQ,CAAC6B,EAAE,CAAC,4BAA4B,CAACC;YAC5C,IAAI,CAACI,cAAc,CAACJ;QACtB;IACF;IAEA,MAAMK,aAA4B;QAChC,IAAI,CAACpC,MAAM,CAACqC,IAAI,CAAC,0CAA0C;YACzDC,QAAQ,IAAI,CAAC9B,WAAW;YACxBQ,WAAW,IAAI,CAACd,MAAM,CAACc,SAAS;YAChCC,aAAa,IAAI,CAACf,MAAM,CAACe,WAAW;QACtC;QAGA,MAAMsB,YAAwB;YAC5BC,IAAI,IAAI,CAAChC,WAAW;YACpBiC,SAAS;YACTC,MAAM;YACNC,QAAQ;YACRC,UAAU,IAAIC;YACd1C,YAAY,EAAE;YACd2C,MAAM;YACNC,UAAU,IAAI,CAAC7C,MAAM,CAACkB,aAAa;QACrC;QAEA,IAAI,CAACb,KAAK,CAACyC,GAAG,CAAC,IAAI,CAACxC,WAAW,EAAE+B;QAGjC,MAAM,IAAI,CAACU,eAAe,CAAC,aAAa;QACxC,MAAM,IAAI,CAACA,eAAe,CAAC,SAAS;QACpC,MAAM,IAAI,CAACA,eAAe,CAAC,SAAS;QACpC,MAAM,IAAI,CAACA,eAAe,CAAC,WAAW;QAGtC,IAAI,IAAI,CAAC/C,MAAM,CAACe,WAAW,EAAE;YAC3B,IAAI,CAACiC,oBAAoB;QAC3B;QAGA,IAAI,IAAI,CAAChD,MAAM,CAACsB,kBAAkB,EAAE;YAClC,MAAM,IAAI,CAAC2B,iBAAiB;QAC9B;QAEA,IAAI,CAACC,IAAI,CAAC,sBAAsB;YAAEd,QAAQ,IAAI,CAAC9B,WAAW;QAAC;IAC7D;IAEA,MAAM6C,WAA0B;QAC9B,IAAI,CAACrD,MAAM,CAACqC,IAAI,CAAC;QAGjB,IAAI,IAAI,CAAC1B,YAAY,EAAE;YACrB2C,cAAc,IAAI,CAAC3C,YAAY;QACjC;QAGA,MAAM,IAAI,CAAC4C,6BAA6B;QAGxC,IAAI,IAAI,CAACrD,MAAM,CAACsB,kBAAkB,EAAE;YAClC,MAAM,IAAI,CAACgC,WAAW;QACxB;QAGA,IAAI,CAAClD,KAAK,CAACmD,KAAK;QAChB,IAAI,CAACtD,UAAU,CAACsD,KAAK;QACrB,IAAI,CAACpD,OAAO,CAACoD,KAAK;QAElB,IAAI,CAACL,IAAI,CAAC,mBAAmB;YAAEd,QAAQ,IAAI,CAAC9B,WAAW;QAAC;IAC1D;IAIA,MAAMyC,gBACJS,IAAY,EACZC,IAAgB,EAChBC,UAOI,CAAC,CAAC,EACW;QACjB,MAAMC,cAAc/D,WAAW;QAE/B,MAAMgE,YAA6B;YACjCtB,IAAIqB;YACJH;YACAC;YACAtD,SAAS,EAAE;YACX0D,SAASH,QAAQG,OAAO,IAAI,IAAI,CAAC7D,MAAM,CAACkB,aAAa,GAAG;YACxD4C,KAAKJ,QAAQI,GAAG;YAChBC,UAAUL,QAAQK,QAAQ,IAAI;YAC9BC,QAAQN,QAAQM,MAAM,KAAK;YAC3BC,SAASP,QAAQO,OAAO,IAAI;YAC5BC,YAAYR,QAAQQ,UAAU,IAAI,IAAI,CAAClE,MAAM,CAACmB,kBAAkB;QAClE;QAEA,IAAI,CAAClB,UAAU,CAAC6C,GAAG,CAACa,aAAaC;QAGjC,MAAMvB,YAAY,IAAI,CAAChC,KAAK,CAAC8D,GAAG,CAAC,IAAI,CAAC7D,WAAW;QACjD+B,UAAUpC,UAAU,CAACmE,IAAI,CAACT;QAE1B,IAAI,CAAC7D,MAAM,CAACqC,IAAI,CAAC,qBAAqB;YAAEwB;YAAaH;YAAMC;QAAK;QAChE,IAAI,CAACP,IAAI,CAAC,4BAA4B;YAAEU;QAAU;QAGlD,IAAI,IAAI,CAAC5D,MAAM,CAACe,WAAW,EAAE;YAC3B,MAAM,IAAI,CAACsD,qBAAqB,CAACT;QACnC;QAEA,OAAOD;IACT;IAEA,MAAMW,gBAAgBX,WAAmB,EAAiB;QACxD,MAAMC,YAAY,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACR;QACtC,IAAI,CAACC,WAAW;YACd,MAAM,IAAIW,MAAM,CAAC,UAAU,EAAEZ,YAAY,UAAU,CAAC;QACtD;QAGA,MAAMa,kBAAkBC,MAAMC,IAAI,CAAC,IAAI,CAACvE,OAAO,CAACwE,MAAM,IAAIC,MAAM,CAC9D,CAACC,QAAU,IAAI,CAACC,iBAAiB,CAACD,MAAMvC,EAAE,MAAMqB;QAGlD,KAAK,MAAMkB,SAASL,gBAAiB;YACnC,MAAM,IAAI,CAACO,WAAW,CAACF,MAAMvC,EAAE;QACjC;QAGA,IAAI,CAACrC,UAAU,CAAC+E,MAAM,CAACrB;QAGvB,MAAMtB,YAAY,IAAI,CAAChC,KAAK,CAAC8D,GAAG,CAAC,IAAI,CAAC7D,WAAW;QACjD+B,UAAUpC,UAAU,GAAGoC,UAAUpC,UAAU,CAAC2E,MAAM,CAAC,CAACK,IAAMA,MAAMtB;QAEhE,IAAI,CAAC7D,MAAM,CAACqC,IAAI,CAAC,qBAAqB;YAAEwB;QAAY;QACpD,IAAI,CAACT,IAAI,CAAC,4BAA4B;YAAES;QAAY;QAGpD,IAAI,IAAI,CAAC3D,MAAM,CAACe,WAAW,EAAE;YAC3B,MAAM,IAAI,CAACmE,qBAAqB,CAACvB;QACnC;IACF;IAIA,MAAMwB,MACJC,GAAW,EACXC,KAAU,EACV3B,UAQI,CAAC,CAAC,EACW;QACjB,MAAM4B,YAAY3C,KAAK4C,GAAG;QAE1B,IAAI;YACF,MAAMC,UAAU5F,WAAW;YAC3B,MAAM2F,MAAM,IAAI5C;YAGhB,MAAMgB,cAAcD,QAAQE,SAAS,IAAI,IAAI,CAAC6B,eAAe,CAAC/B,QAAQD,IAAI,IAAI;YAC9E,MAAMG,YAAY,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACR;YAEtC,IAAI,CAACC,WAAW;gBACd,MAAM,IAAIW,MAAM,CAAC,UAAU,EAAEZ,YAAY,UAAU,CAAC;YACtD;YAEA,IAAIC,UAAUG,QAAQ,EAAE;gBACtB,MAAM,IAAIQ,MAAM;YAClB;YAGA,IAAI,IAAI,CAACmB,gBAAgB,CAAC/B,gBAAgBC,UAAUC,OAAO,EAAE;gBAC3D,MAAM,IAAI,CAAC8B,eAAe,CAAChC;YAC7B;YAGA,MAAMkB,QAAqB;gBACzBvC,IAAIkD;gBACJJ;gBACAC,OAAO,MAAM,IAAI,CAACO,YAAY,CAACP,OAAOzB;gBACtCH,MAAMC,QAAQD,IAAI,IAAI;gBACtBoC,MAAMnC,QAAQmC,IAAI,IAAI,EAAE;gBACxBC,OAAOpC,QAAQoC,KAAK,IAAI;oBAAExD,IAAI;oBAAUyD,SAAS;oBAAItC,MAAM;oBAAeuC,UAAU;gBAAE;gBACtFC,aAAavC,QAAQuC,WAAW,IAAI;gBACpCC,WAAWX;gBACXY,WAAWZ;gBACXa,WAAW1C,QAAQI,GAAG,GAAG,IAAInB,KAAK4C,IAAIc,OAAO,KAAK3C,QAAQI,GAAG,IAAIwC;gBACjEC,SAAS;gBACTC,YAAY,EAAE;gBACdC,cAAc,EAAE;YAClB;YAGA,IAAI,CAACtG,OAAO,CAAC2C,GAAG,CAAC0C,SAASX;YAC1BjB,UAAUzD,OAAO,CAACiE,IAAI,CAACS;YAGvB,IAAI,CAAC6B,WAAW,CAAClB,SAASX;YAG1B,IAAI,CAAC8B,oBAAoB,CAAC,IAAI,CAACrG,WAAW;YAE1C,IAAI,CAACR,MAAM,CAAC8G,KAAK,CAAC,gBAAgB;gBAAEpB;gBAASJ;gBAAKxB,WAAWD;YAAY;YACzE,IAAI,CAACT,IAAI,CAAC,uBAAuB;gBAAE2B;YAAM;YAGzC,IAAI,IAAI,CAAC7E,MAAM,CAACe,WAAW,IAAI2C,QAAQmD,SAAS,KAAK,OAAO;gBAC1D,MAAM,IAAI,CAACC,cAAc,CAACjC;YAC5B;YAEA,IAAI,CAACkC,YAAY,CAAC,SAASpE,KAAK4C,GAAG,KAAKD;YACxC,OAAOE;QACT,EAAE,OAAOwB,OAAO;YACd,IAAI,CAACD,YAAY,CAAC,eAAepE,KAAK4C,GAAG,KAAKD;YAC9C,MAAM0B;QACR;IACF;IAEA,MAAMC,SACJ7B,GAAW,EACX1B,UAII,CAAC,CAAC,EACuB;QAC7B,MAAM4B,YAAY3C,KAAK4C,GAAG;QAE1B,IAAI;YAEF,MAAM2B,SAAS,IAAI,CAACC,cAAc,CAAC/B;YACnC,IAAI8B,UAAU,IAAI,CAACE,YAAY,CAACF,SAAS;gBACvC,IAAI,CAACH,YAAY,CAAC,kBAAkBpE,KAAK4C,GAAG,KAAKD;gBACjD,OAAO4B,OAAOrC,KAAK;YACrB;YAGA,MAAM5E,aAAayD,QAAQE,SAAS,GAChC;gBAAC,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACT,QAAQE,SAAS;aAAE,CAACgB,MAAM,CAACyC,WAChD5C,MAAMC,IAAI,CAAC,IAAI,CAACzE,UAAU,CAAC0E,MAAM;YAErC,KAAK,MAAMf,aAAa3D,WAAY;gBAClC,MAAM4E,QAAQjB,UAAWzD,OAAO,CAACmH,IAAI,CAAC,CAACC,IAAMA,EAAEnC,GAAG,KAAKA;gBACvD,IAAIP,OAAO;oBAET,IAAIA,MAAMuB,SAAS,IAAIvB,MAAMuB,SAAS,GAAG,IAAIzD,QAAQ;wBACnD,MAAM,IAAI,CAACoC,WAAW,CAACF,MAAMvC,EAAE;wBAC/B;oBACF;oBAGA,IAAI,CAAC,IAAI,CAACkF,WAAW,CAAC3C,OAAO,SAAS;wBACpC;oBACF;oBAGA,IAAI,IAAI,CAAC7E,MAAM,CAACe,WAAW,IAAI2C,QAAQ1C,WAAW,KAAK,UAAU;wBAC/D,MAAMyG,cAAc,MAAM,IAAI,CAACC,iBAAiB,CAAC7C;wBACjD,IAAI,CAAC6B,WAAW,CAACe,YAAYnF,EAAE,EAAEmF;wBACjC,IAAI,CAACV,YAAY,CAAC,YAAYpE,KAAK4C,GAAG,KAAKD;wBAC3C,OAAOmC;oBACT;oBAEA,IAAI,CAACf,WAAW,CAAC7B,MAAMvC,EAAE,EAAEuC;oBAC3B,IAAI,CAACkC,YAAY,CAAC,YAAYpE,KAAK4C,GAAG,KAAKD;oBAC3C,OAAOT;gBACT;YACF;YAGA,IAAI,IAAI,CAAC7E,MAAM,CAACe,WAAW,EAAE;gBAC3B,MAAM4G,cAAc,MAAM,IAAI,CAACC,kBAAkB,CAACxC,KAAK1B;gBACvD,IAAIiE,aAAa;oBACf,IAAI,CAACZ,YAAY,CAAC,mBAAmBpE,KAAK4C,GAAG,KAAKD;oBAClD,OAAOqC;gBACT;YACF;YAEA,IAAI,CAACZ,YAAY,CAAC,iBAAiBpE,KAAK4C,GAAG,KAAKD;YAChD,OAAO;QACT,EAAE,OAAO0B,OAAO;YACd,IAAI,CAACD,YAAY,CAAC,kBAAkBpE,KAAK4C,GAAG,KAAKD;YACjD,MAAM0B;QACR;IACF;IAEA,MAAMa,OACJzC,GAAW,EACXC,KAAU,EACV3B,UAII,CAAC,CAAC,EACY;QAClB,MAAM4B,YAAY3C,KAAK4C,GAAG;QAE1B,IAAI;YACF,MAAMV,QAAQ,MAAM,IAAI,CAACoC,QAAQ,CAAC7B,KAAK;gBAAExB,WAAWF,QAAQE,SAAS;YAAC;YACtE,IAAI,CAACiB,OAAO;gBACV,IAAI,CAACkC,YAAY,CAAC,oBAAoBpE,KAAK4C,GAAG,KAAKD;gBACnD,OAAO;YACT;YAGA,IAAI,CAAC,IAAI,CAACkC,WAAW,CAAC3C,OAAO,UAAU;gBACrC,MAAM,IAAIN,MAAM;YAClB;YAGA,IAAIb,QAAQ6C,OAAO,IAAI1B,MAAM0B,OAAO,KAAK7C,QAAQ6C,OAAO,EAAE;gBACxD,MAAM,IAAIhC,MAAM;YAClB;YAGA,MAAMX,YAAY,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAAC,IAAI,CAACW,iBAAiB,CAACD,MAAMvC,EAAE;YAErEuC,MAAMQ,KAAK,GAAG3B,QAAQoE,KAAK,GACvB,MAAM,IAAI,CAACC,WAAW,CAAClD,MAAMQ,KAAK,EAAEA,OAAOzB,aAC3C,MAAM,IAAI,CAACgC,YAAY,CAACP,OAAOzB;YAEnCiB,MAAMsB,SAAS,GAAG,IAAIxD;YACtBkC,MAAM0B,OAAO;YAGb,IAAI,CAACG,WAAW,CAAC7B,MAAMvC,EAAE,EAAEuC;YAG3B,IAAI,CAAC8B,oBAAoB,CAAC,IAAI,CAACrG,WAAW;YAE1C,IAAI,CAACR,MAAM,CAAC8G,KAAK,CAAC,iBAAiB;gBAAEpB,SAASX,MAAMvC,EAAE;gBAAE8C;YAAI;YAC5D,IAAI,CAAClC,IAAI,CAAC,wBAAwB;gBAAE2B;YAAM;YAG1C,IAAI,IAAI,CAAC7E,MAAM,CAACe,WAAW,EAAE;gBAC3B,MAAM,IAAI,CAACiH,eAAe,CAACnD;YAC7B;YAEA,IAAI,CAACkC,YAAY,CAAC,UAAUpE,KAAK4C,GAAG,KAAKD;YACzC,OAAO;QACT,EAAE,OAAO0B,OAAO;YACd,IAAI,CAACD,YAAY,CAAC,gBAAgBpE,KAAK4C,GAAG,KAAKD;YAC/C,MAAM0B;QACR;IACF;IAEA,MAAMjC,YAAYS,OAAe,EAAoB;QACnD,MAAMF,YAAY3C,KAAK4C,GAAG;QAE1B,IAAI;YACF,MAAMV,QAAQ,IAAI,CAAC1E,OAAO,CAACgE,GAAG,CAACqB;YAC/B,IAAI,CAACX,OAAO;gBACV,IAAI,CAACkC,YAAY,CAAC,oBAAoBpE,KAAK4C,GAAG,KAAKD;gBACnD,OAAO;YACT;YAGA,IAAI,CAAC,IAAI,CAACkC,WAAW,CAAC3C,OAAO,WAAW;gBACtC,MAAM,IAAIN,MAAM;YAClB;YAGA,MAAMZ,cAAc,IAAI,CAACmB,iBAAiB,CAACU;YAC3C,MAAM5B,YAAY,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACR;YACtC,IAAIC,WAAW;gBACbA,UAAUzD,OAAO,GAAGyD,UAAUzD,OAAO,CAACyE,MAAM,CAAC,CAAC2C,IAAMA,EAAEjF,EAAE,KAAKkD;YAC/D;YAGA,IAAI,CAACrF,OAAO,CAAC6E,MAAM,CAACQ;YAGpB,IAAI,CAACyC,eAAe,CAACpD,MAAMO,GAAG;YAG9B,IAAI,CAACuB,oBAAoB,CAAC,IAAI,CAACrG,WAAW;YAE1C,IAAI,CAACR,MAAM,CAAC8G,KAAK,CAAC,iBAAiB;gBAAEpB;gBAASJ,KAAKP,MAAMO,GAAG;YAAC;YAC7D,IAAI,CAAClC,IAAI,CAAC,wBAAwB;gBAAEsC;YAAQ;YAG5C,IAAI,IAAI,CAACxF,MAAM,CAACe,WAAW,EAAE;gBAC3B,MAAM,IAAI,CAACmH,iBAAiB,CAAC1C;YAC/B;YAEA,IAAI,CAACuB,YAAY,CAAC,UAAUpE,KAAK4C,GAAG,KAAKD;YACzC,OAAO;QACT,EAAE,OAAO0B,OAAO;YACd,IAAI,CAACD,YAAY,CAAC,gBAAgBpE,KAAK4C,GAAG,KAAKD;YAC/C,MAAM0B;QACR;IACF;IAIA,MAAMmB,MAAMA,KAAkB,EAA0B;QACtD,MAAM7C,YAAY3C,KAAK4C,GAAG;QAE1B,IAAI;YACF,IAAI6C,UAAyB,EAAE;YAG/B,MAAMnI,aAAakI,MAAMvE,SAAS,GAC9B;gBAAC,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACgE,MAAMvE,SAAS;aAAE,CAACgB,MAAM,CAACyC,WAC9C5C,MAAMC,IAAI,CAAC,IAAI,CAACzE,UAAU,CAAC0E,MAAM;YAErC,KAAK,MAAMf,aAAa3D,WAAY;gBAClC,KAAK,MAAM4E,SAASjB,UAAWzD,OAAO,CAAE;oBACtC,IAAI,IAAI,CAACkI,YAAY,CAACxD,OAAOsD,QAAQ;wBACnCC,QAAQhE,IAAI,CAACS;oBACf;gBACF;YACF;YAGA,IAAIsD,MAAMG,MAAM,EAAE;gBAChBF,QAAQG,IAAI,CAAC,CAACC,GAAGC;oBACf,MAAMC,OAAO,IAAI,CAACC,iBAAiB,CAACH,GAAGL,MAAMG,MAAM;oBACnD,MAAMM,OAAO,IAAI,CAACD,iBAAiB,CAACF,GAAGN,MAAMG,MAAM;oBACnD,MAAMO,QAAQV,MAAMW,SAAS,KAAK,SAAS,CAAC,IAAI;oBAEhD,IAAIJ,OAAOE,MAAM,OAAO,CAAC,IAAIC;oBAC7B,IAAIH,OAAOE,MAAM,OAAO,IAAIC;oBAC5B,OAAO;gBACT;YACF;YAGA,MAAME,SAASZ,MAAMY,MAAM,IAAI;YAC/B,MAAMC,QAAQb,MAAMa,KAAK,IAAIZ,QAAQa,MAAM;YAC3Cb,UAAUA,QAAQc,KAAK,CAACH,QAAQA,SAASC;YAEzC,IAAI,CAACjC,YAAY,CAAC,SAASpE,KAAK4C,GAAG,KAAKD;YACxC,OAAO8C;QACT,EAAE,OAAOpB,OAAO;YACd,IAAI,CAACD,YAAY,CAAC,eAAepE,KAAK4C,GAAG,KAAKD;YAC9C,MAAM0B;QACR;IACF;IAKA,MAAMmC,YAAY1F,IAAY,EAAE3C,SAAkB,EAA0B;QAC1E,OAAO,IAAI,CAACqH,KAAK,CAAC;YAChBvD,QAAQ;gBAAEnB;YAAK;YACf3C;QACF;IACF;IAIQkC,uBAA6B;QACnC,IAAI,CAACvC,YAAY,GAAG2I,YAAY;YAC9B,IAAI,CAACC,WAAW;QAClB,GAAG,IAAI,CAACrJ,MAAM,CAACS,YAAY;QAE3B,IAAI,CAACX,MAAM,CAACqC,IAAI,CAAC,2BAA2B;YAC1CmH,UAAU,IAAI,CAACtJ,MAAM,CAACS,YAAY;YAClCO,aAAa,IAAI,CAAChB,MAAM,CAACgB,WAAW;QACtC;IACF;IAEA,MAAcqI,cAA6B;QACzC,IAAI;YAEF,MAAM,IAAI,CAACE,gBAAgB;YAG3B,MAAM,IAAI,CAACC,aAAa;YAGxB,MAAM,IAAI,CAACC,yBAAyB;YAGpC,IAAI,CAACC,gBAAgB;QACvB,EAAE,OAAO1C,OAAO;YACd,IAAI,CAAClH,MAAM,CAACkH,KAAK,CAAC,cAAcA;QAClC;IACF;IAEA,MAAcuC,mBAAkC;QAC9C,MAAMI,aAAa,IAAI,CAACpJ,SAAS,CAACqE,MAAM,CAAC,CAACgF,KAAOA,GAAGnH,MAAM,KAAK;QAE/D,KAAK,MAAMoH,aAAaF,WAAY;YAClC,IAAI;gBACFE,UAAUpH,MAAM,GAAG;gBACnB,MAAM,IAAI,CAACqH,oBAAoB,CAACD;gBAChCA,UAAUpH,MAAM,GAAG;gBAEnB,IAAI,CAAC7B,UAAU,CAACmJ,cAAc,CAACC,SAAS;YAC1C,EAAE,OAAOhD,OAAO;gBACd6C,UAAUpH,MAAM,GAAG;gBACnB,IAAI,CAAC7B,UAAU,CAACmJ,cAAc,CAACE,MAAM;gBACrC,IAAI,CAACnK,MAAM,CAACkH,KAAK,CAAC,yBAAyB;oBAAE6C;oBAAW7C;gBAAM;YAChE;QACF;QAGA,MAAMkD,SAAS,IAAIvH,KAAKA,KAAK4C,GAAG,KAAK;QACrC,IAAI,CAAChF,SAAS,GAAG,IAAI,CAACA,SAAS,CAACqE,MAAM,CACpC,CAACgF,KAAOA,GAAGnH,MAAM,KAAK,aAAamH,GAAGO,SAAS,GAAGD;IAEtD;IAIA,MAActE,aAAaP,KAAU,EAAEzB,SAA0B,EAAgB;QAC/E,IAAIA,UAAUM,UAAU,IAAI,IAAI,CAAClE,MAAM,CAACmB,kBAAkB,EAAE;YAC1D,OAAO,IAAI,CAACiJ,aAAa,CAAC/E;QAC5B;QACA,OAAOA;IACT;IAEA,MAAc0C,YACZsC,QAAa,EACbC,QAAa,EACb1G,SAA0B,EACZ;QAEd,IAAI,OAAOyG,aAAa,YAAY,OAAOC,aAAa,UAAU;YAChE,OAAO;gBAAE,GAAGD,QAAQ;gBAAE,GAAGC,QAAQ;YAAC;QACpC;QACA,OAAOA;IACT;IAEQF,cAAc/E,KAAU,EAAO;QAErC,OAAOA;IACT;IAEQmC,YAAY3C,KAAkB,EAAEgF,SAAsC,EAAW;QAEvF,OAAO;IACT;IAEQpE,gBAAgBhC,IAAY,EAAU;QAE5C,KAAK,MAAM,CAACnB,IAAIsB,UAAU,IAAI,IAAI,CAAC3D,UAAU,CAAE;YAC7C,IAAI2D,UAAUH,IAAI,KAAKA,MAAM;gBAC3B,OAAOnB;YACT;QACF;QAGA,OAAOmC,MAAMC,IAAI,CAAC,IAAI,CAACzE,UAAU,CAACsK,IAAI,GAAG,CAAC,EAAE,IAAI;IAClD;IAEQ7E,iBAAiB/B,WAAmB,EAAU;QACpD,MAAMC,YAAY,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACR;QACtC,IAAI,CAACC,WAAW,OAAO;QAEvB,OAAOA,UAAUzD,OAAO,CAACqK,MAAM,CAAC,CAACC,MAAM5F;YACrC,OAAO4F,OAAOC,KAAKC,SAAS,CAAC9F,OAAOoE,MAAM;QAC5C,GAAG;IACL;IAEQnE,kBAAkBU,OAAe,EAAU;QACjD,KAAK,MAAM,CAAC7B,aAAaC,UAAU,IAAI,IAAI,CAAC3D,UAAU,CAAE;YACtD,IAAI2D,UAAUzD,OAAO,CAACyK,IAAI,CAAC,CAACrD,IAAMA,EAAEjF,EAAE,KAAKkD,UAAU;gBACnD,OAAO7B;YACT;QACF;QACA,OAAO;IACT;IAEQ+C,YAAYlB,OAAe,EAAEX,KAAkB,EAAQ;QAC7D,IAAI,IAAI,CAACzE,KAAK,CAACqK,IAAI,IAAI,IAAI,CAACzK,MAAM,CAACwB,SAAS,EAAE;YAC5C,IAAI,CAACqJ,UAAU;QACjB;QAEA,IAAI,CAACzK,KAAK,CAAC0C,GAAG,CAAC+B,MAAMO,GAAG,EAAE;YACxBP,OAAO;gBAAE,GAAGA,KAAK;YAAC;YAClBiG,QAAQnI,KAAK4C,GAAG,KAAK,IAAI,CAACvF,MAAM,CAACyB,QAAQ;QAC3C;IACF;IAEQ0F,eAAe/B,GAAW,EAAiD;QACjF,OAAO,IAAI,CAAChF,KAAK,CAAC+D,GAAG,CAACiB,QAAQ;IAChC;IAEQgC,aAAaF,MAA8C,EAAW;QAC5E,OAAOA,OAAO4D,MAAM,GAAGnI,KAAK4C,GAAG;IACjC;IAEQ0C,gBAAgB7C,GAAW,EAAQ;QACzC,IAAI,CAAChF,KAAK,CAAC4E,MAAM,CAACI;IACpB;IAEQyF,aAAmB;QAEzB,MAAM1K,UAAUsE,MAAMC,IAAI,CAAC,IAAI,CAACtE,KAAK,CAACD,OAAO;QAC7CA,QAAQoI,IAAI,CAAC,CAACC,GAAGC,IAAMD,CAAC,CAAC,EAAE,CAACsC,MAAM,GAAGrC,CAAC,CAAC,EAAE,CAACqC,MAAM;QAEhD,MAAMC,WAAW5K,QAAQ+I,KAAK,CAAC,GAAG8B,KAAKC,KAAK,CAAC,IAAI,CAACjL,MAAM,CAACwB,SAAS,GAAG;QACrEuJ,SAASG,OAAO,CAAC,CAAC,CAAC9F,IAAI,GAAK,IAAI,CAAChF,KAAK,CAAC4E,MAAM,CAACI;IAChD;IAEA,MAAcO,gBAAgBhC,WAAmB,EAAiB;QAChE,MAAMC,YAAY,IAAI,CAAC3D,UAAU,CAACkE,GAAG,CAACR;QACtC,IAAI,CAACC,WAAW;QAGhB,MAAMzD,UAAUyD,UAAUzD,OAAO,CAACoI,IAAI,CAAC,CAACC,GAAGC,IAAMD,EAAErC,SAAS,CAACE,OAAO,KAAKoC,EAAEtC,SAAS,CAACE,OAAO;QAE5F,MAAM0E,WAAW5K,QAAQ+I,KAAK,CAAC,GAAG8B,KAAKC,KAAK,CAAC9K,QAAQ8I,MAAM,GAAG;QAC9D,KAAK,MAAMpE,SAASkG,SAAU;YAC5B,MAAM,IAAI,CAAChG,WAAW,CAACF,MAAMvC,EAAE;QACjC;IACF;IAEQ+F,aAAaxD,KAAkB,EAAEsD,KAAkB,EAAW;QACpE,IAAIA,MAAM1E,IAAI,IAAIoB,MAAMpB,IAAI,KAAK0E,MAAM1E,IAAI,EAAE,OAAO;QACpD,IAAI0E,MAAMrC,KAAK,IAAIjB,MAAMiB,KAAK,CAACxD,EAAE,KAAK6F,MAAMrC,KAAK,CAACxD,EAAE,EAAE,OAAO;QAC7D,IAAI6F,MAAMlC,WAAW,IAAIpB,MAAMoB,WAAW,KAAKkC,MAAMlC,WAAW,EAAE,OAAO;QACzE,IAAIkC,MAAMgD,YAAY,IAAItG,MAAMqB,SAAS,GAAGiC,MAAMgD,YAAY,EAAE,OAAO;QACvE,IAAIhD,MAAMiD,YAAY,IAAIvG,MAAMsB,SAAS,GAAGgC,MAAMiD,YAAY,EAAE,OAAO;QAEvE,IAAIjD,MAAMtC,IAAI,IAAIsC,MAAMtC,IAAI,CAACoD,MAAM,GAAG,GAAG;YACvC,MAAMoC,aAAalD,MAAMtC,IAAI,CAACyF,KAAK,CAAC,CAACC,MAAQ1G,MAAMgB,IAAI,CAAC2F,QAAQ,CAACD;YACjE,IAAI,CAACF,YAAY,OAAO;QAC1B;QAEA,OAAO;IACT;IAEQ1C,kBAAkB8C,GAAQ,EAAEC,IAAY,EAAO;QACrD,OAAOA,KAAKC,KAAK,CAAC,KAAKnB,MAAM,CAAC,CAACoB,SAASxG,MAAQwG,SAAS,CAACxG,IAAI,EAAEqG;IAClE;IAEQ9E,qBAAqBvE,MAAc,EAAQ;QACjD,MAAMwJ,UAAU,IAAI,CAAClL,WAAW,CAACyD,GAAG,CAAC/B,WAAW;QAChD,IAAI,CAAC1B,WAAW,CAACoC,GAAG,CAACV,QAAQwJ,UAAU;IACzC;IAEQ7E,aAAa8C,SAAiB,EAAEgC,QAAgB,EAAQ;QAC9D,MAAMD,UAAU,IAAI,CAAC/K,gBAAgB,CAACsD,GAAG,CAAC0F,cAAc;YAAEiC,OAAO;YAAGC,WAAW;QAAE;QACjFH,QAAQE,KAAK;QACbF,QAAQG,SAAS,IAAIF;QACrB,IAAI,CAAChL,gBAAgB,CAACiC,GAAG,CAAC+G,WAAW+B;IACvC;IAEQlK,uBAAyC;QAC/C,OAAO;YACLsK,cAAc;YACdC,WAAW;YACXC,gBAAgB;YAChBC,WAAW;YACXC,mBAAmB;YACnBrC,gBAAgB;gBACdsC,SAAS;gBACTrC,WAAW;gBACXC,QAAQ;YACV;YACAqC,aAAa;gBACXC,aAAa;gBACbC,cAAc;gBACdC,aAAa;gBACbC,YAAY;YACd;YACAC,aAAa;gBACXC,aAAa;gBACbC,WAAW;gBACXC,cAAc;YAChB;QACF;IACF;IAEQpD,mBAAyB;QAC/B,IAAI,CAAC9I,UAAU,CAACoL,YAAY,GAAG,IAAI,CAAC7L,OAAO,CAACsK,IAAI;QAChD,IAAI,CAAC7J,UAAU,CAACsL,cAAc,GAAG,IAAI,CAACjM,UAAU,CAACwK,IAAI;QACrD,IAAI,CAAC7J,UAAU,CAACuL,SAAS,GAAG,IAAI,CAAC9L,KAAK,CAACoK,IAAI;QAG3C,MAAMsC,cAAc,IAAI,CAAClM,gBAAgB,CAACsD,GAAG,CAAC,eAAe;YAAE2H,OAAO;YAAGC,WAAW;QAAE;QACtF,MAAMiB,eAAe,IAAI,CAACnM,gBAAgB,CAACsD,GAAG,CAAC,YAAY;YAAE2H,OAAO;YAAGC,WAAW;QAAE;QAEpF,IAAI,CAACnL,UAAU,CAAC0L,WAAW,CAACC,WAAW,GACrCQ,YAAYjB,KAAK,GAAG,IAAIiB,YAAYhB,SAAS,GAAGgB,YAAYjB,KAAK,GAAG;QACtE,IAAI,CAAClL,UAAU,CAAC0L,WAAW,CAACE,YAAY,GACtCQ,aAAalB,KAAK,GAAG,IAAIkB,aAAajB,SAAS,GAAGiB,aAAalB,KAAK,GAAG;IAC3E;IAIA,MAAchF,eAAejC,KAAkB,EAAiB,CAEhE;IAEA,MAAcR,sBAAsBT,SAA0B,EAAiB,CAE/E;IAEA,MAAcsB,sBAAsBvB,WAAmB,EAAiB,CAExE;IAEA,MAAcqE,gBAAgBnD,KAAkB,EAAiB,CAEjE;IAEA,MAAcqD,kBAAkB1C,OAAe,EAAiB,CAEhE;IAEA,MAAcoC,mBAAmBxC,GAAW,EAAE1B,OAAY,EAA+B;QAEvF,OAAO;IACT;IAEA,MAAcgE,kBAAkB7C,KAAkB,EAAwB;QAExE,OAAOA;IACT;IAEA,MAAc2E,gBAA+B,CAE7C;IAEA,MAAcC,4BAA2C,CAEzD;IAEA,MAAcK,qBAAqBD,SAAwB,EAAiB,CAE5E;IAEA,MAAcxG,gCAA+C,CAE7D;IAEA,MAAcJ,oBAAmC,CAEjD;IAEA,MAAcK,cAA6B,CAE3C;IAEQxB,kBAAkBD,IAAS,EAAQ,CAE3C;IAEQE,iBAAiBF,IAAS,EAAQ,CAE1C;IAEQG,eAAeH,IAAS,EAAQ,CAExC;IAEQI,eAAeJ,IAAS,EAAQ,CAExC;IAIAoL,gBAAkC;QAChC,IAAI,CAACvD,gBAAgB;QACrB,OAAO;YAAE,GAAG,IAAI,CAAC9I,UAAU;QAAC;IAC9B;IAEAsM,gBAAmC;QACjC,OAAOzI,MAAMC,IAAI,CAAC,IAAI,CAACzE,UAAU,CAAC0E,MAAM;IAC1C;IAEAwI,WAAyB;QACvB,OAAO1I,MAAMC,IAAI,CAAC,IAAI,CAACrE,KAAK,CAACsE,MAAM;IACrC;IAEA,MAAMyI,SAA0B;QAE9B,MAAMA,SAAS;YACbjD,WAAW,IAAIxH;YACf1C,YAAYwE,MAAMC,IAAI,CAAC,IAAI,CAACzE,UAAU,CAAC0E,MAAM;YAC7CxE,SAASsE,MAAMC,IAAI,CAAC,IAAI,CAACvE,OAAO,CAACwE,MAAM;YACvC0I,UAAU;gBACR9G,SAAS;gBACTnE,QAAQ,IAAI,CAAC9B,WAAW;gBACxBN,QAAQ,IAAI,CAACA,MAAM;YACrB;QACF;QAEA,OAAO0K,KAAKC,SAAS,CAACyC;IACxB;IAEA,MAAME,QAAQC,UAAkB,EAAiB;QAE/C,MAAMH,SAAS1C,KAAK8C,KAAK,CAACD;QAG1B,IAAI,CAACtN,UAAU,CAACsD,KAAK;QACrB,IAAI,CAACpD,OAAO,CAACoD,KAAK;QAClB,IAAI,CAACnD,KAAK,CAACmD,KAAK;QAGhB,KAAK,MAAMK,aAAawJ,OAAOnN,UAAU,CAAE;YACzC,IAAI,CAACA,UAAU,CAAC6C,GAAG,CAACc,UAAUtB,EAAE,EAAEsB;QACpC;QAGA,KAAK,MAAMiB,SAASuI,OAAOjN,OAAO,CAAE;YAClC,IAAI,CAACA,OAAO,CAAC2C,GAAG,CAAC+B,MAAMvC,EAAE,EAAEuC;QAC7B;QAEA,IAAI,CAAC/E,MAAM,CAACqC,IAAI,CAAC,wBAAwB;YACvClC,YAAYmN,OAAOnN,UAAU,CAACgJ,MAAM;YACpC9I,SAASiN,OAAOjN,OAAO,CAAC8I,MAAM;QAChC;IACF;IAEA,MAAM1F,QAAuB;QAC3B,IAAI,CAACtD,UAAU,CAACsD,KAAK;QACrB,IAAI,CAACpD,OAAO,CAACoD,KAAK;QAClB,IAAI,CAACnD,KAAK,CAACmD,KAAK;QAChB,IAAI,CAAChD,SAAS,GAAG,EAAE;QACnB,IAAI,CAACK,UAAU,GAAG,IAAI,CAACc,oBAAoB;QAE3C,IAAI,CAAC5B,MAAM,CAACqC,IAAI,CAAC;QACjB,IAAI,CAACe,IAAI,CAAC;IACZ;AACF"}