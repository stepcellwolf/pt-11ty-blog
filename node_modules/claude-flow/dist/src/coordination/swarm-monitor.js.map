{"version":3,"sources":["../../../src/coordination/swarm-monitor.ts"],"sourcesContent":["import { EventEmitter } from 'node:events';\nimport * as os from 'node:os';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\nimport { Logger } from '../core/logger.js';\nimport { performance } from 'node:perf_hooks';\n\ninterface AgentMetrics {\n  id: string;\n  name: string;\n  status: 'idle' | 'running' | 'completed' | 'failed' | 'stalled';\n  currentTask?: string;\n  startTime?: number;\n  endTime?: number;\n  duration?: number;\n  cpuUsage?: number;\n  memoryUsage?: number;\n  taskCount: number;\n  successCount: number;\n  failureCount: number;\n  averageTaskDuration: number;\n  lastActivity: number;\n  outputSize?: number;\n  errorRate: number;\n}\n\ninterface SystemMetrics {\n  timestamp: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  totalMemory: number;\n  freeMemory: number;\n  loadAverage: number[];\n  activeAgents: number;\n  totalTasks: number;\n  completedTasks: number;\n  failedTasks: number;\n  pendingTasks: number;\n  averageTaskDuration: number;\n  throughput: number; // tasks per minute\n}\n\ninterface Alert {\n  id: string;\n  timestamp: number;\n  level: 'info' | 'warning' | 'error' | 'critical';\n  type:\n    | 'agent_failure'\n    | 'high_cpu'\n    | 'high_memory'\n    | 'stalled_agent'\n    | 'low_throughput'\n    | 'error_rate';\n  message: string;\n  details?: any;\n}\n\ninterface MonitoringConfig {\n  updateInterval: number; // milliseconds\n  metricsRetention: number; // hours\n  cpuThreshold: number; // percentage\n  memoryThreshold: number; // percentage\n  stallTimeout: number; // milliseconds\n  errorRateThreshold: number; // percentage\n  throughputThreshold: number; // tasks per minute\n  enableAlerts: boolean;\n  enableHistory: boolean;\n  historyPath?: string;\n}\n\nexport class SwarmMonitor extends EventEmitter {\n  private logger: Logger;\n  private config: MonitoringConfig;\n  private agentMetrics: Map<string, AgentMetrics> = new Map();\n  private systemMetrics: SystemMetrics[] = [];\n  private alerts: Alert[] = [];\n  private monitoringInterval?: NodeJS.Timeout;\n  private startTime: number;\n  private taskStartTimes: Map<string, number> = new Map();\n  private taskCompletionTimes: number[] = [];\n  private lastThroughputCheck: number;\n  private tasksInLastMinute: number = 0;\n\n  constructor(config?: Partial<MonitoringConfig>) {\n    super();\n    this.logger = new Logger('SwarmMonitor');\n    this.config = {\n      updateInterval: 1000, // 1 second\n      metricsRetention: 24, // 24 hours\n      cpuThreshold: 80, // 80%\n      memoryThreshold: 85, // 85%\n      stallTimeout: 300000, // 5 minutes\n      errorRateThreshold: 10, // 10%\n      throughputThreshold: 1, // 1 task per minute minimum\n      enableAlerts: true,\n      enableHistory: true,\n      historyPath: './monitoring/history',\n      ...config,\n    };\n    this.startTime = Date.now();\n    this.lastThroughputCheck = Date.now();\n  }\n\n  async start(): Promise<void> {\n    this.logger.info('Starting swarm monitoring...');\n\n    // Create history directory if needed\n    if (this.config.enableHistory && this.config.historyPath) {\n      await fs.mkdir(this.config.historyPath, { recursive: true });\n    }\n\n    // Start periodic monitoring\n    this.monitoringInterval = setInterval(() => {\n      this.collectMetrics();\n    }, this.config.updateInterval);\n\n    // Start initial collection\n    await this.collectMetrics();\n  }\n\n  stop(): void {\n    this.logger.info('Stopping swarm monitoring...');\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = undefined;\n    }\n  }\n\n  // Agent registration and tracking\n  registerAgent(agentId: string, name: string): void {\n    this.agentMetrics.set(agentId, {\n      id: agentId,\n      name,\n      status: 'idle',\n      taskCount: 0,\n      successCount: 0,\n      failureCount: 0,\n      averageTaskDuration: 0,\n      lastActivity: Date.now(),\n      errorRate: 0,\n    });\n    this.logger.debug(`Registered agent: ${name} (${agentId})`);\n  }\n\n  unregisterAgent(agentId: string): void {\n    const metrics = this.agentMetrics.get(agentId);\n    if (metrics) {\n      this.logger.debug(`Unregistered agent: ${metrics.name} (${agentId})`);\n      this.agentMetrics.delete(agentId);\n    }\n  }\n\n  // Task tracking\n  taskStarted(agentId: string, taskId: string, taskDescription?: string): void {\n    const metrics = this.agentMetrics.get(agentId);\n    if (metrics) {\n      metrics.status = 'running';\n      metrics.currentTask = taskDescription || taskId;\n      metrics.startTime = Date.now();\n      metrics.lastActivity = Date.now();\n      metrics.taskCount++;\n      this.taskStartTimes.set(taskId, Date.now());\n      this.emit('task:started', { agentId, taskId, taskDescription });\n    }\n  }\n\n  taskCompleted(agentId: string, taskId: string, outputSize?: number): void {\n    const metrics = this.agentMetrics.get(agentId);\n    const startTime = this.taskStartTimes.get(taskId);\n\n    if (metrics && startTime) {\n      const duration = Date.now() - startTime;\n      metrics.status = 'completed';\n      metrics.endTime = Date.now();\n      metrics.duration = duration;\n      metrics.lastActivity = Date.now();\n      metrics.successCount++;\n      metrics.outputSize = outputSize;\n\n      // Update average duration\n      const totalDuration = metrics.averageTaskDuration * (metrics.successCount - 1) + duration;\n      metrics.averageTaskDuration = totalDuration / metrics.successCount;\n\n      // Update error rate\n      metrics.errorRate = (metrics.failureCount / metrics.taskCount) * 100;\n\n      // Track for throughput calculation\n      this.taskCompletionTimes.push(Date.now());\n      this.tasksInLastMinute++;\n\n      this.taskStartTimes.delete(taskId);\n      this.emit('task:completed', { agentId, taskId, duration, outputSize });\n    }\n  }\n\n  taskFailed(agentId: string, taskId: string, error: string): void {\n    const metrics = this.agentMetrics.get(agentId);\n    const startTime = this.taskStartTimes.get(taskId);\n\n    if (metrics) {\n      const duration = startTime ? Date.now() - startTime : 0;\n      metrics.status = 'failed';\n      metrics.endTime = Date.now();\n      metrics.duration = duration;\n      metrics.lastActivity = Date.now();\n      metrics.failureCount++;\n\n      // Update error rate\n      metrics.errorRate = (metrics.failureCount / metrics.taskCount) * 100;\n\n      this.taskStartTimes.delete(taskId);\n      this.emit('task:failed', { agentId, taskId, error, duration });\n\n      // Check error rate threshold\n      if (metrics.errorRate > this.config.errorRateThreshold) {\n        this.createAlert(\n          'error_rate',\n          'critical',\n          `Agent ${metrics.name} has high error rate: ${metrics.errorRate.toFixed(1)}%`,\n        );\n      }\n    }\n  }\n\n  // Metrics collection\n  private async collectMetrics(): Promise<void> {\n    try {\n      // Collect system metrics\n      const cpuUsage = this.getCPUUsage();\n      const memInfo = this.getMemoryInfo();\n      const loadAvg = os.loadavg();\n\n      // Calculate throughput\n      const now = Date.now();\n      const minuteAgo = now - 60000;\n      this.taskCompletionTimes = this.taskCompletionTimes.filter((time) => time > minuteAgo);\n      const throughput = this.taskCompletionTimes.length;\n\n      // Calculate task statistics\n      let totalTasks = 0;\n      let completedTasks = 0;\n      let failedTasks = 0;\n      let activeAgents = 0;\n      let totalDuration = 0;\n      let durationCount = 0;\n\n      // Check for stalled agents\n      for (const [agentId, metrics] of this.agentMetrics) {\n        if (metrics.status === 'running') {\n          activeAgents++;\n\n          // Check for stalled agent\n          const stallTime = now - metrics.lastActivity;\n          if (stallTime > this.config.stallTimeout) {\n            metrics.status = 'stalled';\n            this.createAlert(\n              'stalled_agent',\n              'warning',\n              `Agent ${metrics.name} appears to be stalled (${Math.round(stallTime / 1000)}s inactive)`,\n            );\n          }\n        }\n\n        totalTasks += metrics.taskCount;\n        completedTasks += metrics.successCount;\n        failedTasks += metrics.failureCount;\n\n        if (metrics.averageTaskDuration > 0) {\n          totalDuration += metrics.averageTaskDuration * metrics.successCount;\n          durationCount += metrics.successCount;\n        }\n      }\n\n      const avgDuration = durationCount > 0 ? totalDuration / durationCount : 0;\n      const pendingTasks = totalTasks - completedTasks - failedTasks;\n\n      // Create system metrics\n      const systemMetrics: SystemMetrics = {\n        timestamp: now,\n        cpuUsage,\n        memoryUsage: memInfo.usagePercent,\n        totalMemory: memInfo.total,\n        freeMemory: memInfo.free,\n        loadAverage: loadAvg,\n        activeAgents,\n        totalTasks,\n        completedTasks,\n        failedTasks,\n        pendingTasks,\n        averageTaskDuration: avgDuration,\n        throughput,\n      };\n\n      this.systemMetrics.push(systemMetrics);\n\n      // Check system thresholds\n      if (this.config.enableAlerts) {\n        this.checkThresholds(systemMetrics);\n      }\n\n      // Clean old metrics\n      this.cleanOldMetrics();\n\n      // Save history if enabled\n      if (this.config.enableHistory) {\n        await this.saveHistory(systemMetrics);\n      }\n\n      // Emit metrics update\n      this.emit('metrics:updated', {\n        system: systemMetrics,\n        agents: Array.from(this.agentMetrics.values()),\n      });\n    } catch (error) {\n      this.logger.error('Error collecting metrics:', error);\n    }\n  }\n\n  private getCPUUsage(): number {\n    const cpus = os.cpus();\n    let totalIdle = 0;\n    let totalTick = 0;\n\n    cpus.forEach((cpu) => {\n      for (const type in cpu.times) {\n        totalTick += cpu.times[type as keyof typeof cpu.times];\n      }\n      totalIdle += cpu.times.idle;\n    });\n\n    return 100 - Math.floor((totalIdle / totalTick) * 100);\n  }\n\n  private getMemoryInfo(): { total: number; free: number; used: number; usagePercent: number } {\n    const total = os.totalmem();\n    const free = os.freemem();\n    const used = total - free;\n    const usagePercent = (used / total) * 100;\n\n    return { total, free, used, usagePercent };\n  }\n\n  private checkThresholds(metrics: SystemMetrics): void {\n    // CPU threshold\n    if (metrics.cpuUsage > this.config.cpuThreshold) {\n      this.createAlert('high_cpu', 'warning', `High CPU usage detected: ${metrics.cpuUsage}%`);\n    }\n\n    // Memory threshold\n    if (metrics.memoryUsage > this.config.memoryThreshold) {\n      this.createAlert(\n        'high_memory',\n        'warning',\n        `High memory usage detected: ${metrics.memoryUsage.toFixed(1)}%`,\n      );\n    }\n\n    // Throughput threshold\n    if (metrics.activeAgents > 0 && metrics.throughput < this.config.throughputThreshold) {\n      this.createAlert(\n        'low_throughput',\n        'warning',\n        `Low throughput detected: ${metrics.throughput} tasks/min`,\n      );\n    }\n  }\n\n  private createAlert(\n    type: Alert['type'],\n    level: Alert['level'],\n    message: string,\n    details?: any,\n  ): void {\n    const alert: Alert = {\n      id: `${type}_${Date.now()}`,\n      timestamp: Date.now(),\n      level,\n      type,\n      message,\n      details,\n    };\n\n    this.alerts.push(alert);\n    this.emit('alert', alert);\n    this.logger[level](message);\n  }\n\n  private cleanOldMetrics(): void {\n    const retentionTime = this.config.metricsRetention * 60 * 60 * 1000;\n    const cutoff = Date.now() - retentionTime;\n\n    this.systemMetrics = this.systemMetrics.filter((m) => m.timestamp > cutoff);\n    this.alerts = this.alerts.filter((a) => a.timestamp > cutoff);\n  }\n\n  private async saveHistory(metrics: SystemMetrics): Promise<void> {\n    if (!this.config.historyPath) return;\n\n    try {\n      const date = new Date();\n      const filename = `metrics_${date.toISOString().split('T')[0]}.jsonl`;\n      const filepath = path.join(this.config.historyPath, filename);\n\n      const line =\n        JSON.stringify({\n          ...metrics,\n          agents: Array.from(this.agentMetrics.values()),\n        }) + '\\n';\n\n      await fs.appendFile(filepath, line);\n    } catch (error) {\n      this.logger.error('Error saving history:', error);\n    }\n  }\n\n  // Getters for current state\n  getSystemMetrics(): SystemMetrics | undefined {\n    return this.systemMetrics[this.systemMetrics.length - 1];\n  }\n\n  getAgentMetrics(agentId?: string): AgentMetrics | AgentMetrics[] | undefined {\n    if (agentId) {\n      return this.agentMetrics.get(agentId);\n    }\n    return Array.from(this.agentMetrics.values());\n  }\n\n  getAlerts(since?: number): Alert[] {\n    if (since) {\n      return this.alerts.filter((a) => a.timestamp > since);\n    }\n    return this.alerts;\n  }\n\n  getHistoricalMetrics(hours: number = 1): SystemMetrics[] {\n    const since = Date.now() - hours * 60 * 60 * 1000;\n    return this.systemMetrics.filter((m) => m.timestamp > since);\n  }\n\n  // Summary statistics\n  getSummary(): {\n    uptime: number;\n    totalAgents: number;\n    activeAgents: number;\n    totalTasks: number;\n    completedTasks: number;\n    failedTasks: number;\n    successRate: number;\n    averageDuration: number;\n    currentThroughput: number;\n    alerts: number;\n  } {\n    const current = this.getSystemMetrics();\n    const uptime = Date.now() - this.startTime;\n    const totalAgents = this.agentMetrics.size;\n    const activeAgents = current?.activeAgents || 0;\n    const totalTasks = current?.totalTasks || 0;\n    const completedTasks = current?.completedTasks || 0;\n    const failedTasks = current?.failedTasks || 0;\n    const successRate = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;\n    const averageDuration = current?.averageTaskDuration || 0;\n    const currentThroughput = current?.throughput || 0;\n    const alerts = this.alerts.filter((a) => a.timestamp > Date.now() - 3600000).length; // Last hour\n\n    return {\n      uptime,\n      totalAgents,\n      activeAgents,\n      totalTasks,\n      completedTasks,\n      failedTasks,\n      successRate,\n      averageDuration,\n      currentThroughput,\n      alerts,\n    };\n  }\n\n  // Export monitoring data\n  async exportMetrics(filepath: string): Promise<void> {\n    const data = {\n      summary: this.getSummary(),\n      systemMetrics: this.systemMetrics,\n      agentMetrics: Array.from(this.agentMetrics.values()),\n      alerts: this.alerts,\n      exported: new Date().toISOString(),\n    };\n\n    await fs.writeFile(filepath, JSON.stringify(data, null, 2));\n    this.logger.info(`Exported metrics to ${filepath}`);\n  }\n}\n\n// Export types for external use\nexport type { AgentMetrics, SystemMetrics, Alert, MonitoringConfig };\n"],"names":["EventEmitter","os","fs","path","Logger","SwarmMonitor","logger","config","agentMetrics","Map","systemMetrics","alerts","monitoringInterval","startTime","taskStartTimes","taskCompletionTimes","lastThroughputCheck","tasksInLastMinute","updateInterval","metricsRetention","cpuThreshold","memoryThreshold","stallTimeout","errorRateThreshold","throughputThreshold","enableAlerts","enableHistory","historyPath","Date","now","start","info","mkdir","recursive","setInterval","collectMetrics","stop","clearInterval","undefined","registerAgent","agentId","name","set","id","status","taskCount","successCount","failureCount","averageTaskDuration","lastActivity","errorRate","debug","unregisterAgent","metrics","get","delete","taskStarted","taskId","taskDescription","currentTask","emit","taskCompleted","outputSize","duration","endTime","totalDuration","push","taskFailed","error","createAlert","toFixed","cpuUsage","getCPUUsage","memInfo","getMemoryInfo","loadAvg","loadavg","minuteAgo","filter","time","throughput","length","totalTasks","completedTasks","failedTasks","activeAgents","durationCount","stallTime","Math","round","avgDuration","pendingTasks","timestamp","memoryUsage","usagePercent","totalMemory","total","freeMemory","free","loadAverage","checkThresholds","cleanOldMetrics","saveHistory","system","agents","Array","from","values","cpus","totalIdle","totalTick","forEach","cpu","type","times","idle","floor","totalmem","freemem","used","level","message","details","alert","retentionTime","cutoff","m","a","date","filename","toISOString","split","filepath","join","line","JSON","stringify","appendFile","getSystemMetrics","getAgentMetrics","getAlerts","since","getHistoricalMetrics","hours","getSummary","current","uptime","totalAgents","size","successRate","averageDuration","currentThroughput","exportMetrics","data","summary","exported","writeFile"],"mappings":"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"}