{"version":3,"sources":["../../../src/coordination/load-balancer.ts"],"sourcesContent":["import {\n  getErrorMessage,\n  hasAgentLoad,\n  hasAgentTask,\n  hasWorkStealingData,\n} from '../utils/type-guards.js';\n/**\n * Advanced load balancing and work stealing implementation\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  AgentId,\n  AgentState,\n  TaskDefinition,\n  TaskId,\n  LoadBalancingStrategy,\n} from '../swarm/types.js';\nimport { WorkStealingCoordinator } from './work-stealing.js';\n\nexport interface LoadBalancerConfig {\n  strategy: LoadBalancingStrategy;\n  enableWorkStealing: boolean;\n  stealThreshold: number;\n  maxStealBatch: number;\n  rebalanceInterval: number;\n  loadSamplingInterval: number;\n  affinityWeight: number;\n  performanceWeight: number;\n  loadWeight: number;\n  latencyWeight: number;\n  queueDepthThreshold: number;\n  adaptiveThresholds: boolean;\n  predictiveEnabled: boolean;\n  debugMode: boolean;\n}\n\nexport interface AgentLoad {\n  agentId: string;\n  queueDepth: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  taskCount: number;\n  averageResponseTime: number;\n  throughput: number;\n  lastUpdated: Date;\n  capacity: number;\n  utilization: number;\n  efficiency: number;\n  affinityScore: number;\n}\n\nexport interface LoadBalancingDecision {\n  selectedAgent: AgentId;\n  reason: string;\n  confidence: number;\n  alternatives: Array<{\n    agent: AgentId;\n    score: number;\n    reason: string;\n  }>;\n  loadBefore: Record<string, number>;\n  predictedLoadAfter: Record<string, number>;\n  timestamp: Date;\n}\n\nexport interface WorkStealingOperation {\n  id: string;\n  sourceAgent: AgentId;\n  targetAgent: AgentId;\n  tasks: TaskId[];\n  reason: string;\n  status: 'planned' | 'executing' | 'completed' | 'failed';\n  startTime: Date;\n  endTime?: Date;\n  metrics: {\n    tasksStolen: number;\n    loadReduction: number;\n    latencyImprovement: number;\n  };\n}\n\nexport interface LoadPrediction {\n  agentId: string;\n  currentLoad: number;\n  predictedLoad: number;\n  confidence: number;\n  timeHorizon: number;\n  factors: Record<string, number>;\n}\n\n/**\n * Advanced load balancing system with work stealing and predictive capabilities\n */\nexport class LoadBalancer extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: LoadBalancerConfig;\n  private workStealer: WorkStealingCoordinator;\n\n  // Load tracking\n  private agentLoads = new Map<string, AgentLoad>();\n  private loadHistory = new Map<string, Array<{ timestamp: Date; load: number }>>();\n  private taskQueues = new Map<string, TaskDefinition[]>();\n\n  // Monitoring and statistics\n  private loadSamplingInterval?: NodeJS.Timeout;\n  private rebalanceInterval?: NodeJS.Timeout;\n  private decisions: LoadBalancingDecision[] = [];\n  private stealOperations = new Map<string, WorkStealingOperation>();\n\n  // Predictive modeling\n  private loadPredictors = new Map<string, LoadPredictor>();\n  private performanceBaselines = new Map<string, PerformanceBaseline>();\n\n  constructor(config: Partial<LoadBalancerConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      strategy: 'hybrid',\n      enableWorkStealing: true,\n      stealThreshold: 3,\n      maxStealBatch: 5,\n      rebalanceInterval: 10000,\n      loadSamplingInterval: 5000,\n      affinityWeight: 0.3,\n      performanceWeight: 0.3,\n      loadWeight: 0.25,\n      latencyWeight: 0.15,\n      queueDepthThreshold: 10,\n      adaptiveThresholds: true,\n      predictiveEnabled: true,\n      debugMode: false,\n      ...config,\n    };\n\n    this.workStealer = new WorkStealingCoordinator(\n      {\n        enabled: this.config.enableWorkStealing,\n        stealThreshold: this.config.stealThreshold,\n        maxStealBatch: this.config.maxStealBatch,\n        stealInterval: this.config.rebalanceInterval,\n      },\n      this.eventBus,\n      this.logger,\n    );\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('agent:load-update', (data) => {\n      if (hasAgentLoad(data)) {\n        this.updateAgentLoad(data.agentId, data.load);\n      }\n    });\n\n    this.eventBus.on('task:queued', (data) => {\n      if (hasAgentTask(data)) {\n        this.updateTaskQueue(data.agentId, data.task, 'add');\n      }\n    });\n\n    this.eventBus.on('task:started', (data) => {\n      if (hasAgentTask(data)) {\n        this.updateTaskQueue(data.agentId, data.task, 'remove');\n      }\n    });\n\n    this.eventBus.on('workstealing:request', (data) => {\n      if (hasWorkStealingData(data)) {\n        this.executeWorkStealing(data.sourceAgent, data.targetAgent, data.taskCount);\n      }\n    });\n\n    this.eventBus.on('agent:performance-update', (data) => {\n      this.updatePerformanceBaseline(data.agentId, data.metrics);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing load balancer', {\n      strategy: this.config.strategy,\n      workStealing: this.config.enableWorkStealing,\n      predictive: this.config.predictiveEnabled,\n    });\n\n    // Initialize work stealer\n    await this.workStealer.initialize();\n\n    // Start monitoring\n    this.startLoadSampling();\n    this.startRebalancing();\n\n    this.emit('loadbalancer:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down load balancer');\n\n    // Stop monitoring\n    if (this.loadSamplingInterval) clearInterval(this.loadSamplingInterval);\n    if (this.rebalanceInterval) clearInterval(this.rebalanceInterval);\n\n    // Shutdown work stealer\n    await this.workStealer.shutdown();\n\n    this.emit('loadbalancer:shutdown');\n  }\n\n  // === AGENT SELECTION ===\n\n  async selectAgent(\n    task: TaskDefinition,\n    availableAgents: AgentState[],\n    constraints?: {\n      excludeAgents?: AgentId[];\n      preferredAgents?: AgentId[];\n      maxLoad?: number;\n      requireCapabilities?: string[];\n    },\n  ): Promise<LoadBalancingDecision> {\n    const startTime = Date.now();\n\n    try {\n      // Filter agents based on constraints\n      const candidates = this.filterAgentsByConstraints(availableAgents, task, constraints);\n\n      if (candidates.length === 0) {\n        throw new Error('No suitable agents available for task');\n      }\n\n      // Apply selection strategy\n      const decision = await this.applySelectionStrategy(task, candidates);\n\n      // Record decision\n      this.decisions.push(decision);\n\n      // Keep only last 1000 decisions\n      if (this.decisions.length > 1000) {\n        this.decisions.shift();\n      }\n\n      const selectionTime = Date.now() - startTime;\n      this.logger.debug('Agent selected', {\n        taskId: task.id.id,\n        selectedAgent: decision.selectedAgent.id,\n        reason: decision.reason,\n        confidence: decision.confidence,\n        selectionTime,\n      });\n\n      this.emit('agent:selected', { task, decision, selectionTime });\n\n      return decision;\n    } catch (error) {\n      this.logger.error('Agent selection failed', { taskId: task.id.id, error });\n      throw error;\n    }\n  }\n\n  private filterAgentsByConstraints(\n    agents: AgentState[],\n    task: TaskDefinition,\n    constraints?: {\n      excludeAgents?: AgentId[];\n      preferredAgents?: AgentId[];\n      maxLoad?: number;\n      requireCapabilities?: string[];\n    },\n  ): AgentState[] {\n    return agents.filter((agent) => {\n      // Exclude specific agents\n      if (constraints?.excludeAgents?.some((excluded) => excluded.id === agent.id.id)) {\n        return false;\n      }\n\n      // Check maximum load\n      const load = this.agentLoads.get(agent.id.id);\n      if (constraints?.maxLoad && load && load.utilization > constraints.maxLoad) {\n        return false;\n      }\n\n      // Check required capabilities\n      if (constraints?.requireCapabilities) {\n        const hasAllCapabilities = constraints.requireCapabilities.every(\n          (cap) =>\n            agent.capabilities.domains.includes(cap) ||\n            agent.capabilities.tools.includes(cap) ||\n            agent.capabilities.languages.includes(cap),\n        );\n        if (!hasAllCapabilities) {\n          return false;\n        }\n      }\n\n      // Check task type compatibility\n      if (!this.isAgentCompatible(agent, task)) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  private async applySelectionStrategy(\n    task: TaskDefinition,\n    candidates: AgentState[],\n  ): Promise<LoadBalancingDecision> {\n    const scores = new Map<string, number>();\n    const reasons = new Map<string, string>();\n    const loadBefore: Record<string, number> = {};\n    const predictedLoadAfter: Record<string, number> = {};\n\n    // Calculate scores for each candidate\n    for (const agent of candidates) {\n      const agentId = agent.id.id;\n      const load = this.agentLoads.get(agentId) || this.createDefaultLoad(agentId);\n\n      loadBefore[agentId] = load.utilization;\n\n      let score = 0;\n      const scoreComponents: string[] = [];\n\n      switch (this.config.strategy) {\n        case 'load-based':\n          score = this.calculateLoadScore(agent, load);\n          scoreComponents.push(`load:${score.toFixed(2)}`);\n          break;\n\n        case 'performance-based':\n          score = this.calculatePerformanceScore(agent, load);\n          scoreComponents.push(`perf:${score.toFixed(2)}`);\n          break;\n\n        case 'capability-based':\n          score = this.calculateCapabilityScore(agent, task);\n          scoreComponents.push(`cap:${score.toFixed(2)}`);\n          break;\n\n        case 'affinity-based':\n          score = this.calculateAffinityScore(agent, task);\n          scoreComponents.push(`affinity:${score.toFixed(2)}`);\n          break;\n\n        case 'cost-based':\n          score = this.calculateCostScore(agent, task);\n          scoreComponents.push(`cost:${score.toFixed(2)}`);\n          break;\n\n        case 'hybrid':\n          score = this.calculateHybridScore(agent, task, load);\n          scoreComponents.push(`hybrid:${score.toFixed(2)}`);\n          break;\n\n        default:\n          score = Math.random(); // Random fallback\n          scoreComponents.push(`random:${score.toFixed(2)}`);\n      }\n\n      // Apply predictive modeling if enabled\n      if (this.config.predictiveEnabled) {\n        const prediction = this.predictLoad(agentId, task);\n        const predictiveScore = this.calculatePredictiveScore(prediction);\n        score = score * 0.7 + predictiveScore * 0.3;\n        predictedLoadAfter[agentId] = prediction.predictedLoad;\n        scoreComponents.push(`pred:${predictiveScore.toFixed(2)}`);\n      } else {\n        predictedLoadAfter[agentId] = load.utilization + 0.1; // Simple estimate\n      }\n\n      scores.set(agentId, score);\n      reasons.set(agentId, scoreComponents.join(','));\n    }\n\n    // Select agent with highest score\n    const sortedCandidates = candidates.sort((a, b) => {\n      const scoreA = scores.get(a.id.id) || 0;\n      const scoreB = scores.get(b.id.id) || 0;\n      return scoreB - scoreA;\n    });\n\n    const selectedAgent = sortedCandidates[0];\n    const selectedScore = scores.get(selectedAgent.id.id) || 0;\n    const selectedReason = reasons.get(selectedAgent.id.id) || 'unknown';\n\n    // Build alternatives list\n    const alternatives = sortedCandidates.slice(1, 4).map((agent) => ({\n      agent: agent.id,\n      score: scores.get(agent.id.id) || 0,\n      reason: reasons.get(agent.id.id) || 'unknown',\n    }));\n\n    // Calculate confidence based on score gap\n    const secondBestScore = alternatives.length > 0 ? alternatives[0].score : 0;\n    const confidence = Math.min(1, selectedScore - secondBestScore + 0.5);\n\n    return {\n      selectedAgent: selectedAgent.id,\n      reason: selectedReason,\n      confidence,\n      alternatives,\n      loadBefore,\n      predictedLoadAfter,\n      timestamp: new Date(),\n    };\n  }\n\n  // === SCORING ALGORITHMS ===\n\n  private calculateLoadScore(agent: AgentState, load: AgentLoad): number {\n    // Higher score for lower load (inverted)\n    return 1 - load.utilization;\n  }\n\n  private calculatePerformanceScore(agent: AgentState, load: AgentLoad): number {\n    const baseline = this.performanceBaselines.get(agent.id.id);\n    if (!baseline) return 0.5;\n\n    // Combine throughput, efficiency, and response time\n    const throughputScore = Math.min(1, load.throughput / baseline.expectedThroughput);\n    const efficiencyScore = load.efficiency;\n    const responseScore = Math.min(1, baseline.expectedResponseTime / load.averageResponseTime);\n\n    return (throughputScore + efficiencyScore + responseScore) / 3;\n  }\n\n  private calculateCapabilityScore(agent: AgentState, task: TaskDefinition): number {\n    let score = 0;\n    let totalChecks = 0;\n\n    // Check language compatibility\n    if (task.requirements.capabilities.includes('coding')) {\n      const hasLanguage = agent.capabilities.languages.some(\n        (lang) => task.context.language === lang,\n      );\n      score += hasLanguage ? 1 : 0;\n      totalChecks++;\n    }\n\n    // Check framework compatibility\n    if (task.context.framework) {\n      const hasFramework = agent.capabilities.frameworks.includes(task.context.framework);\n      score += hasFramework ? 1 : 0;\n      totalChecks++;\n    }\n\n    // Check domain expertise\n    const domainMatch = agent.capabilities.domains.some(\n      (domain) => task.type.includes(domain) || task.requirements.capabilities.includes(domain),\n    );\n    score += domainMatch ? 1 : 0;\n    totalChecks++;\n\n    // Check required tools\n    const hasTools = task.requirements.tools.every((tool) =>\n      agent.capabilities.tools.includes(tool),\n    );\n    score += hasTools ? 1 : 0;\n    totalChecks++;\n\n    return totalChecks > 0 ? score / totalChecks : 0;\n  }\n\n  private calculateAffinityScore(agent: AgentState, task: TaskDefinition): number {\n    const load = this.agentLoads.get(agent.id.id);\n    if (!load) return 0;\n\n    return load.affinityScore || 0.5;\n  }\n\n  private calculateCostScore(agent: AgentState, task: TaskDefinition): number {\n    // Simple cost model - could be enhanced\n    const baseCost = 1.0;\n    const performanceFactor = agent.capabilities.speed;\n    const reliabilityFactor = agent.capabilities.reliability;\n\n    const cost = baseCost / (performanceFactor * reliabilityFactor);\n    return Math.max(0, 1 - cost / 2); // Normalize and invert\n  }\n\n  private calculateHybridScore(agent: AgentState, task: TaskDefinition, load: AgentLoad): number {\n    const loadScore = this.calculateLoadScore(agent, load);\n    const performanceScore = this.calculatePerformanceScore(agent, load);\n    const capabilityScore = this.calculateCapabilityScore(agent, task);\n    const affinityScore = this.calculateAffinityScore(agent, task);\n\n    return (\n      loadScore * this.config.loadWeight +\n      performanceScore * this.config.performanceWeight +\n      capabilityScore * this.config.affinityWeight +\n      affinityScore * this.config.latencyWeight\n    );\n  }\n\n  private calculatePredictiveScore(prediction: LoadPrediction): number {\n    // Higher score for lower predicted load\n    const loadScore = 1 - prediction.predictedLoad;\n    const confidenceBonus = prediction.confidence * 0.2;\n    return Math.min(1, loadScore + confidenceBonus);\n  }\n\n  // === WORK STEALING ===\n\n  private async executeWorkStealing(\n    sourceAgentId: string,\n    targetAgentId: string,\n    taskCount: number,\n  ): Promise<void> {\n    const operationId = `steal-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n\n    const operation: WorkStealingOperation = {\n      id: operationId,\n      sourceAgent: { id: sourceAgentId, swarmId: 'default', type: 'coordinator', instance: 1 },\n      targetAgent: { id: targetAgentId, swarmId: 'default', type: 'coordinator', instance: 1 },\n      tasks: [],\n      reason: 'load_imbalance',\n      status: 'planned',\n      startTime: new Date(),\n      metrics: {\n        tasksStolen: 0,\n        loadReduction: 0,\n        latencyImprovement: 0,\n      },\n    };\n\n    this.stealOperations.set(operationId, operation);\n\n    try {\n      operation.status = 'executing';\n\n      // Get source queue\n      const sourceQueue = this.taskQueues.get(sourceAgentId) || [];\n      if (sourceQueue.length === 0) {\n        throw new Error('Source agent has no tasks to steal');\n      }\n\n      // Select tasks to steal (lowest priority first)\n      const tasksToSteal = sourceQueue\n        .sort((a, b) => (a.priority === b.priority ? 0 : a.priority === 'low' ? -1 : 1))\n        .slice(0, Math.min(taskCount, this.config.maxStealBatch));\n\n      // Remove tasks from source\n      for (const task of tasksToSteal) {\n        this.updateTaskQueue(sourceAgentId, task, 'remove');\n        this.updateTaskQueue(targetAgentId, task, 'add');\n        operation.tasks.push(task.id);\n      }\n\n      // Update metrics\n      operation.metrics.tasksStolen = tasksToSteal.length;\n      operation.metrics.loadReduction = this.calculateLoadReduction(\n        sourceAgentId,\n        tasksToSteal.length,\n      );\n      operation.status = 'completed';\n      operation.endTime = new Date();\n\n      this.logger.info('Work stealing completed', {\n        operationId,\n        sourceAgent: sourceAgentId,\n        targetAgent: targetAgentId,\n        tasksStolen: operation.metrics.tasksStolen,\n      });\n\n      this.emit('workstealing:completed', { operation });\n    } catch (error) {\n      operation.status = 'failed';\n      operation.endTime = new Date();\n\n      this.logger.error('Work stealing failed', {\n        operationId,\n        sourceAgent: sourceAgentId,\n        targetAgent: targetAgentId,\n        error,\n      });\n\n      this.emit('workstealing:failed', { operation, error });\n    }\n  }\n\n  // === LOAD MONITORING ===\n\n  private startLoadSampling(): void {\n    this.loadSamplingInterval = setInterval(() => {\n      this.sampleAgentLoads();\n    }, this.config.loadSamplingInterval);\n\n    this.logger.info('Started load sampling', {\n      interval: this.config.loadSamplingInterval,\n    });\n  }\n\n  private startRebalancing(): void {\n    this.rebalanceInterval = setInterval(() => {\n      this.performRebalancing();\n    }, this.config.rebalanceInterval);\n\n    this.logger.info('Started rebalancing', {\n      interval: this.config.rebalanceInterval,\n    });\n  }\n\n  private async sampleAgentLoads(): Promise<void> {\n    // Sample current loads from all agents\n    for (const [agentId, load] of this.agentLoads) {\n      // Update load history\n      const history = this.loadHistory.get(agentId) || [];\n      history.push({ timestamp: new Date(), load: load.utilization });\n\n      // Keep only last 100 samples\n      if (history.length > 100) {\n        history.shift();\n      }\n\n      this.loadHistory.set(agentId, history);\n\n      // Update predictive models\n      if (this.config.predictiveEnabled) {\n        this.updateLoadPredictor(agentId, load);\n      }\n    }\n  }\n\n  private async performRebalancing(): Promise<void> {\n    if (!this.config.enableWorkStealing) return;\n\n    try {\n      // Find overloaded and underloaded agents\n      const loads = Array.from(this.agentLoads.entries());\n      const overloaded = loads.filter(\n        ([_, load]) => load.utilization > 0.8 && load.queueDepth > this.config.queueDepthThreshold,\n      );\n      const underloaded = loads.filter(\n        ([_, load]) => load.utilization < 0.3 && load.queueDepth < 2,\n      );\n\n      if (overloaded.length === 0 || underloaded.length === 0) {\n        return; // No rebalancing needed\n      }\n\n      // Perform work stealing\n      for (const [overloadedId, overloadedLoad] of overloaded) {\n        // Find best underloaded target\n        const target = underloaded.sort((a, b) => a[1].utilization - b[1].utilization)[0];\n\n        if (target) {\n          const [targetId] = target;\n          const tasksToSteal = Math.min(\n            Math.floor((overloadedLoad.queueDepth - targetId.length) / 2),\n            this.config.maxStealBatch,\n          );\n\n          if (tasksToSteal > 0) {\n            await this.executeWorkStealing(overloadedId, targetId, tasksToSteal);\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('Rebalancing failed', error);\n    }\n  }\n\n  // === PREDICTIVE MODELING ===\n\n  private predictLoad(agentId: string, task: TaskDefinition): LoadPrediction {\n    const predictor = this.loadPredictors.get(agentId);\n    const currentLoad = this.agentLoads.get(agentId)?.utilization || 0;\n\n    if (!predictor) {\n      // Simple fallback prediction\n      return {\n        agentId,\n        currentLoad,\n        predictedLoad: Math.min(1, currentLoad + 0.1),\n        confidence: 0.5,\n        timeHorizon: 60000, // 1 minute\n        factors: { task_complexity: 0.1 },\n      };\n    }\n\n    return predictor.predict(task);\n  }\n\n  private updateLoadPredictor(agentId: string, load: AgentLoad): void {\n    let predictor = this.loadPredictors.get(agentId);\n    if (!predictor) {\n      predictor = new LoadPredictor(agentId);\n      this.loadPredictors.set(agentId, predictor);\n    }\n\n    predictor.update(load);\n  }\n\n  // === UTILITY METHODS ===\n\n  private isAgentCompatible(agent: AgentState, task: TaskDefinition): boolean {\n    // Check basic type compatibility\n    const typeCompatible = this.checkTypeCompatibility(agent.type, task.type);\n    if (!typeCompatible) return false;\n\n    // Check capability requirements\n    const hasRequiredCapabilities = task.requirements.capabilities.every((cap) => {\n      return (\n        agent.capabilities.domains.includes(cap) ||\n        agent.capabilities.tools.includes(cap) ||\n        agent.capabilities.languages.includes(cap)\n      );\n    });\n\n    return hasRequiredCapabilities;\n  }\n\n  private checkTypeCompatibility(agentType: string, taskType: string): boolean {\n    const compatibilityMap: Record<string, string[]> = {\n      researcher: ['research', 'analysis', 'documentation'],\n      coder: ['coding', 'testing', 'integration', 'deployment'],\n      analyst: ['analysis', 'validation', 'review'],\n      reviewer: ['review', 'validation', 'documentation'],\n      coordinator: ['coordination', 'monitoring', 'management'],\n      tester: ['testing', 'validation', 'integration'],\n      specialist: ['custom', 'optimization', 'maintenance'],\n    };\n\n    const compatibleTypes = compatibilityMap[agentType] || [];\n    return compatibleTypes.some((type) => taskType.includes(type));\n  }\n\n  private updateAgentLoad(agentId: string, loadData: Partial<AgentLoad>): void {\n    const existing = this.agentLoads.get(agentId) || this.createDefaultLoad(agentId);\n    const updated = { ...existing, ...loadData, lastUpdated: new Date() };\n\n    // Recalculate utilization\n    updated.utilization = this.calculateUtilization(updated);\n\n    this.agentLoads.set(agentId, updated);\n  }\n\n  private updateTaskQueue(\n    agentId: string,\n    task: TaskDefinition,\n    operation: 'add' | 'remove',\n  ): void {\n    const queue = this.taskQueues.get(agentId) || [];\n\n    if (operation === 'add') {\n      queue.push(task);\n    } else {\n      const index = queue.findIndex((t) => t.id.id === task.id.id);\n      if (index >= 0) {\n        queue.splice(index, 1);\n      }\n    }\n\n    this.taskQueues.set(agentId, queue);\n\n    // Update agent load\n    this.updateAgentLoad(agentId, {\n      queueDepth: queue.length,\n      taskCount: queue.length,\n    });\n  }\n\n  private updatePerformanceBaseline(agentId: string, metrics: any): void {\n    const baseline = this.performanceBaselines.get(agentId) || {\n      expectedThroughput: 10,\n      expectedResponseTime: 5000,\n      expectedQuality: 0.8,\n    };\n\n    // Update baseline with exponential moving average\n    const alpha = 0.1;\n    baseline.expectedThroughput =\n      baseline.expectedThroughput * (1 - alpha) + metrics.throughput * alpha;\n    baseline.expectedResponseTime =\n      baseline.expectedResponseTime * (1 - alpha) + metrics.responseTime * alpha;\n\n    this.performanceBaselines.set(agentId, baseline);\n  }\n\n  private calculateUtilization(load: AgentLoad): number {\n    // Combine multiple factors to calculate overall utilization\n    const queueFactor = Math.min(1, load.queueDepth / 10);\n    const cpuFactor = load.cpuUsage / 100;\n    const memoryFactor = load.memoryUsage / 100;\n    const taskFactor = Math.min(1, load.taskCount / load.capacity);\n\n    return (queueFactor + cpuFactor + memoryFactor + taskFactor) / 4;\n  }\n\n  private calculateLoadReduction(agentId: string, tasksRemoved: number): number {\n    const load = this.agentLoads.get(agentId);\n    if (!load) return 0;\n\n    const oldUtilization = load.utilization;\n    const newUtilization = this.calculateUtilization({\n      ...load,\n      queueDepth: load.queueDepth - tasksRemoved,\n      taskCount: load.taskCount - tasksRemoved,\n    });\n\n    return oldUtilization - newUtilization;\n  }\n\n  private createDefaultLoad(agentId: string): AgentLoad {\n    return {\n      agentId,\n      queueDepth: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      taskCount: 0,\n      averageResponseTime: 5000,\n      throughput: 0,\n      lastUpdated: new Date(),\n      capacity: 10,\n      utilization: 0,\n      efficiency: 1.0,\n      affinityScore: 0.5,\n    };\n  }\n\n  // === PUBLIC API ===\n\n  getAgentLoad(agentId: string): AgentLoad | undefined {\n    return this.agentLoads.get(agentId);\n  }\n\n  getAllLoads(): AgentLoad[] {\n    return Array.from(this.agentLoads.values());\n  }\n\n  getRecentDecisions(limit: number = 10): LoadBalancingDecision[] {\n    return this.decisions.slice(-limit);\n  }\n\n  getStealOperations(): WorkStealingOperation[] {\n    return Array.from(this.stealOperations.values());\n  }\n\n  getLoadStatistics(): {\n    totalAgents: number;\n    averageUtilization: number;\n    overloadedAgents: number;\n    underloadedAgents: number;\n    totalStealOperations: number;\n    successfulSteals: number;\n  } {\n    const loads = Array.from(this.agentLoads.values());\n    const avgUtilization =\n      loads.reduce((sum, load) => sum + load.utilization, 0) / loads.length || 0;\n    const overloaded = loads.filter((load) => load.utilization > 0.8).length;\n    const underloaded = loads.filter((load) => load.utilization < 0.3).length;\n    const successfulSteals = Array.from(this.stealOperations.values()).filter(\n      (op) => op.status === 'completed',\n    ).length;\n\n    return {\n      totalAgents: loads.length,\n      averageUtilization: avgUtilization,\n      overloadedAgents: overloaded,\n      underloadedAgents: underloaded,\n      totalStealOperations: this.stealOperations.size,\n      successfulSteals,\n    };\n  }\n\n  // Force rebalance\n  async forceRebalance(): Promise<void> {\n    await this.performRebalancing();\n  }\n}\n\n// === HELPER CLASSES ===\n\nclass LoadPredictor {\n  private agentId: string;\n  private history: Array<{ timestamp: Date; load: number }> = [];\n  private model: SimpleLinearModel;\n\n  constructor(agentId: string) {\n    this.agentId = agentId;\n    this.model = new SimpleLinearModel();\n  }\n\n  update(load: AgentLoad): void {\n    this.history.push({ timestamp: new Date(), load: load.utilization });\n\n    // Keep only last 50 samples\n    if (this.history.length > 50) {\n      this.history.shift();\n    }\n\n    // Update model if we have enough data\n    if (this.history.length >= 10) {\n      this.model.train(this.history);\n    }\n  }\n\n  predict(task: TaskDefinition): LoadPrediction {\n    const currentLoad = this.history.length > 0 ? this.history[this.history.length - 1].load : 0;\n\n    let predictedLoad = currentLoad;\n    let confidence = 0.5;\n\n    if (this.history.length >= 10) {\n      const prediction = this.model.predict();\n      predictedLoad = prediction.value;\n      confidence = prediction.confidence;\n    }\n\n    // Adjust for task complexity\n    const taskComplexity = this.estimateTaskComplexity(task);\n    predictedLoad = Math.min(1, predictedLoad + taskComplexity * 0.1);\n\n    return {\n      agentId: this.agentId,\n      currentLoad,\n      predictedLoad,\n      confidence,\n      timeHorizon: 60000,\n      factors: {\n        task_complexity: taskComplexity,\n        historical_trend: predictedLoad - currentLoad,\n      },\n    };\n  }\n\n  private estimateTaskComplexity(task: TaskDefinition): number {\n    // Simple complexity estimation\n    let complexity = 0.5;\n\n    if (task.requirements.estimatedDuration && task.requirements.estimatedDuration > 300000) {\n      complexity += 0.3; // Long-running task\n    }\n\n    if (task.requirements.memoryRequired && task.requirements.memoryRequired > 512 * 1024 * 1024) {\n      complexity += 0.2; // Memory-intensive\n    }\n\n    if (task.requirements.capabilities.length > 3) {\n      complexity += 0.2; // Requires multiple capabilities\n    }\n\n    return Math.min(1, complexity);\n  }\n}\n\nclass SimpleLinearModel {\n  private slope = 0;\n  private intercept = 0;\n  private r2 = 0;\n\n  train(data: Array<{ timestamp: Date; load: number }>): void {\n    if (data.length < 2) return;\n\n    // Convert timestamps to relative time points\n    const startTime = data[0].timestamp.getTime();\n    const points = data.map((point, index) => ({\n      x: index, // Use index as x for simplicity\n      y: point.load,\n    }));\n\n    // Calculate linear regression\n    const n = points.length;\n    const sumX = points.reduce((sum, p) => sum + p.x, 0);\n    const sumY = points.reduce((sum, p) => sum + p.y, 0);\n    const sumXY = points.reduce((sum, p) => sum + p.x * p.y, 0);\n    const sumXX = points.reduce((sum, p) => sum + p.x * p.x, 0);\n\n    this.slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    this.intercept = (sumY - this.slope * sumX) / n;\n\n    // Calculate R²\n    const meanY = sumY / n;\n    const ssTotal = points.reduce((sum, p) => sum + Math.pow(p.y - meanY, 2), 0);\n    const ssRes = points.reduce((sum, p) => {\n      const predicted = this.slope * p.x + this.intercept;\n      return sum + Math.pow(p.y - predicted, 2);\n    }, 0);\n\n    this.r2 = 1 - ssRes / ssTotal;\n  }\n\n  predict(): { value: number; confidence: number } {\n    // Predict next value (x = n)\n    const nextValue = this.slope * 1 + this.intercept; // Predict 1 step ahead\n    const confidence = Math.max(0, this.r2); // Use R² as confidence\n\n    return {\n      value: Math.max(0, Math.min(1, nextValue)),\n      confidence,\n    };\n  }\n}\n\ninterface PerformanceBaseline {\n  expectedThroughput: number;\n  expectedResponseTime: number;\n  expectedQuality: number;\n}\n"],"names":["hasAgentLoad","hasAgentTask","hasWorkStealingData","EventEmitter","WorkStealingCoordinator","LoadBalancer","logger","eventBus","config","workStealer","agentLoads","Map","loadHistory","taskQueues","loadSamplingInterval","rebalanceInterval","decisions","stealOperations","loadPredictors","performanceBaselines","strategy","enableWorkStealing","stealThreshold","maxStealBatch","affinityWeight","performanceWeight","loadWeight","latencyWeight","queueDepthThreshold","adaptiveThresholds","predictiveEnabled","debugMode","enabled","stealInterval","setupEventHandlers","on","data","updateAgentLoad","agentId","load","updateTaskQueue","task","executeWorkStealing","sourceAgent","targetAgent","taskCount","updatePerformanceBaseline","metrics","initialize","info","workStealing","predictive","startLoadSampling","startRebalancing","emit","shutdown","clearInterval","selectAgent","availableAgents","constraints","startTime","Date","now","candidates","filterAgentsByConstraints","length","Error","decision","applySelectionStrategy","push","shift","selectionTime","debug","taskId","id","selectedAgent","reason","confidence","error","agents","filter","agent","excludeAgents","some","excluded","get","maxLoad","utilization","requireCapabilities","hasAllCapabilities","every","cap","capabilities","domains","includes","tools","languages","isAgentCompatible","scores","reasons","loadBefore","predictedLoadAfter","createDefaultLoad","score","scoreComponents","calculateLoadScore","toFixed","calculatePerformanceScore","calculateCapabilityScore","calculateAffinityScore","calculateCostScore","calculateHybridScore","Math","random","prediction","predictLoad","predictiveScore","calculatePredictiveScore","predictedLoad","set","join","sortedCandidates","sort","a","b","scoreA","scoreB","selectedScore","selectedReason","alternatives","slice","map","secondBestScore","min","timestamp","baseline","throughputScore","throughput","expectedThroughput","efficiencyScore","efficiency","responseScore","expectedResponseTime","averageResponseTime","totalChecks","requirements","hasLanguage","lang","context","language","framework","hasFramework","frameworks","domainMatch","domain","type","hasTools","tool","affinityScore","baseCost","performanceFactor","speed","reliabilityFactor","reliability","cost","max","loadScore","performanceScore","capabilityScore","confidenceBonus","sourceAgentId","targetAgentId","operationId","toString","operation","swarmId","instance","tasks","status","tasksStolen","loadReduction","latencyImprovement","sourceQueue","tasksToSteal","priority","calculateLoadReduction","endTime","setInterval","sampleAgentLoads","interval","performRebalancing","history","updateLoadPredictor","loads","Array","from","entries","overloaded","_","queueDepth","underloaded","overloadedId","overloadedLoad","target","targetId","floor","predictor","currentLoad","timeHorizon","factors","task_complexity","predict","LoadPredictor","update","typeCompatible","checkTypeCompatibility","hasRequiredCapabilities","agentType","taskType","compatibilityMap","researcher","coder","analyst","reviewer","coordinator","tester","specialist","compatibleTypes","loadData","existing","updated","lastUpdated","calculateUtilization","queue","index","findIndex","t","splice","expectedQuality","alpha","responseTime","queueFactor","cpuFactor","cpuUsage","memoryFactor","memoryUsage","taskFactor","capacity","tasksRemoved","oldUtilization","newUtilization","getAgentLoad","getAllLoads","values","getRecentDecisions","limit","getStealOperations","getLoadStatistics","avgUtilization","reduce","sum","successfulSteals","op","totalAgents","averageUtilization","overloadedAgents","underloadedAgents","totalStealOperations","size","forceRebalance","model","SimpleLinearModel","train","value","taskComplexity","estimateTaskComplexity","historical_trend","complexity","estimatedDuration","memoryRequired","slope","intercept","r2","getTime","points","point","x","y","n","sumX","p","sumY","sumXY","sumXX","meanY","ssTotal","pow","ssRes","predicted","nextValue"],"mappings":"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"}