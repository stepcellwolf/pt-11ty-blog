{"version":3,"sources":["../../../src/coordination/hive-orchestrator.ts"],"sourcesContent":["/**\n * Hive Mind Orchestrator - Advanced task coordination with consensus\n */\n\nimport { EventEmitter } from 'events';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface HiveTask {\n  id: string;\n  type: 'analysis' | 'design' | 'implementation' | 'testing' | 'documentation' | 'research';\n  description: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  dependencies: string[];\n  assignedTo?: string;\n  status: 'pending' | 'voting' | 'assigned' | 'executing' | 'reviewing' | 'completed' | 'failed';\n  votes: Map<string, { approve: boolean; confidence: number }>;\n  result?: any;\n  metrics?: {\n    startTime: number;\n    endTime?: number;\n    attempts: number;\n    quality?: number;\n  };\n}\n\nexport interface HiveDecision {\n  id: string;\n  type: 'task_assignment' | 'quality_check' | 'architecture' | 'consensus';\n  proposal: any;\n  votes: Map<string, boolean>;\n  result: 'approved' | 'rejected' | 'pending';\n  timestamp: number;\n}\n\nexport class HiveOrchestrator extends EventEmitter {\n  private tasks: Map<string, HiveTask> = new Map();\n  private decisions: Map<string, HiveDecision> = new Map();\n  private agentCapabilities: Map<string, Set<string>> = new Map();\n  private consensusThreshold: number;\n  private topology: string;\n\n  constructor(\n    options: {\n      consensusThreshold?: number;\n      topology?: 'hierarchical' | 'mesh' | 'ring' | 'star';\n    } = {},\n  ) {\n    super();\n    this.consensusThreshold = options.consensusThreshold || 0.6;\n    this.topology = options.topology || 'hierarchical';\n  }\n\n  /**\n   * Register agent capabilities for task matching\n   */\n  registerAgentCapabilities(agentId: string, capabilities: string[]) {\n    this.agentCapabilities.set(agentId, new Set(capabilities));\n    this.emit('agent:registered', { agentId, capabilities });\n  }\n\n  /**\n   * Decompose objective into coordinated tasks\n   */\n  async decomposeObjective(objective: string): Promise<HiveTask[]> {\n    const tasks: HiveTask[] = [];\n\n    // Analyze objective to determine task types\n    const needsResearch =\n      objective.toLowerCase().includes('research') || objective.toLowerCase().includes('analyze');\n    const needsDesign =\n      objective.toLowerCase().includes('build') ||\n      objective.toLowerCase().includes('create') ||\n      objective.toLowerCase().includes('develop');\n    const needsImplementation = needsDesign || objective.toLowerCase().includes('implement');\n\n    // Create task graph based on objective\n    if (needsResearch) {\n      tasks.push(\n        this.createTask(\n          'research',\n          `Research background and requirements for: ${objective}`,\n          'high',\n        ),\n      );\n    }\n\n    const analysisTask = this.createTask(\n      'analysis',\n      `Analyze requirements and constraints for: ${objective}`,\n      'critical',\n    );\n    tasks.push(analysisTask);\n\n    if (needsDesign) {\n      const designTask = this.createTask(\n        'design',\n        'Design system architecture and components',\n        'high',\n        [analysisTask.id],\n      );\n      tasks.push(designTask);\n\n      if (needsImplementation) {\n        const implTask = this.createTask('implementation', 'Implement core functionality', 'high', [\n          designTask.id,\n        ]);\n        tasks.push(implTask);\n\n        const testTask = this.createTask('testing', 'Test and validate implementation', 'high', [\n          implTask.id,\n        ]);\n        tasks.push(testTask);\n      }\n    }\n\n    // Always include documentation\n    const docTask = this.createTask(\n      'documentation',\n      'Document solution and decisions',\n      'medium',\n      tasks.filter((t) => t.type !== 'documentation').map((t) => t.id),\n    );\n    tasks.push(docTask);\n\n    // Apply topology-specific ordering\n    return this.applyTopologyOrdering(tasks);\n  }\n\n  /**\n   * Create a new task\n   */\n  private createTask(\n    type: HiveTask['type'],\n    description: string,\n    priority: HiveTask['priority'],\n    dependencies: string[] = [],\n  ): HiveTask {\n    const task: HiveTask = {\n      id: generateId('task'),\n      type,\n      description,\n      priority,\n      dependencies,\n      status: 'pending',\n      votes: new Map(),\n      metrics: {\n        startTime: Date.now(),\n        attempts: 0,\n      },\n    };\n\n    this.tasks.set(task.id, task);\n    this.emit('task:created', task);\n\n    return task;\n  }\n\n  /**\n   * Apply topology-specific task ordering\n   */\n  private applyTopologyOrdering(tasks: HiveTask[]): HiveTask[] {\n    switch (this.topology) {\n      case 'hierarchical':\n        // Priority-based ordering with dependency respect\n        return tasks.sort((a, b) => {\n          const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n          return priorityOrder[a.priority] - priorityOrder[b.priority];\n        });\n\n      case 'ring':\n        // Sequential ordering - each task depends on previous\n        for (let i = 1; i < tasks.length; i++) {\n          if (tasks[i].dependencies.length === 0) {\n            tasks[i].dependencies.push(tasks[i - 1].id);\n          }\n        }\n        return tasks;\n\n      case 'mesh':\n        // Parallel-friendly ordering - minimize dependencies\n        return tasks.sort((a, b) => a.dependencies.length - b.dependencies.length);\n\n      case 'star':\n        // Central coordination - all tasks report to analysis\n        const analysisTask = tasks.find((t) => t.type === 'analysis');\n        if (analysisTask) {\n          tasks.forEach((t) => {\n            if (t.id !== analysisTask.id && t.dependencies.length === 0) {\n              t.dependencies.push(analysisTask.id);\n            }\n          });\n        }\n        return tasks;\n\n      default:\n        return tasks;\n    }\n  }\n\n  /**\n   * Propose task assignment with voting\n   */\n  async proposeTaskAssignment(taskId: string, agentId: string): Promise<HiveDecision> {\n    const task = this.tasks.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} not found`);\n\n    const decision: HiveDecision = {\n      id: generateId('decision'),\n      type: 'task_assignment',\n      proposal: { taskId, agentId },\n      votes: new Map(),\n      result: 'pending',\n      timestamp: Date.now(),\n    };\n\n    this.decisions.set(decision.id, decision);\n    task.status = 'voting';\n\n    this.emit('decision:proposed', decision);\n\n    return decision;\n  }\n\n  /**\n   * Submit vote for a decision\n   */\n  submitVote(decisionId: string, agentId: string, vote: boolean) {\n    const decision = this.decisions.get(decisionId);\n    if (!decision) throw new Error(`Decision ${decisionId} not found`);\n\n    decision.votes.set(agentId, vote);\n\n    // Check if we have enough votes\n    const totalAgents = this.agentCapabilities.size;\n    const votesReceived = decision.votes.size;\n\n    if (votesReceived >= totalAgents * 0.8) {\n      // 80% participation required\n      this.evaluateDecision(decision);\n    }\n  }\n\n  /**\n   * Evaluate decision based on votes\n   */\n  private evaluateDecision(decision: HiveDecision) {\n    const approvals = Array.from(decision.votes.values()).filter((v) => v).length;\n    const totalVotes = decision.votes.size;\n    const approvalRate = approvals / totalVotes;\n\n    decision.result = approvalRate >= this.consensusThreshold ? 'approved' : 'rejected';\n\n    if (decision.result === 'approved' && decision.type === 'task_assignment') {\n      const { taskId, agentId } = decision.proposal;\n      const task = this.tasks.get(taskId);\n      if (task) {\n        task.assignedTo = agentId;\n        task.status = 'assigned';\n        this.emit('task:assigned', { task, agentId });\n      }\n    }\n\n    this.emit('decision:resolved', decision);\n  }\n\n  /**\n   * Get optimal agent for task based on capabilities\n   */\n  getOptimalAgent(taskId: string): string | null {\n    const task = this.tasks.get(taskId);\n    if (!task) return null;\n\n    let bestAgent: string | null = null;\n    let bestScore = 0;\n\n    for (const [agentId, capabilities] of this.agentCapabilities) {\n      const score = this.calculateAgentTaskScore(task, capabilities);\n      if (score > bestScore) {\n        bestScore = score;\n        bestAgent = agentId;\n      }\n    }\n\n    return bestAgent;\n  }\n\n  /**\n   * Calculate how well agent capabilities match task\n   */\n  private calculateAgentTaskScore(task: HiveTask, capabilities: Set<string>): number {\n    let score = 0;\n\n    // Type-specific scoring\n    switch (task.type) {\n      case 'research':\n        if (capabilities.has('research')) score += 5;\n        if (capabilities.has('analysis')) score += 3;\n        if (capabilities.has('exploration')) score += 2;\n        break;\n      case 'design':\n        if (capabilities.has('architecture')) score += 5;\n        if (capabilities.has('design')) score += 4;\n        if (capabilities.has('planning')) score += 3;\n        break;\n      case 'implementation':\n        if (capabilities.has('coding')) score += 5;\n        if (capabilities.has('implementation')) score += 4;\n        if (capabilities.has('building')) score += 3;\n        break;\n      case 'testing':\n        if (capabilities.has('testing')) score += 5;\n        if (capabilities.has('validation')) score += 4;\n        if (capabilities.has('quality')) score += 3;\n        break;\n      case 'documentation':\n        if (capabilities.has('documentation')) score += 5;\n        if (capabilities.has('writing')) score += 3;\n        break;\n    }\n\n    // General capabilities bonus\n    if (capabilities.has('analysis')) score += 1;\n    if (capabilities.has('optimization')) score += 1;\n\n    return score;\n  }\n\n  /**\n   * Update task status\n   */\n  updateTaskStatus(taskId: string, status: HiveTask['status'], result?: any) {\n    const task = this.tasks.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} not found`);\n\n    task.status = status;\n    if (result) task.result = result;\n    if (status === 'completed' && task.metrics) {\n      task.metrics.endTime = Date.now();\n    }\n\n    this.emit('task:updated', task);\n\n    // Check if we can start dependent tasks\n    if (status === 'completed') {\n      this.checkDependentTasks(taskId);\n    }\n  }\n\n  /**\n   * Check and update dependent tasks\n   */\n  private checkDependentTasks(completedTaskId: string) {\n    for (const task of this.tasks.values()) {\n      if (task.status === 'pending' && task.dependencies.includes(completedTaskId)) {\n        // Check if all dependencies are completed\n        const allDepsCompleted = task.dependencies.every((depId) => {\n          const depTask = this.tasks.get(depId);\n          return depTask && depTask.status === 'completed';\n        });\n\n        if (allDepsCompleted) {\n          this.emit('task:ready', task);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate swarm performance metrics\n   */\n  getPerformanceMetrics() {\n    const tasks = Array.from(this.tasks.values());\n    const completed = tasks.filter((t) => t.status === 'completed');\n    const failed = tasks.filter((t) => t.status === 'failed');\n\n    const avgExecutionTime =\n      completed.length > 0\n        ? completed.reduce(\n            (sum, t) => sum + (t.metrics?.endTime || 0) - (t.metrics?.startTime || 0),\n            0,\n          ) / completed.length\n        : 0;\n\n    const decisions = Array.from(this.decisions.values());\n    const approvedDecisions = decisions.filter((d) => d.result === 'approved');\n\n    return {\n      totalTasks: tasks.length,\n      completedTasks: completed.length,\n      failedTasks: failed.length,\n      pendingTasks: tasks.filter((t) => t.status === 'pending').length,\n      executingTasks: tasks.filter((t) => t.status === 'executing').length,\n      avgExecutionTime,\n      totalDecisions: decisions.length,\n      approvedDecisions: approvedDecisions.length,\n      consensusRate: decisions.length > 0 ? approvedDecisions.length / decisions.length : 0,\n      topology: this.topology,\n    };\n  }\n\n  /**\n   * Get task dependency graph\n   */\n  getTaskGraph() {\n    const nodes = Array.from(this.tasks.values()).map((task) => ({\n      id: task.id,\n      type: task.type,\n      status: task.status,\n      assignedTo: task.assignedTo,\n    }));\n\n    const edges = [];\n    for (const task of this.tasks.values()) {\n      for (const dep of task.dependencies) {\n        edges.push({ from: dep, to: task.id });\n      }\n    }\n\n    return { nodes, edges };\n  }\n}\n"],"names":["EventEmitter","generateId","HiveOrchestrator","tasks","Map","decisions","agentCapabilities","consensusThreshold","topology","options","registerAgentCapabilities","agentId","capabilities","set","Set","emit","decomposeObjective","objective","needsResearch","toLowerCase","includes","needsDesign","needsImplementation","push","createTask","analysisTask","designTask","id","implTask","testTask","docTask","filter","t","type","map","applyTopologyOrdering","description","priority","dependencies","task","status","votes","metrics","startTime","Date","now","attempts","sort","a","b","priorityOrder","critical","high","medium","low","i","length","find","forEach","proposeTaskAssignment","taskId","get","Error","decision","proposal","result","timestamp","submitVote","decisionId","vote","totalAgents","size","votesReceived","evaluateDecision","approvals","Array","from","values","v","totalVotes","approvalRate","assignedTo","getOptimalAgent","bestAgent","bestScore","score","calculateAgentTaskScore","has","updateTaskStatus","endTime","checkDependentTasks","completedTaskId","allDepsCompleted","every","depId","depTask","getPerformanceMetrics","completed","failed","avgExecutionTime","reduce","sum","approvedDecisions","d","totalTasks","completedTasks","failedTasks","pendingTasks","executingTasks","totalDecisions","consensusRate","getTaskGraph","nodes","edges","dep","to"],"mappings":"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"}