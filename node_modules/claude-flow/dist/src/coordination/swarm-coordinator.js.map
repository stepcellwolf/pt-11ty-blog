{"version":3,"sources":["../../../src/coordination/swarm-coordinator.ts"],"sourcesContent":["import { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { EventBus } from '../core/event-bus.js';\nimport { generateId } from '../utils/helpers.js';\nimport { SwarmMonitor } from './swarm-monitor.js';\nimport type { AdvancedTaskScheduler } from './advanced-scheduler.js';\nimport { MemoryManager } from '../memory/manager.js';\n\nexport interface SwarmAgent {\n  id: string;\n  name: string;\n  type: 'researcher' | 'coder' | 'analyst' | 'coordinator' | 'reviewer';\n  status: 'idle' | 'busy' | 'failed' | 'completed';\n  capabilities: string[];\n  currentTask?: SwarmTask;\n  processId?: number;\n  terminalId?: string;\n  metrics: {\n    tasksCompleted: number;\n    tasksFailed: number;\n    totalDuration: number;\n    lastActivity: Date;\n  };\n}\n\nexport interface SwarmTask {\n  id: string;\n  type: string;\n  description: string;\n  priority: number;\n  dependencies: string[];\n  assignedTo?: string;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  result?: any;\n  error?: string;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  retryCount: number;\n  maxRetries: number;\n  timeout?: number;\n}\n\nexport interface SwarmObjective {\n  id: string;\n  description: string;\n  strategy: 'auto' | 'research' | 'development' | 'analysis';\n  tasks: SwarmTask[];\n  status: 'planning' | 'executing' | 'completed' | 'failed';\n  createdAt: Date;\n  completedAt?: Date;\n}\n\nexport interface SwarmConfig {\n  maxAgents: number;\n  maxConcurrentTasks: number;\n  taskTimeout: number;\n  enableMonitoring: boolean;\n  enableWorkStealing: boolean;\n  enableCircuitBreaker: boolean;\n  memoryNamespace: string;\n  coordinationStrategy: 'centralized' | 'distributed' | 'hybrid';\n  backgroundTaskInterval: number;\n  healthCheckInterval: number;\n  maxRetries: number;\n  backoffMultiplier: number;\n}\n\nexport class SwarmCoordinator extends EventEmitter {\n  private logger: Logger;\n  private config: SwarmConfig;\n  private agents: Map<string, SwarmAgent>;\n  private objectives: Map<string, SwarmObjective>;\n  private tasks: Map<string, SwarmTask>;\n  private monitor?: SwarmMonitor;\n  private scheduler?: AdvancedTaskScheduler;\n  private memoryManager: MemoryManager;\n  private backgroundWorkers: Map<string, NodeJS.Timeout>;\n  private isRunning: boolean = false;\n  private workStealer?: any;\n  private circuitBreaker?: any;\n\n  constructor(config: Partial<SwarmConfig> = {}) {\n    super();\n    this.logger = new Logger('SwarmCoordinator');\n    this.config = {\n      maxAgents: 10,\n      maxConcurrentTasks: 5,\n      taskTimeout: 300000, // 5 minutes\n      enableMonitoring: true,\n      enableWorkStealing: true,\n      enableCircuitBreaker: true,\n      memoryNamespace: 'swarm',\n      coordinationStrategy: 'hybrid',\n      backgroundTaskInterval: 5000, // 5 seconds\n      healthCheckInterval: 10000, // 10 seconds\n      maxRetries: 3,\n      backoffMultiplier: 2,\n      ...config,\n    };\n\n    this.agents = new Map();\n    this.objectives = new Map();\n    this.tasks = new Map();\n    this.backgroundWorkers = new Map();\n\n    // Initialize memory manager\n    const eventBus = EventBus.getInstance();\n    this.memoryManager = new MemoryManager(\n      {\n        backend: 'sqlite',\n        namespace: this.config.memoryNamespace,\n        cacheSizeMB: 50,\n        syncOnExit: true,\n        maxEntries: 10000,\n        ttlMinutes: 60,\n      },\n      eventBus,\n      this.logger,\n    );\n\n    if (this.config.enableMonitoring) {\n      this.monitor = new SwarmMonitor({\n        updateInterval: 1000,\n        enableAlerts: true,\n        enableHistory: true,\n      });\n    }\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    // Monitor events\n    if (this.monitor) {\n      this.monitor.on('alert', (alert: any) => {\n        this.handleMonitorAlert(alert);\n      });\n    }\n\n    // Add custom event handlers for swarm coordination\n    this.on('task:completed', (data: any) => {\n      this.handleTaskCompleted(data.taskId, data.result);\n    });\n\n    this.on('task:failed', (data: any) => {\n      this.handleTaskFailed(data.taskId, data.error);\n    });\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      this.logger.warn('Swarm coordinator already running');\n      return;\n    }\n\n    this.logger.info('Starting swarm coordinator...');\n    this.isRunning = true;\n\n    // Start subsystems\n    await this.memoryManager.initialize();\n\n    if (this.monitor) {\n      await this.monitor.start();\n    }\n\n    // Start background workers\n    this.startBackgroundWorkers();\n\n    this.emit('coordinator:started');\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      return;\n    }\n\n    this.logger.info('Stopping swarm coordinator...');\n    this.isRunning = false;\n\n    // Stop background workers\n    this.stopBackgroundWorkers();\n\n    // Stop subsystems\n    await this.scheduler.shutdown();\n\n    if (this.monitor) {\n      this.monitor.stop();\n    }\n\n    this.emit('coordinator:stopped');\n  }\n\n  private startBackgroundWorkers(): void {\n    // Task processor worker\n    const taskProcessor = setInterval(() => {\n      this.processBackgroundTasks();\n    }, this.config.backgroundTaskInterval);\n    this.backgroundWorkers.set('taskProcessor', taskProcessor);\n\n    // Health check worker\n    const healthChecker = setInterval(() => {\n      this.performHealthChecks();\n    }, this.config.healthCheckInterval);\n    this.backgroundWorkers.set('healthChecker', healthChecker);\n\n    // Work stealing worker\n    if (this.workStealer) {\n      const workStealerWorker = setInterval(() => {\n        this.performWorkStealing();\n      }, this.config.backgroundTaskInterval);\n      this.backgroundWorkers.set('workStealer', workStealerWorker);\n    }\n\n    // Memory sync worker\n    const memorySync = setInterval(() => {\n      this.syncMemoryState();\n    }, this.config.backgroundTaskInterval * 2);\n    this.backgroundWorkers.set('memorySync', memorySync);\n  }\n\n  private stopBackgroundWorkers(): void {\n    for (const [name, worker] of this.backgroundWorkers) {\n      clearInterval(worker);\n      this.logger.debug(`Stopped background worker: ${name}`);\n    }\n    this.backgroundWorkers.clear();\n  }\n\n  async createObjective(\n    description: string,\n    strategy: SwarmObjective['strategy'] = 'auto',\n  ): Promise<string> {\n    const objectiveId = generateId('objective');\n    const objective: SwarmObjective = {\n      id: objectiveId,\n      description,\n      strategy,\n      tasks: [],\n      status: 'planning',\n      createdAt: new Date(),\n    };\n\n    this.objectives.set(objectiveId, objective);\n    this.logger.info(`Created objective: ${objectiveId} - ${description}`);\n\n    // Decompose objective into tasks\n    const tasks = await this.decomposeObjective(objective);\n    objective.tasks = tasks;\n\n    // Store in memory\n    await this.memoryManager.store({\n      id: `objective:${objectiveId}`,\n      agentId: 'swarm-coordinator',\n      type: 'objective',\n      content: JSON.stringify(objective),\n      namespace: this.config.memoryNamespace,\n      timestamp: new Date(),\n      metadata: {\n        type: 'objective',\n        strategy,\n        taskCount: tasks.length,\n      },\n    });\n\n    this.emit('objective:created', objective);\n    return objectiveId;\n  }\n\n  private async decomposeObjective(objective: SwarmObjective): Promise<SwarmTask[]> {\n    const tasks: SwarmTask[] = [];\n\n    switch (objective.strategy) {\n      case 'research':\n        tasks.push(\n          this.createTask('research', 'Gather information and research materials', 1),\n          this.createTask('analysis', 'Analyze research findings', 2, ['research']),\n          this.createTask('synthesis', 'Synthesize insights and create report', 3, ['analysis']),\n        );\n        break;\n\n      case 'development':\n        tasks.push(\n          this.createTask('planning', 'Plan architecture and design', 1),\n          this.createTask('implementation', 'Implement core functionality', 2, ['planning']),\n          this.createTask('testing', 'Test and validate implementation', 3, ['implementation']),\n          this.createTask('documentation', 'Create documentation', 3, ['implementation']),\n          this.createTask('review', 'Peer review and refinement', 4, ['testing', 'documentation']),\n        );\n        break;\n\n      case 'analysis':\n        tasks.push(\n          this.createTask('data-collection', 'Collect and prepare data', 1),\n          this.createTask('analysis', 'Perform detailed analysis', 2, ['data-collection']),\n          this.createTask('visualization', 'Create visualizations', 3, ['analysis']),\n          this.createTask('reporting', 'Generate final report', 4, ['analysis', 'visualization']),\n        );\n        break;\n\n      default: // auto\n        // Use AI to decompose based on objective description\n        tasks.push(\n          this.createTask('exploration', 'Explore and understand requirements', 1),\n          this.createTask('planning', 'Create execution plan', 2, ['exploration']),\n          this.createTask('execution', 'Execute main tasks', 3, ['planning']),\n          this.createTask('validation', 'Validate and test results', 4, ['execution']),\n          this.createTask('completion', 'Finalize and document', 5, ['validation']),\n        );\n    }\n\n    // Register tasks\n    tasks.forEach((task) => {\n      this.tasks.set(task.id, task);\n    });\n\n    return tasks;\n  }\n\n  private createTask(\n    type: string,\n    description: string,\n    priority: number,\n    dependencies: string[] = [],\n  ): SwarmTask {\n    return {\n      id: generateId('task'),\n      type,\n      description,\n      priority,\n      dependencies,\n      status: 'pending',\n      createdAt: new Date(),\n      retryCount: 0,\n      maxRetries: this.config.maxRetries,\n      timeout: this.config.taskTimeout,\n    };\n  }\n\n  async registerAgent(\n    name: string,\n    type: SwarmAgent['type'],\n    capabilities: string[] = [],\n  ): Promise<string> {\n    const agentId = generateId('agent');\n    const agent: SwarmAgent = {\n      id: agentId,\n      name,\n      type,\n      status: 'idle',\n      capabilities,\n      metrics: {\n        tasksCompleted: 0,\n        tasksFailed: 0,\n        totalDuration: 0,\n        lastActivity: new Date(),\n      },\n    };\n\n    this.agents.set(agentId, agent);\n\n    if (this.monitor) {\n      this.monitor.registerAgent(agentId, name);\n    }\n\n    // Register with work stealer if enabled\n    if (this.workStealer) {\n      this.workStealer.registerWorker(agentId, 1);\n    }\n\n    this.logger.info(`Registered agent: ${name} (${agentId}) - Type: ${type}`);\n    this.emit('agent:registered', agent);\n\n    return agentId;\n  }\n\n  async assignTask(taskId: string, agentId: string): Promise<void> {\n    const task = this.tasks.get(taskId);\n    const agent = this.agents.get(agentId);\n\n    if (!task || !agent) {\n      throw new Error('Task or agent not found');\n    }\n\n    if (agent.status !== 'idle') {\n      throw new Error('Agent is not available');\n    }\n\n    // Check circuit breaker\n    if (this.circuitBreaker && !this.circuitBreaker.canExecute(agentId)) {\n      throw new Error('Agent circuit breaker is open');\n    }\n\n    task.assignedTo = agentId;\n    task.status = 'running';\n    task.startedAt = new Date();\n\n    agent.status = 'busy';\n    agent.currentTask = task;\n\n    if (this.monitor) {\n      this.monitor.taskStarted(agentId, taskId, task.description);\n    }\n\n    this.logger.info(`Assigned task ${taskId} to agent ${agentId}`);\n    this.emit('task:assigned', { task, agent });\n\n    // Execute task in background\n    this.executeTask(task, agent);\n  }\n\n  private async executeTask(task: SwarmTask, agent: SwarmAgent): Promise<void> {\n    try {\n      // Simulate task execution\n      // In real implementation, this would spawn actual Claude instances\n      const result = await this.simulateTaskExecution(task, agent);\n\n      await this.handleTaskCompleted(task.id, result);\n    } catch (error) {\n      await this.handleTaskFailed(task.id, error);\n    }\n  }\n\n  private async simulateTaskExecution(task: SwarmTask, agent: SwarmAgent): Promise<any> {\n    // This is where we would actually spawn Claude processes\n    // For now, simulate with timeout\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Task timeout'));\n      }, task.timeout || this.config.taskTimeout);\n\n      // Simulate work\n      setTimeout(\n        () => {\n          clearTimeout(timeout);\n          resolve({\n            taskId: task.id,\n            agentId: agent.id,\n            result: `Completed ${task.type} task`,\n            timestamp: new Date(),\n          });\n        },\n        Math.random() * 5000 + 2000,\n      );\n    });\n  }\n\n  private async handleTaskCompleted(taskId: string, result: any): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) return;\n\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo) : null;\n\n    task.status = 'completed';\n    task.completedAt = new Date();\n    task.result = result;\n\n    if (agent) {\n      agent.status = 'idle';\n      agent.currentTask = undefined;\n      agent.metrics.tasksCompleted++;\n      agent.metrics.totalDuration += task.completedAt.getTime() - (task.startedAt?.getTime() || 0);\n      agent.metrics.lastActivity = new Date();\n\n      if (this.monitor) {\n        this.monitor.taskCompleted(agent.id, taskId);\n      }\n\n      if (this.circuitBreaker) {\n        this.circuitBreaker.recordSuccess(agent.id);\n      }\n    }\n\n    // Store result in memory\n    await this.memoryManager.store({\n      id: `task:${taskId}:result`,\n      agentId: agent?.id || 'unknown',\n      type: 'task-result',\n      content: JSON.stringify(result),\n      namespace: this.config.memoryNamespace,\n      timestamp: new Date(),\n      metadata: {\n        type: 'task-result',\n        taskType: task.type,\n        agentId: agent?.id,\n      },\n    });\n\n    this.logger.info(`Task ${taskId} completed successfully`);\n    this.emit('task:completed', { task, result });\n\n    // Check if objective is complete\n    this.checkObjectiveCompletion(task);\n  }\n\n  private async handleTaskFailed(taskId: string, error: any): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) return;\n\n    const agent = task.assignedTo ? this.agents.get(task.assignedTo) : null;\n\n    task.error = (error instanceof Error ? error.message : String(error)) || String(error);\n    task.retryCount++;\n\n    if (agent) {\n      agent.status = 'idle';\n      agent.currentTask = undefined;\n      agent.metrics.tasksFailed++;\n      agent.metrics.lastActivity = new Date();\n\n      if (this.monitor) {\n        this.monitor.taskFailed(agent.id, taskId, task.error);\n      }\n\n      if (this.circuitBreaker) {\n        this.circuitBreaker.recordFailure(agent.id);\n      }\n    }\n\n    // Retry logic\n    if (task.retryCount < task.maxRetries) {\n      task.status = 'pending';\n      task.assignedTo = undefined;\n      this.logger.warn(`Task ${taskId} failed, will retry (${task.retryCount}/${task.maxRetries})`);\n      this.emit('task:retry', { task, error });\n    } else {\n      task.status = 'failed';\n      task.completedAt = new Date();\n      this.logger.error(`Task ${taskId} failed after ${task.retryCount} retries`);\n      this.emit('task:failed', { task, error });\n    }\n  }\n\n  private checkObjectiveCompletion(completedTask: SwarmTask): void {\n    for (const [objectiveId, objective] of this.objectives) {\n      if (objective.status !== 'executing') continue;\n\n      const allTasksComplete = objective.tasks.every((task) => {\n        const t = this.tasks.get(task.id);\n        return t && (t.status === 'completed' || t.status === 'failed');\n      });\n\n      if (allTasksComplete) {\n        objective.status = 'completed';\n        objective.completedAt = new Date();\n        this.logger.info(`Objective ${objectiveId} completed`);\n        this.emit('objective:completed', objective);\n      }\n    }\n  }\n\n  private async processBackgroundTasks(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      // Process pending tasks\n      const pendingTasks = Array.from(this.tasks.values()).filter(\n        (t) => t.status === 'pending' && this.areDependenciesMet(t),\n      );\n\n      // Get available agents\n      const availableAgents = Array.from(this.agents.values()).filter((a) => a.status === 'idle');\n\n      // Assign tasks to agents\n      for (const task of pendingTasks) {\n        if (availableAgents.length === 0) break;\n\n        const agent = this.selectBestAgent(task, availableAgents);\n        if (agent) {\n          try {\n            await this.assignTask(task.id, agent.id);\n            availableAgents.splice(availableAgents.indexOf(agent), 1);\n          } catch (error) {\n            this.logger.error(`Failed to assign task ${task.id}:`, error);\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error processing background tasks:', error);\n    }\n  }\n\n  private areDependenciesMet(task: SwarmTask): boolean {\n    return task.dependencies.every((depId) => {\n      const dep = this.tasks.get(depId);\n      return dep && dep.status === 'completed';\n    });\n  }\n\n  private selectBestAgent(task: SwarmTask, availableAgents: SwarmAgent[]): SwarmAgent | null {\n    // Simple selection based on task type and agent capabilities\n    const compatibleAgents = availableAgents.filter((agent) => {\n      // Match task type to agent type\n      if (task.type.includes('research') && agent.type === 'researcher') return true;\n      if (task.type.includes('implement') && agent.type === 'coder') return true;\n      if (task.type.includes('analysis') && agent.type === 'analyst') return true;\n      if (task.type.includes('review') && agent.type === 'reviewer') return true;\n      return agent.type === 'coordinator'; // Coordinator can do any task\n    });\n\n    if (compatibleAgents.length === 0) {\n      return availableAgents[0]; // Fallback to any available agent\n    }\n\n    // Select agent with best performance metrics\n    return compatibleAgents.reduce((best, agent) => {\n      const bestRatio = best.metrics.tasksCompleted / (best.metrics.tasksFailed + 1);\n      const agentRatio = agent.metrics.tasksCompleted / (agent.metrics.tasksFailed + 1);\n      return agentRatio > bestRatio ? agent : best;\n    });\n  }\n\n  private async performHealthChecks(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      const now = new Date();\n\n      for (const [agentId, agent] of this.agents) {\n        // Check for stalled agents\n        if (agent.status === 'busy' && agent.currentTask) {\n          const taskDuration = now.getTime() - (agent.currentTask.startedAt?.getTime() || 0);\n          if (taskDuration > this.config.taskTimeout) {\n            this.logger.warn(`Agent ${agentId} appears stalled on task ${agent.currentTask.id}`);\n            await this.handleTaskFailed(agent.currentTask.id, new Error('Task timeout'));\n          }\n        }\n\n        // Check agent health\n        const inactivityTime = now.getTime() - agent.metrics.lastActivity.getTime();\n        if (inactivityTime > this.config.healthCheckInterval * 3) {\n          this.logger.warn(\n            `Agent ${agentId} has been inactive for ${Math.round(inactivityTime / 1000)}s`,\n          );\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error performing health checks:', error);\n    }\n  }\n\n  private async performWorkStealing(): Promise<void> {\n    if (!this.isRunning || !this.workStealer) return;\n\n    try {\n      // Get agent workloads\n      const workloads = new Map<string, number>();\n      for (const [agentId, agent] of this.agents) {\n        workloads.set(agentId, agent.status === 'busy' ? 1 : 0);\n      }\n\n      // Update work stealer\n      this.workStealer.updateLoads(workloads);\n\n      // Check for work stealing opportunities\n      const stealingSuggestions = this.workStealer.suggestWorkStealing();\n\n      for (const suggestion of stealingSuggestions) {\n        this.logger.debug(`Work stealing suggestion: ${suggestion.from} -> ${suggestion.to}`);\n        // In a real implementation, we would reassign tasks here\n      }\n    } catch (error) {\n      this.logger.error('Error performing work stealing:', error);\n    }\n  }\n\n  private async syncMemoryState(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      // Sync current state to memory\n      const state = {\n        objectives: Array.from(this.objectives.values()),\n        tasks: Array.from(this.tasks.values()),\n        agents: Array.from(this.agents.values()).map((a) => ({\n          ...a,\n          currentTask: undefined, // Don't store transient state\n        })),\n        timestamp: new Date(),\n      };\n\n      await this.memoryManager.store({\n        id: 'swarm:state',\n        agentId: 'swarm-coordinator',\n        type: 'swarm-state',\n        content: JSON.stringify(state),\n        namespace: this.config.memoryNamespace,\n        timestamp: new Date(),\n        metadata: {\n          type: 'swarm-state',\n          objectiveCount: state.objectives.length,\n          taskCount: state.tasks.length,\n          agentCount: state.agents.length,\n        },\n      });\n    } catch (error) {\n      this.logger.error('Error syncing memory state:', error);\n    }\n  }\n\n  private handleMonitorAlert(alert: any): void {\n    this.logger.warn(`Monitor alert: ${alert.message}`);\n    this.emit('monitor:alert', alert);\n  }\n\n  private handleAgentMessage(message: Message): void {\n    this.logger.debug(`Agent message: ${message.type} from ${message.from}`);\n    this.emit('agent:message', message);\n  }\n\n  // Public API methods\n  async executeObjective(objectiveId: string): Promise<void> {\n    const objective = this.objectives.get(objectiveId);\n    if (!objective) {\n      throw new Error('Objective not found');\n    }\n\n    objective.status = 'executing';\n    this.logger.info(`Executing objective: ${objectiveId}`);\n    this.emit('objective:started', objective);\n\n    // Tasks will be processed by background workers\n  }\n\n  getObjectiveStatus(objectiveId: string): SwarmObjective | undefined {\n    return this.objectives.get(objectiveId);\n  }\n\n  getAgentStatus(agentId: string): SwarmAgent | undefined {\n    return this.agents.get(agentId);\n  }\n\n  getSwarmStatus(): {\n    objectives: number;\n    tasks: { total: number; pending: number; running: number; completed: number; failed: number };\n    agents: { total: number; idle: number; busy: number; failed: number };\n    uptime: number;\n  } {\n    const tasks = Array.from(this.tasks.values());\n    const agents = Array.from(this.agents.values());\n\n    return {\n      objectives: this.objectives.size,\n      tasks: {\n        total: tasks.length,\n        pending: tasks.filter((t) => t.status === 'pending').length,\n        running: tasks.filter((t) => t.status === 'running').length,\n        completed: tasks.filter((t) => t.status === 'completed').length,\n        failed: tasks.filter((t) => t.status === 'failed').length,\n      },\n      agents: {\n        total: agents.length,\n        idle: agents.filter((a) => a.status === 'idle').length,\n        busy: agents.filter((a) => a.status === 'busy').length,\n        failed: agents.filter((a) => a.status === 'failed').length,\n      },\n      uptime: this.monitor ? this.monitor.getSummary().uptime : 0,\n    };\n  }\n}\n"],"names":["EventEmitter","Logger","EventBus","generateId","SwarmMonitor","MemoryManager","SwarmCoordinator","logger","config","agents","objectives","tasks","monitor","scheduler","memoryManager","backgroundWorkers","isRunning","workStealer","circuitBreaker","maxAgents","maxConcurrentTasks","taskTimeout","enableMonitoring","enableWorkStealing","enableCircuitBreaker","memoryNamespace","coordinationStrategy","backgroundTaskInterval","healthCheckInterval","maxRetries","backoffMultiplier","Map","eventBus","getInstance","backend","namespace","cacheSizeMB","syncOnExit","maxEntries","ttlMinutes","updateInterval","enableAlerts","enableHistory","setupEventHandlers","on","alert","handleMonitorAlert","data","handleTaskCompleted","taskId","result","handleTaskFailed","error","start","warn","info","initialize","startBackgroundWorkers","emit","stop","stopBackgroundWorkers","shutdown","taskProcessor","setInterval","processBackgroundTasks","set","healthChecker","performHealthChecks","workStealerWorker","performWorkStealing","memorySync","syncMemoryState","name","worker","clearInterval","debug","clear","createObjective","description","strategy","objectiveId","objective","id","status","createdAt","Date","decomposeObjective","store","agentId","type","content","JSON","stringify","timestamp","metadata","taskCount","length","push","createTask","forEach","task","priority","dependencies","retryCount","timeout","registerAgent","capabilities","agent","metrics","tasksCompleted","tasksFailed","totalDuration","lastActivity","registerWorker","assignTask","get","Error","canExecute","assignedTo","startedAt","currentTask","taskStarted","executeTask","simulateTaskExecution","Promise","resolve","reject","setTimeout","clearTimeout","Math","random","completedAt","undefined","getTime","taskCompleted","recordSuccess","taskType","checkObjectiveCompletion","message","String","taskFailed","recordFailure","completedTask","allTasksComplete","every","t","pendingTasks","Array","from","values","filter","areDependenciesMet","availableAgents","a","selectBestAgent","splice","indexOf","depId","dep","compatibleAgents","includes","reduce","best","bestRatio","agentRatio","now","taskDuration","inactivityTime","round","workloads","updateLoads","stealingSuggestions","suggestWorkStealing","suggestion","to","state","map","objectiveCount","agentCount","handleAgentMessage","executeObjective","getObjectiveStatus","getAgentStatus","getSwarmStatus","size","total","pending","running","completed","failed","idle","busy","uptime","getSummary"],"mappings":"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"}