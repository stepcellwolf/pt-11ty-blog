{"version":3,"sources":["../../../src/coordination/dependency-graph.ts"],"sourcesContent":["/**\n * Dependency graph management for task scheduling\n */\n\nimport type { Task } from '../utils/types.js';\nimport { TaskDependencyError } from '../utils/errors.js';\nimport type { ILogger } from '../core/logger.js';\n\nexport interface DependencyNode {\n  taskId: string;\n  dependencies: Set<string>;\n  dependents: Set<string>;\n  status: 'pending' | 'ready' | 'running' | 'completed' | 'failed';\n}\n\nexport interface DependencyPath {\n  from: string;\n  to: string;\n  path: string[];\n}\n\n/**\n * Manages task dependencies and determines execution order\n */\nexport class DependencyGraph {\n  private nodes = new Map<string, DependencyNode>();\n  private completedTasks = new Set<string>();\n\n  constructor(private logger: ILogger) {}\n\n  /**\n   * Add a task to the dependency graph\n   */\n  addTask(task: Task): void {\n    if (this.nodes.has(task.id)) {\n      this.logger.warn('Task already exists in dependency graph', { taskId: task.id });\n      return;\n    }\n\n    const node: DependencyNode = {\n      taskId: task.id,\n      dependencies: new Set(task.dependencies),\n      dependents: new Set(),\n      status: 'pending',\n    };\n\n    // Validate dependencies exist\n    for (const depId of task.dependencies) {\n      if (!this.nodes.has(depId) && !this.completedTasks.has(depId)) {\n        throw new TaskDependencyError(task.id, [depId]);\n      }\n    }\n\n    // Add node\n    this.nodes.set(task.id, node);\n\n    // Update dependents for dependencies\n    for (const depId of task.dependencies) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.dependents.add(task.id);\n      }\n    }\n\n    // Check if task is ready\n    if (this.isTaskReady(task.id)) {\n      node.status = 'ready';\n    }\n  }\n\n  /**\n   * Remove a task from the dependency graph\n   */\n  removeTask(taskId: string): void {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      return;\n    }\n\n    // Remove from dependents of dependencies\n    for (const depId of node.dependencies) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.dependents.delete(taskId);\n      }\n    }\n\n    // Remove from dependencies of dependents\n    for (const depId of node.dependents) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.dependencies.delete(taskId);\n        // Check if dependent is now ready\n        if (this.isTaskReady(depId)) {\n          depNode.status = 'ready';\n        }\n      }\n    }\n\n    this.nodes.delete(taskId);\n  }\n\n  /**\n   * Mark a task as completed\n   */\n  markCompleted(taskId: string): string[] {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      this.logger.warn('Task not found in dependency graph', { taskId });\n      return [];\n    }\n\n    node.status = 'completed';\n    this.completedTasks.add(taskId);\n\n    // Find newly ready tasks\n    const readyTasks: string[] = [];\n\n    for (const dependentId of node.dependents) {\n      const dependent = this.nodes.get(dependentId);\n      if (dependent && dependent.status === 'pending' && this.isTaskReady(dependentId)) {\n        dependent.status = 'ready';\n        readyTasks.push(dependentId);\n      }\n    }\n\n    // Remove from active graph\n    this.removeTask(taskId);\n\n    return readyTasks;\n  }\n\n  /**\n   * Mark a task as failed\n   */\n  markFailed(taskId: string): string[] {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      return [];\n    }\n\n    node.status = 'failed';\n\n    // Get all dependent tasks that need to be cancelled\n    const toCancelIds = this.getAllDependents(taskId);\n\n    // Mark all dependents as failed\n    for (const depId of toCancelIds) {\n      const depNode = this.nodes.get(depId);\n      if (depNode) {\n        depNode.status = 'failed';\n      }\n    }\n\n    return toCancelIds;\n  }\n\n  /**\n   * Check if a task is ready to run\n   */\n  isTaskReady(taskId: string): boolean {\n    const node = this.nodes.get(taskId);\n    if (!node) {\n      return false;\n    }\n\n    // All dependencies must be completed\n    for (const depId of node.dependencies) {\n      if (!this.completedTasks.has(depId)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get all ready tasks\n   */\n  getReadyTasks(): string[] {\n    const ready: string[] = [];\n\n    for (const [taskId, node] of this.nodes) {\n      if (node.status === 'ready' || (node.status === 'pending' && this.isTaskReady(taskId))) {\n        ready.push(taskId);\n        node.status = 'ready';\n      }\n    }\n\n    return ready;\n  }\n\n  /**\n   * Get all dependents of a task (recursive)\n   */\n  getAllDependents(taskId: string): string[] {\n    const visited = new Set<string>();\n    const dependents: string[] = [];\n\n    const visit = (id: string) => {\n      if (visited.has(id)) {\n        return;\n      }\n      visited.add(id);\n\n      const node = this.nodes.get(id);\n      if (!node) {\n        return;\n      }\n\n      for (const depId of node.dependents) {\n        if (!visited.has(depId)) {\n          dependents.push(depId);\n          visit(depId);\n        }\n      }\n    };\n\n    visit(taskId);\n    return dependents;\n  }\n\n  /**\n   * Detect circular dependencies\n   */\n  detectCycles(): string[][] {\n    const cycles: string[][] = [];\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const currentPath: string[] = [];\n\n    const hasCycle = (taskId: string): boolean => {\n      visited.add(taskId);\n      recursionStack.add(taskId);\n      currentPath.push(taskId);\n\n      const node = this.nodes.get(taskId);\n      if (!node) {\n        currentPath.pop();\n        recursionStack.delete(taskId);\n        return false;\n      }\n\n      for (const depId of node.dependencies) {\n        if (!visited.has(depId)) {\n          if (hasCycle(depId)) {\n            return true;\n          }\n        } else if (recursionStack.has(depId)) {\n          // Found cycle\n          const cycleStart = currentPath.indexOf(depId);\n          const cycle = currentPath.slice(cycleStart);\n          cycle.push(depId); // Complete the cycle\n          cycles.push(cycle);\n          return true;\n        }\n      }\n\n      currentPath.pop();\n      recursionStack.delete(taskId);\n      return false;\n    };\n\n    // Check all nodes\n    for (const taskId of this.nodes.keys()) {\n      if (!visited.has(taskId)) {\n        hasCycle(taskId);\n      }\n    }\n\n    return cycles;\n  }\n\n  /**\n   * Get topological sort of tasks\n   */\n  topologicalSort(): string[] | null {\n    // Check for cycles first\n    const cycles = this.detectCycles();\n    if (cycles.length > 0) {\n      this.logger.error('Cannot perform topological sort due to cycles', { cycles });\n      return null;\n    }\n\n    const sorted: string[] = [];\n    const visited = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (visited.has(taskId)) {\n        return;\n      }\n      visited.add(taskId);\n\n      const node = this.nodes.get(taskId);\n      if (!node) {\n        return;\n      }\n\n      // Visit dependencies first\n      for (const depId of node.dependencies) {\n        if (!visited.has(depId)) {\n          visit(depId);\n        }\n      }\n\n      sorted.push(taskId);\n    };\n\n    // Visit all nodes\n    for (const taskId of this.nodes.keys()) {\n      if (!visited.has(taskId)) {\n        visit(taskId);\n      }\n    }\n\n    return sorted;\n  }\n\n  /**\n   * Find critical path (longest path through the graph)\n   */\n  findCriticalPath(): DependencyPath | null {\n    const paths: DependencyPath[] = [];\n\n    // Find all paths from tasks with no dependencies to tasks with no dependents\n    const sources = Array.from(this.nodes.entries())\n      .filter(([_, node]) => node.dependencies.size === 0)\n      .map(([id]) => id);\n\n    const sinks = Array.from(this.nodes.entries())\n      .filter(([_, node]) => node.dependents.size === 0)\n      .map(([id]) => id);\n\n    for (const source of sources) {\n      for (const sink of sinks) {\n        const path = this.findPath(source, sink);\n        if (path) {\n          paths.push({ from: source, to: sink, path });\n        }\n      }\n    }\n\n    // Return longest path\n    if (paths.length === 0) {\n      return null;\n    }\n\n    return paths.reduce((longest, current) =>\n      current.path.length > longest.path.length ? current : longest,\n    );\n  }\n\n  /**\n   * Find path between two tasks\n   */\n  private findPath(from: string, to: string): string[] | null {\n    if (from === to) {\n      return [from];\n    }\n\n    const visited = new Set<string>();\n    const queue: Array<{ taskId: string; path: string[] }> = [{ taskId: from, path: [from] }];\n\n    while (queue.length > 0) {\n      const { taskId, path } = queue.shift()!;\n\n      if (visited.has(taskId)) {\n        continue;\n      }\n      visited.add(taskId);\n\n      const node = this.nodes.get(taskId);\n      if (!node) {\n        continue;\n      }\n\n      for (const depId of node.dependents) {\n        if (depId === to) {\n          return [...path, to];\n        }\n\n        if (!visited.has(depId)) {\n          queue.push({ taskId: depId, path: [...path, depId] });\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get graph statistics\n   */\n  getStats(): Record<string, unknown> {\n    const stats = {\n      totalTasks: this.nodes.size,\n      completedTasks: this.completedTasks.size,\n      readyTasks: 0,\n      pendingTasks: 0,\n      runningTasks: 0,\n      failedTasks: 0,\n      avgDependencies: 0,\n      maxDependencies: 0,\n      cycles: this.detectCycles(),\n    };\n\n    let totalDeps = 0;\n    for (const node of this.nodes.values()) {\n      totalDeps += node.dependencies.size;\n      stats.maxDependencies = Math.max(stats.maxDependencies, node.dependencies.size);\n\n      switch (node.status) {\n        case 'ready':\n          stats.readyTasks++;\n          break;\n        case 'pending':\n          stats.pendingTasks++;\n          break;\n        case 'running':\n          stats.runningTasks++;\n          break;\n        case 'failed':\n          stats.failedTasks++;\n          break;\n      }\n    }\n\n    stats.avgDependencies = this.nodes.size > 0 ? totalDeps / this.nodes.size : 0;\n\n    return stats;\n  }\n\n  /**\n   * Export graph to DOT format for visualization\n   */\n  toDot(): string {\n    let dot = 'digraph TaskDependencies {\\n';\n    dot += '  rankdir=LR;\\n';\n    dot += '  node [shape=box];\\n\\n';\n\n    // Add nodes with status colors\n    for (const [taskId, node] of this.nodes) {\n      let color = 'white';\n      switch (node.status) {\n        case 'ready':\n          color = 'lightgreen';\n          break;\n        case 'running':\n          color = 'yellow';\n          break;\n        case 'completed':\n          color = 'green';\n          break;\n        case 'failed':\n          color = 'red';\n          break;\n      }\n      dot += `  \"${taskId}\" [style=filled, fillcolor=${color}];\\n`;\n    }\n\n    dot += '\\n';\n\n    // Add edges\n    for (const [taskId, node] of this.nodes) {\n      for (const depId of node.dependencies) {\n        dot += `  \"${depId}\" -> \"${taskId}\";\\n`;\n      }\n    }\n\n    dot += '}\\n';\n    return dot;\n  }\n}\n"],"names":["TaskDependencyError","DependencyGraph","nodes","Map","completedTasks","Set","logger","addTask","task","has","id","warn","taskId","node","dependencies","dependents","status","depId","set","depNode","get","add","isTaskReady","removeTask","delete","markCompleted","readyTasks","dependentId","dependent","push","markFailed","toCancelIds","getAllDependents","getReadyTasks","ready","visited","visit","detectCycles","cycles","recursionStack","currentPath","hasCycle","pop","cycleStart","indexOf","cycle","slice","keys","topologicalSort","length","error","sorted","findCriticalPath","paths","sources","Array","from","entries","filter","_","size","map","sinks","source","sink","path","findPath","to","reduce","longest","current","queue","shift","getStats","stats","totalTasks","pendingTasks","runningTasks","failedTasks","avgDependencies","maxDependencies","totalDeps","values","Math","max","toDot","dot","color"],"mappings":"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"}