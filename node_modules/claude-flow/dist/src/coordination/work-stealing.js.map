{"version":3,"sources":["../../../src/coordination/work-stealing.ts"],"sourcesContent":["/**\n * Work stealing algorithm for load balancing between agents\n */\n\nimport type { Task, AgentProfile } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\n\nexport interface WorkStealingConfig {\n  enabled: boolean;\n  stealThreshold: number; // Min difference in task count to trigger stealing\n  maxStealBatch: number; // Max tasks to steal at once\n  stealInterval: number; // How often to check for steal opportunities (ms)\n}\n\nexport interface AgentWorkload {\n  agentId: string;\n  taskCount: number;\n  avgTaskDuration: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  priority: number;\n  capabilities: string[];\n}\n\n/**\n * Work stealing coordinator for load balancing\n */\nexport class WorkStealingCoordinator {\n  private workloads = new Map<string, AgentWorkload>();\n  private stealInterval?: ReturnType<typeof setInterval>;\n  private taskDurations = new Map<string, number[]>(); // agentId -> task durations\n\n  constructor(\n    private config: WorkStealingConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    if (!this.config.enabled) {\n      this.logger.info('Work stealing is disabled');\n      return;\n    }\n\n    this.logger.info('Initializing work stealing coordinator');\n\n    // Start periodic steal checks\n    this.stealInterval = setInterval(() => this.checkAndSteal(), this.config.stealInterval);\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.stealInterval) {\n      clearInterval(this.stealInterval);\n    }\n\n    this.workloads.clear();\n    this.taskDurations.clear();\n  }\n\n  updateAgentWorkload(agentId: string, workload: Partial<AgentWorkload>): void {\n    const existing = this.workloads.get(agentId) || {\n      agentId,\n      taskCount: 0,\n      avgTaskDuration: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      priority: 0,\n      capabilities: [],\n    };\n\n    this.workloads.set(agentId, { ...existing, ...workload });\n  }\n\n  recordTaskDuration(agentId: string, duration: number): void {\n    if (!this.taskDurations.has(agentId)) {\n      this.taskDurations.set(agentId, []);\n    }\n\n    const durations = this.taskDurations.get(agentId)!;\n    durations.push(duration);\n\n    // Keep only last 100 durations\n    if (durations.length > 100) {\n      durations.shift();\n    }\n\n    // Update average duration\n    const avg = durations.reduce((sum, d) => sum + d, 0) / durations.length;\n    this.updateAgentWorkload(agentId, { avgTaskDuration: avg });\n  }\n\n  async checkAndSteal(): Promise<void> {\n    const workloads = Array.from(this.workloads.values());\n    if (workloads.length < 2) {\n      return; // Need at least 2 agents\n    }\n\n    // Sort by task count (ascending)\n    workloads.sort((a, b) => a.taskCount - b.taskCount);\n\n    const minLoaded = workloads[0];\n    const maxLoaded = workloads[workloads.length - 1];\n\n    // Check if stealing is warranted\n    const difference = maxLoaded.taskCount - minLoaded.taskCount;\n    if (difference < this.config.stealThreshold) {\n      return; // Not enough imbalance\n    }\n\n    // Calculate how many tasks to steal\n    const tasksToSteal = Math.min(Math.floor(difference / 2), this.config.maxStealBatch);\n\n    this.logger.info('Initiating work stealing', {\n      from: maxLoaded.agentId,\n      to: minLoaded.agentId,\n      tasksToSteal,\n      difference,\n    });\n\n    // Emit steal request event\n    this.eventBus.emit('workstealing:request', {\n      sourceAgent: maxLoaded.agentId,\n      targetAgent: minLoaded.agentId,\n      taskCount: tasksToSteal,\n    });\n  }\n\n  /**\n   * Find the best agent for a task based on capabilities and load\n   */\n  findBestAgent(task: Task, agents: AgentProfile[]): string | null {\n    const candidates: Array<{\n      agentId: string;\n      score: number;\n    }> = [];\n\n    for (const agent of agents) {\n      const workload = this.workloads.get(agent.id);\n      if (!workload) {\n        continue;\n      }\n\n      // Calculate score based on multiple factors\n      let score = 100;\n\n      // Factor 1: Task count (lower is better)\n      score -= workload.taskCount * 10;\n\n      // Factor 2: CPU usage (lower is better)\n      score -= workload.cpuUsage * 0.5;\n\n      // Factor 3: Memory usage (lower is better)\n      score -= workload.memoryUsage * 0.3;\n\n      // Factor 4: Agent priority (higher is better)\n      score += agent.priority * 5;\n\n      // Factor 5: Capability match\n      const taskType = task.type;\n      if (agent.capabilities.includes(taskType)) {\n        score += 20; // Bonus for capability match\n      }\n\n      // Factor 6: Average task duration (predictive load)\n      const predictedLoad = workload.avgTaskDuration * workload.taskCount;\n      score -= predictedLoad / 1000; // Convert to seconds\n\n      candidates.push({ agentId: agent.id, score });\n    }\n\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    // Sort by score (descending) and return best\n    candidates.sort((a, b) => b.score - a.score);\n\n    this.logger.debug('Agent selection scores', {\n      taskId: task.id,\n      candidates: candidates.slice(0, 5), // Top 5\n    });\n\n    return candidates[0].agentId;\n  }\n\n  getWorkloadStats(): Record<string, unknown> {\n    const stats: Record<string, unknown> = {\n      totalAgents: this.workloads.size,\n      workloads: {},\n    };\n\n    let totalTasks = 0;\n    let minTasks = Infinity;\n    let maxTasks = 0;\n\n    for (const [agentId, workload] of this.workloads) {\n      totalTasks += workload.taskCount;\n      minTasks = Math.min(minTasks, workload.taskCount);\n      maxTasks = Math.max(maxTasks, workload.taskCount);\n\n      (stats.workloads as Record<string, unknown>)[agentId] = {\n        taskCount: workload.taskCount,\n        avgTaskDuration: workload.avgTaskDuration,\n        cpuUsage: workload.cpuUsage,\n        memoryUsage: workload.memoryUsage,\n      };\n    }\n\n    stats.totalTasks = totalTasks;\n    stats.avgTasksPerAgent = totalTasks / this.workloads.size;\n    stats.minTasks = minTasks === Infinity ? 0 : minTasks;\n    stats.maxTasks = maxTasks;\n    stats.imbalance = maxTasks - (minTasks === Infinity ? 0 : minTasks);\n\n    return stats;\n  }\n}\n"],"names":["WorkStealingCoordinator","workloads","Map","stealInterval","taskDurations","config","eventBus","logger","initialize","enabled","info","setInterval","checkAndSteal","shutdown","clearInterval","clear","updateAgentWorkload","agentId","workload","existing","get","taskCount","avgTaskDuration","cpuUsage","memoryUsage","priority","capabilities","set","recordTaskDuration","duration","has","durations","push","length","shift","avg","reduce","sum","d","Array","from","values","sort","a","b","minLoaded","maxLoaded","difference","stealThreshold","tasksToSteal","Math","min","floor","maxStealBatch","to","emit","sourceAgent","targetAgent","findBestAgent","task","agents","candidates","agent","id","score","taskType","type","includes","predictedLoad","debug","taskId","slice","getWorkloadStats","stats","totalAgents","size","totalTasks","minTasks","Infinity","maxTasks","max","avgTasksPerAgent","imbalance"],"mappings":"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"}