{"version":3,"sources":["../../../src/coordination/scheduler.ts"],"sourcesContent":["/**\n * Task scheduler implementation\n */\n\nimport { Task, TaskStatus, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TaskError, TaskTimeoutError, TaskDependencyError } from '../utils/errors.js';\nimport { delay } from '../utils/helpers.js';\n\ninterface ScheduledTask {\n  task: Task;\n  agentId: string;\n  attempts: number;\n  lastAttempt?: Date;\n  timeout?: number;\n}\n\n/**\n * Task scheduler for managing task assignment and execution\n */\nexport class TaskScheduler {\n  protected tasks = new Map<string, ScheduledTask>();\n  protected agentTasks = new Map<string, Set<string>>(); // agentId -> taskIds\n  protected taskDependencies = new Map<string, Set<string>>(); // taskId -> dependent taskIds\n  protected completedTasks = new Set<string>();\n\n  constructor(\n    protected config: CoordinationConfig,\n    protected eventBus: IEventBus,\n    protected logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing task scheduler');\n\n    // Set up periodic cleanup\n    setInterval(() => this.cleanup(), 60000); // Every minute\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down task scheduler');\n\n    // Cancel all active tasks\n    const taskIds = Array.from(this.tasks.keys());\n    await Promise.all(taskIds.map((id) => this.cancelTask(id, 'Scheduler shutdown')));\n\n    this.tasks.clear();\n    this.agentTasks.clear();\n    this.taskDependencies.clear();\n    this.completedTasks.clear();\n  }\n\n  async assignTask(task: Task, agentId: string): Promise<void> {\n    this.logger.info('Assigning task', { taskId: task.id, agentId });\n\n    // Check dependencies\n    if (task.dependencies.length > 0) {\n      const unmetDependencies = task.dependencies.filter(\n        (depId) => !this.completedTasks.has(depId),\n      );\n\n      if (unmetDependencies.length > 0) {\n        throw new TaskDependencyError(task.id, unmetDependencies);\n      }\n    }\n\n    // Create scheduled task\n    const scheduledTask: ScheduledTask = {\n      task: { ...task, status: 'assigned', assignedAgent: agentId },\n      agentId,\n      attempts: 0,\n    };\n\n    // Store task\n    this.tasks.set(task.id, scheduledTask);\n\n    // Update agent tasks\n    if (!this.agentTasks.has(agentId)) {\n      this.agentTasks.set(agentId, new Set());\n    }\n    this.agentTasks.get(agentId)!.add(task.id);\n\n    // Update dependencies\n    for (const depId of task.dependencies) {\n      if (!this.taskDependencies.has(depId)) {\n        this.taskDependencies.set(depId, new Set());\n      }\n      this.taskDependencies.get(depId)!.add(task.id);\n    }\n\n    // Start task execution\n    this.startTask(task.id);\n  }\n\n  async completeTask(taskId: string, result: unknown): Promise<void> {\n    const scheduled = this.tasks.get(taskId);\n    if (!scheduled) {\n      throw new TaskError(`Task not found: ${taskId}`);\n    }\n\n    this.logger.info('Task completed', { taskId, agentId: scheduled.agentId });\n\n    // Update task status\n    scheduled.task.status = 'completed';\n    scheduled.task.output = result as Record<string, unknown>;\n    scheduled.task.completedAt = new Date();\n\n    // Clear timeout\n    if (scheduled.timeout) {\n      clearTimeout(scheduled.timeout);\n    }\n\n    // Remove from active tasks\n    this.tasks.delete(taskId);\n    this.agentTasks.get(scheduled.agentId)?.delete(taskId);\n\n    // Add to completed tasks\n    this.completedTasks.add(taskId);\n\n    // Check and start dependent tasks\n    const dependents = this.taskDependencies.get(taskId);\n    if (dependents) {\n      for (const dependentId of dependents) {\n        const dependent = this.tasks.get(dependentId);\n        if (dependent && this.canStartTask(dependent.task)) {\n          this.startTask(dependentId);\n        }\n      }\n    }\n  }\n\n  async failTask(taskId: string, error: Error): Promise<void> {\n    const scheduled = this.tasks.get(taskId);\n    if (!scheduled) {\n      throw new TaskError(`Task not found: ${taskId}`);\n    }\n\n    this.logger.error('Task failed', {\n      taskId,\n      agentId: scheduled.agentId,\n      attempt: scheduled.attempts,\n      error,\n    });\n\n    // Clear timeout\n    if (scheduled.timeout) {\n      clearTimeout(scheduled.timeout);\n    }\n\n    scheduled.attempts++;\n    scheduled.lastAttempt = new Date();\n\n    // Check if we should retry\n    if (scheduled.attempts < this.config.maxRetries) {\n      this.logger.info('Retrying task', {\n        taskId,\n        attempt: scheduled.attempts,\n        maxRetries: this.config.maxRetries,\n      });\n\n      // Schedule retry with exponential backoff\n      const retryDelay = this.config.retryDelay * Math.pow(2, scheduled.attempts - 1);\n\n      setTimeout(() => {\n        this.startTask(taskId);\n      }, retryDelay);\n    } else {\n      // Max retries exceeded, mark as failed\n      scheduled.task.status = 'failed';\n      scheduled.task.error = error;\n      scheduled.task.completedAt = new Date();\n\n      // Remove from active tasks\n      this.tasks.delete(taskId);\n      this.agentTasks.get(scheduled.agentId)?.delete(taskId);\n\n      // Cancel dependent tasks\n      await this.cancelDependentTasks(taskId, 'Parent task failed');\n    }\n  }\n\n  async cancelTask(taskId: string, reason: string): Promise<void> {\n    const scheduled = this.tasks.get(taskId);\n    if (!scheduled) {\n      return; // Already cancelled or completed\n    }\n\n    this.logger.info('Cancelling task', { taskId, reason });\n\n    // Clear timeout\n    if (scheduled.timeout) {\n      clearTimeout(scheduled.timeout);\n    }\n\n    // Update task status\n    scheduled.task.status = 'cancelled';\n    scheduled.task.completedAt = new Date();\n\n    // Emit cancellation event\n    this.eventBus.emit(SystemEvents.TASK_CANCELLED, { taskId, reason });\n\n    // Remove from active tasks\n    this.tasks.delete(taskId);\n    this.agentTasks.get(scheduled.agentId)?.delete(taskId);\n\n    // Cancel dependent tasks\n    await this.cancelDependentTasks(taskId, 'Parent task cancelled');\n  }\n\n  async cancelAgentTasks(agentId: string): Promise<void> {\n    const taskIds = this.agentTasks.get(agentId);\n    if (!taskIds) {\n      return;\n    }\n\n    this.logger.info('Cancelling all tasks for agent', {\n      agentId,\n      taskCount: taskIds.size,\n    });\n\n    const promises = Array.from(taskIds).map((taskId) =>\n      this.cancelTask(taskId, 'Agent terminated'),\n    );\n\n    await Promise.all(promises);\n    this.agentTasks.delete(agentId);\n  }\n\n  async rescheduleAgentTasks(agentId: string): Promise<void> {\n    const taskIds = this.agentTasks.get(agentId);\n    if (!taskIds || taskIds.size === 0) {\n      return;\n    }\n\n    this.logger.info('Rescheduling tasks for agent', {\n      agentId,\n      taskCount: taskIds.size,\n    });\n\n    for (const taskId of taskIds) {\n      const scheduled = this.tasks.get(taskId);\n      if (scheduled && scheduled.task.status === 'running') {\n        // Reset task status\n        scheduled.task.status = 'queued';\n        scheduled.attempts = 0;\n\n        // Re-emit task created event for reassignment\n        this.eventBus.emit(SystemEvents.TASK_CREATED, {\n          task: scheduled.task,\n        });\n      }\n    }\n  }\n\n  getAgentTaskCount(agentId: string): number {\n    return this.agentTasks.get(agentId)?.size || 0;\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const activeTasks = this.tasks.size;\n    const completedTasks = this.completedTasks.size;\n    const agentsWithTasks = this.agentTasks.size;\n\n    const tasksByStatus: Record<TaskStatus, number> = {\n      pending: 0,\n      queued: 0,\n      assigned: 0,\n      running: 0,\n      completed: completedTasks,\n      failed: 0,\n      cancelled: 0,\n    };\n\n    for (const scheduled of this.tasks.values()) {\n      tasksByStatus[scheduled.task.status]++;\n    }\n\n    return {\n      healthy: true,\n      metrics: {\n        activeTasks,\n        completedTasks,\n        agentsWithTasks,\n        ...tasksByStatus,\n      },\n    };\n  }\n\n  async getAgentTasks(agentId: string): Promise<Task[]> {\n    const taskIds = this.agentTasks.get(agentId);\n    if (!taskIds) {\n      return [];\n    }\n\n    const tasks: Task[] = [];\n    for (const taskId of taskIds) {\n      const scheduled = this.tasks.get(taskId);\n      if (scheduled) {\n        tasks.push(scheduled.task);\n      }\n    }\n\n    return tasks;\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing task scheduler maintenance');\n\n    // Cleanup old completed tasks\n    this.cleanup();\n\n    // Check for stuck tasks\n    const now = new Date();\n    for (const [taskId, scheduled] of this.tasks) {\n      if (scheduled.task.status === 'running' && scheduled.task.startedAt) {\n        const runtime = now.getTime() - scheduled.task.startedAt.getTime();\n        if (runtime > this.config.resourceTimeout * 2) {\n          this.logger.warn('Found stuck task', {\n            taskId,\n            runtime,\n            agentId: scheduled.agentId,\n          });\n\n          // Force fail the task\n          await this.failTask(taskId, new TaskTimeoutError(taskId, runtime));\n        }\n      }\n    }\n  }\n\n  private startTask(taskId: string): void {\n    const scheduled = this.tasks.get(taskId);\n    if (!scheduled) {\n      return;\n    }\n\n    // Update status\n    scheduled.task.status = 'running';\n    scheduled.task.startedAt = new Date();\n\n    // Emit task started event\n    this.eventBus.emit(SystemEvents.TASK_STARTED, {\n      taskId,\n      agentId: scheduled.agentId,\n    });\n\n    // Set timeout for task execution\n    const timeoutMs = this.config.resourceTimeout;\n    scheduled.timeout = setTimeout(() => {\n      this.failTask(taskId, new TaskTimeoutError(taskId, timeoutMs));\n    }, timeoutMs);\n  }\n\n  private canStartTask(task: Task): boolean {\n    // Check if all dependencies are completed\n    return task.dependencies.every((depId) => this.completedTasks.has(depId));\n  }\n\n  private async cancelDependentTasks(taskId: string, reason: string): Promise<void> {\n    const dependents = this.taskDependencies.get(taskId);\n    if (!dependents) {\n      return;\n    }\n\n    for (const dependentId of dependents) {\n      await this.cancelTask(dependentId, reason);\n    }\n  }\n\n  private cleanup(): void {\n    // Clean up old completed tasks (keep last 1000)\n    if (this.completedTasks.size > 1000) {\n      const toRemove = this.completedTasks.size - 1000;\n      const iterator = this.completedTasks.values();\n\n      for (let i = 0; i < toRemove; i++) {\n        const result = iterator.next();\n        if (!result.done && result.value) {\n          this.completedTasks.delete(result.value);\n          this.taskDependencies.delete(result.value);\n        }\n      }\n    }\n  }\n}\n"],"names":["SystemEvents","TaskError","TaskTimeoutError","TaskDependencyError","TaskScheduler","tasks","Map","agentTasks","taskDependencies","completedTasks","Set","config","eventBus","logger","initialize","info","setInterval","cleanup","shutdown","taskIds","Array","from","keys","Promise","all","map","id","cancelTask","clear","assignTask","task","agentId","taskId","dependencies","length","unmetDependencies","filter","depId","has","scheduledTask","status","assignedAgent","attempts","set","get","add","startTask","completeTask","result","scheduled","output","completedAt","Date","timeout","clearTimeout","delete","dependents","dependentId","dependent","canStartTask","failTask","error","attempt","lastAttempt","maxRetries","retryDelay","Math","pow","setTimeout","cancelDependentTasks","reason","emit","TASK_CANCELLED","cancelAgentTasks","taskCount","size","promises","rescheduleAgentTasks","TASK_CREATED","getAgentTaskCount","getHealthStatus","activeTasks","agentsWithTasks","tasksByStatus","pending","queued","assigned","running","completed","failed","cancelled","values","healthy","metrics","getAgentTasks","push","performMaintenance","debug","now","startedAt","runtime","getTime","resourceTimeout","warn","TASK_STARTED","timeoutMs","every","toRemove","iterator","i","next","done","value"],"mappings":"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"}