{"version":3,"sources":["../../../src/coordination/resources.ts"],"sourcesContent":["/**\n * Resource manager for preventing conflicts and deadlocks\n */\n\nimport { Resource, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { ResourceLockError } from '../utils/errors.js';\nimport { delay, timeout } from '../utils/helpers.js';\n\ninterface LockRequest {\n  agentId: string;\n  resourceId: string;\n  timestamp: Date;\n  priority: number;\n}\n\n/**\n * Resource manager implementation\n */\nexport class ResourceManager {\n  private resources = new Map<string, Resource>();\n  private locks = new Map<string, string>(); // resourceId -> agentId\n  private waitQueue = new Map<string, LockRequest[]>(); // resourceId -> queue\n  private agentResources = new Map<string, Set<string>>(); // agentId -> resourceIds\n\n  constructor(\n    private config: CoordinationConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing resource manager');\n\n    // Set up periodic cleanup\n    setInterval(() => this.cleanup(), 30000); // Every 30 seconds\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down resource manager');\n\n    // Release all locks\n    for (const [resourceId, agentId] of this.locks) {\n      await this.release(resourceId, agentId);\n    }\n\n    this.resources.clear();\n    this.locks.clear();\n    this.waitQueue.clear();\n    this.agentResources.clear();\n  }\n\n  async acquire(resourceId: string, agentId: string, priority = 0): Promise<void> {\n    this.logger.debug('Resource acquisition requested', { resourceId, agentId });\n\n    // Check if resource exists\n    if (!this.resources.has(resourceId)) {\n      this.resources.set(resourceId, {\n        id: resourceId,\n        type: 'generic',\n        locked: false,\n      });\n    }\n\n    const resource = this.resources.get(resourceId)!;\n\n    // Check if already locked by this agent\n    if (this.locks.get(resourceId) === agentId) {\n      this.logger.debug('Resource already locked by agent', { resourceId, agentId });\n      return;\n    }\n\n    // Try to acquire lock\n    if (!resource.locked) {\n      await this.lockResource(resourceId, agentId);\n      return;\n    }\n\n    // Add to wait queue\n    const request: LockRequest = {\n      agentId,\n      resourceId,\n      timestamp: new Date(),\n      priority,\n    };\n\n    if (!this.waitQueue.has(resourceId)) {\n      this.waitQueue.set(resourceId, []);\n    }\n\n    const queue = this.waitQueue.get(resourceId)!;\n    queue.push(request);\n\n    // Sort by priority and timestamp\n    queue.sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return b.priority - a.priority; // Higher priority first\n      }\n      return a.timestamp.getTime() - b.timestamp.getTime(); // Earlier first\n    });\n\n    this.logger.info('Agent added to resource wait queue', {\n      resourceId,\n      agentId,\n      queueLength: queue.length,\n    });\n\n    // Wait for resource with timeout\n    const startTime = Date.now();\n    while (Date.now() - startTime < this.config.resourceTimeout) {\n      // Check if we're next in queue and resource is available\n      const nextRequest = queue[0];\n      if (nextRequest?.agentId === agentId && !resource.locked) {\n        // Remove from queue and acquire\n        queue.shift();\n        await this.lockResource(resourceId, agentId);\n        return;\n      }\n\n      // Check if our request is still in queue\n      const ourRequest = queue.find((req) => req.agentId === agentId);\n      if (!ourRequest) {\n        // Request was removed (possibly by cleanup)\n        throw new ResourceLockError('Resource request cancelled');\n      }\n\n      await delay(100);\n    }\n\n    // Timeout - remove from queue\n    const index = queue.findIndex((req) => req.agentId === agentId);\n    if (index !== -1) {\n      queue.splice(index, 1);\n    }\n\n    throw new ResourceLockError(`Resource acquisition timeout for ${resourceId}`, {\n      resourceId,\n      agentId,\n      timeout: this.config.resourceTimeout,\n    });\n  }\n\n  async release(resourceId: string, agentId: string): Promise<void> {\n    this.logger.debug('Resource release requested', { resourceId, agentId });\n\n    const currentLock = this.locks.get(resourceId);\n    if (currentLock !== agentId) {\n      this.logger.warn('Attempted to release unowned resource', {\n        resourceId,\n        agentId,\n        currentLock,\n      });\n      return;\n    }\n\n    // Release the lock\n    this.unlockResource(resourceId, agentId);\n\n    // Process wait queue\n    const queue = this.waitQueue.get(resourceId);\n    if (queue && queue.length > 0) {\n      const nextRequest = queue.shift()!;\n\n      // Grant lock to next in queue\n      await this.lockResource(resourceId, nextRequest.agentId);\n    }\n  }\n\n  async releaseAllForAgent(agentId: string): Promise<void> {\n    const resources = this.agentResources.get(agentId);\n    if (!resources) {\n      return;\n    }\n\n    this.logger.info('Releasing all resources for agent', {\n      agentId,\n      resourceCount: resources.size,\n    });\n\n    const promises = Array.from(resources).map((resourceId) => this.release(resourceId, agentId));\n\n    await Promise.all(promises);\n    this.agentResources.delete(agentId);\n  }\n\n  getAllocations(): Map<string, string> {\n    return new Map(this.locks);\n  }\n\n  getWaitingRequests(): Map<string, string[]> {\n    const waiting = new Map<string, string[]>();\n\n    for (const [resourceId, queue] of this.waitQueue) {\n      if (queue.length > 0) {\n        waiting.set(queue[0].agentId, [...(waiting.get(queue[0].agentId) || []), resourceId]);\n      }\n    }\n\n    return waiting;\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const totalResources = this.resources.size;\n    const lockedResources = this.locks.size;\n    const waitingAgents = new Set<string>();\n    let totalWaiting = 0;\n\n    for (const queue of this.waitQueue.values()) {\n      totalWaiting += queue.length;\n      queue.forEach((req) => waitingAgents.add(req.agentId));\n    }\n\n    return {\n      healthy: true,\n      metrics: {\n        totalResources,\n        lockedResources,\n        freeResources: totalResources - lockedResources,\n        waitingAgents: waitingAgents.size,\n        totalWaitingRequests: totalWaiting,\n      },\n    };\n  }\n\n  private async lockResource(resourceId: string, agentId: string): Promise<void> {\n    const resource = this.resources.get(resourceId)!;\n\n    resource.locked = true;\n    resource.lockedBy = agentId;\n    resource.lockedAt = new Date();\n\n    this.locks.set(resourceId, agentId);\n\n    // Track agent resources\n    if (!this.agentResources.has(agentId)) {\n      this.agentResources.set(agentId, new Set());\n    }\n    this.agentResources.get(agentId)!.add(resourceId);\n\n    this.logger.info('Resource locked', { resourceId, agentId });\n\n    // Emit event\n    this.eventBus.emit(SystemEvents.RESOURCE_ACQUIRED, { resourceId, agentId });\n  }\n\n  private unlockResource(resourceId: string, agentId: string): void {\n    const resource = this.resources.get(resourceId);\n    if (!resource) {\n      return;\n    }\n\n    resource.locked = false;\n    delete resource.lockedBy;\n    delete resource.lockedAt;\n\n    this.locks.delete(resourceId);\n\n    // Remove from agent resources\n    this.agentResources.get(agentId)?.delete(resourceId);\n\n    this.logger.info('Resource unlocked', { resourceId, agentId });\n\n    // Emit event\n    this.eventBus.emit(SystemEvents.RESOURCE_RELEASED, { resourceId, agentId });\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing resource manager maintenance');\n    this.cleanup();\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n\n    // Clean up stale wait requests\n    for (const [resourceId, queue] of this.waitQueue) {\n      const filtered = queue.filter((req) => {\n        const age = now - req.timestamp.getTime();\n        if (age > this.config.resourceTimeout) {\n          this.logger.warn('Removing stale resource request', {\n            resourceId,\n            agentId: req.agentId,\n            age,\n          });\n          return false;\n        }\n        return true;\n      });\n\n      if (filtered.length === 0) {\n        this.waitQueue.delete(resourceId);\n      } else {\n        this.waitQueue.set(resourceId, filtered);\n      }\n    }\n\n    // Clean up locks held too long\n    for (const [resourceId, agentId] of this.locks) {\n      const resource = this.resources.get(resourceId);\n      if (resource?.lockedAt) {\n        const lockAge = now - resource.lockedAt.getTime();\n        if (lockAge > this.config.resourceTimeout * 2) {\n          this.logger.warn('Force releasing stale lock', {\n            resourceId,\n            agentId,\n            lockAge,\n          });\n          this.unlockResource(resourceId, agentId);\n        }\n      }\n    }\n  }\n}\n"],"names":["SystemEvents","ResourceLockError","delay","ResourceManager","resources","Map","locks","waitQueue","agentResources","config","eventBus","logger","initialize","info","setInterval","cleanup","shutdown","resourceId","agentId","release","clear","acquire","priority","debug","has","set","id","type","locked","resource","get","lockResource","request","timestamp","Date","queue","push","sort","a","b","getTime","queueLength","length","startTime","now","resourceTimeout","nextRequest","shift","ourRequest","find","req","index","findIndex","splice","timeout","currentLock","warn","unlockResource","releaseAllForAgent","resourceCount","size","promises","Array","from","map","Promise","all","delete","getAllocations","getWaitingRequests","waiting","getHealthStatus","totalResources","lockedResources","waitingAgents","Set","totalWaiting","values","forEach","add","healthy","metrics","freeResources","totalWaitingRequests","lockedBy","lockedAt","emit","RESOURCE_ACQUIRED","RESOURCE_RELEASED","performMaintenance","filtered","filter","age","lockAge"],"mappings":"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"}