{"version":3,"sources":["../../../src/coordination/advanced-scheduler.ts"],"sourcesContent":["/**\n * Advanced task scheduler with intelligent agent selection and priority handling\n */\n\nimport {\n  Task,\n  TaskStatus,\n  CoordinationConfig,\n  SystemEvents,\n  AgentProfile,\n} from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TaskScheduler } from './scheduler.js';\nimport { WorkStealingCoordinator } from './work-stealing.js';\nimport { DependencyGraph } from './dependency-graph.js';\nimport { CircuitBreakerManager, CircuitBreakerConfig } from './circuit-breaker.js';\n\nexport interface SchedulingStrategy {\n  name: string;\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null;\n}\n\nexport interface SchedulingContext {\n  taskLoads: Map<string, number>;\n  agentCapabilities: Map<string, string[]>;\n  agentPriorities: Map<string, number>;\n  taskHistory: Map<string, TaskStats>;\n  currentTime: Date;\n}\n\nexport interface TaskStats {\n  totalExecutions: number;\n  avgDuration: number;\n  successRate: number;\n  lastAgent?: string;\n}\n\n/**\n * Capability-based scheduling strategy\n */\nexport class CapabilitySchedulingStrategy implements SchedulingStrategy {\n  name = 'capability';\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    // Filter agents by capability match\n    const capableAgents = agents.filter((agent) => {\n      const capabilities = context.agentCapabilities.get(agent.id) || agent.capabilities;\n      return task.type === 'any' || capabilities.includes(task.type) || capabilities.includes('*');\n    });\n\n    if (capableAgents.length === 0) {\n      return null;\n    }\n\n    // Sort by load (ascending) and priority (descending)\n    capableAgents.sort((a, b) => {\n      const loadA = context.taskLoads.get(a.id) || 0;\n      const loadB = context.taskLoads.get(b.id) || 0;\n\n      if (loadA !== loadB) {\n        return loadA - loadB;\n      }\n\n      const priorityA = context.agentPriorities.get(a.id) || a.priority;\n      const priorityB = context.agentPriorities.get(b.id) || b.priority;\n\n      return priorityB - priorityA;\n    });\n\n    return capableAgents[0].id;\n  }\n}\n\n/**\n * Round-robin scheduling strategy\n */\nexport class RoundRobinSchedulingStrategy implements SchedulingStrategy {\n  name = 'round-robin';\n  private lastIndex = 0;\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    if (agents.length === 0) {\n      return null;\n    }\n\n    this.lastIndex = (this.lastIndex + 1) % agents.length;\n    return agents[this.lastIndex].id;\n  }\n}\n\n/**\n * Least-loaded scheduling strategy\n */\nexport class LeastLoadedSchedulingStrategy implements SchedulingStrategy {\n  name = 'least-loaded';\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    if (agents.length === 0) {\n      return null;\n    }\n\n    let minLoad = Infinity;\n    let selectedAgent: string | null = null;\n\n    for (const agent of agents) {\n      const load = context.taskLoads.get(agent.id) || 0;\n      if (load < minLoad) {\n        minLoad = load;\n        selectedAgent = agent.id;\n      }\n    }\n\n    return selectedAgent;\n  }\n}\n\n/**\n * Affinity-based scheduling strategy (prefers agents that previously executed similar tasks)\n */\nexport class AffinitySchedulingStrategy implements SchedulingStrategy {\n  name = 'affinity';\n\n  selectAgent(task: Task, agents: AgentProfile[], context: SchedulingContext): string | null {\n    const taskStats = context.taskHistory.get(task.type);\n\n    if (taskStats?.lastAgent) {\n      // Check if the last agent is available\n      const lastAgent = agents.find((a) => a.id === taskStats.lastAgent);\n      if (lastAgent) {\n        const load = context.taskLoads.get(lastAgent.id) || 0;\n        // Use last agent if not overloaded\n        if (load < lastAgent.maxConcurrentTasks * 0.8) {\n          return lastAgent.id;\n        }\n      }\n    }\n\n    // Fall back to capability-based selection\n    return new CapabilitySchedulingStrategy().selectAgent(task, agents, context);\n  }\n}\n\n/**\n * Advanced task scheduler with multiple strategies\n */\nexport class AdvancedTaskScheduler extends TaskScheduler {\n  private strategies = new Map<string, SchedulingStrategy>();\n  private activeAgents = new Map<string, AgentProfile>();\n  private taskStats = new Map<string, TaskStats>();\n  private workStealing: WorkStealingCoordinator;\n  private dependencyGraph: DependencyGraph;\n  private circuitBreakers: CircuitBreakerManager;\n  private defaultStrategy = 'capability';\n\n  constructor(config: CoordinationConfig, eventBus: IEventBus, logger: ILogger) {\n    super(config, eventBus, logger);\n\n    // Initialize components\n    this.workStealing = new WorkStealingCoordinator(\n      {\n        enabled: true,\n        stealThreshold: 3,\n        maxStealBatch: 2,\n        stealInterval: 5000,\n      },\n      eventBus,\n      logger,\n    );\n\n    this.dependencyGraph = new DependencyGraph(logger);\n\n    const cbConfig: CircuitBreakerConfig = {\n      failureThreshold: 3,\n      successThreshold: 2,\n      timeout: 30000,\n      halfOpenLimit: 1,\n    };\n    this.circuitBreakers = new CircuitBreakerManager(cbConfig, logger, eventBus);\n\n    // Register default strategies\n    this.registerStrategy(new CapabilitySchedulingStrategy());\n    this.registerStrategy(new RoundRobinSchedulingStrategy());\n    this.registerStrategy(new LeastLoadedSchedulingStrategy());\n    this.registerStrategy(new AffinitySchedulingStrategy());\n\n    // Set up event handlers\n    this.setupAdvancedEventHandlers();\n  }\n\n  override async initialize(): Promise<void> {\n    await super.initialize();\n    await this.workStealing.initialize();\n\n    this.logger.info('Advanced task scheduler initialized');\n  }\n\n  override async shutdown(): Promise<void> {\n    await this.workStealing.shutdown();\n    await super.shutdown();\n  }\n\n  /**\n   * Register a scheduling strategy\n   */\n  registerStrategy(strategy: SchedulingStrategy): void {\n    this.strategies.set(strategy.name, strategy);\n    this.logger.info('Registered scheduling strategy', { name: strategy.name });\n  }\n\n  /**\n   * Set the default scheduling strategy\n   */\n  setDefaultStrategy(name: string): void {\n    if (!this.strategies.has(name)) {\n      throw new Error(`Strategy not found: ${name}`);\n    }\n    this.defaultStrategy = name;\n  }\n\n  /**\n   * Register an agent\n   */\n  registerAgent(profile: AgentProfile): void {\n    this.activeAgents.set(profile.id, profile);\n    this.workStealing.updateAgentWorkload(profile.id, {\n      agentId: profile.id,\n      taskCount: 0,\n      avgTaskDuration: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      priority: profile.priority,\n      capabilities: profile.capabilities,\n    });\n  }\n\n  /**\n   * Unregister an agent\n   */\n  unregisterAgent(agentId: string): void {\n    this.activeAgents.delete(agentId);\n  }\n\n  /**\n   * Override assignTask to use advanced scheduling\n   */\n  override async assignTask(task: Task, agentId?: string): Promise<void> {\n    // Add to dependency graph\n    this.dependencyGraph.addTask(task);\n\n    // If no agent specified, select one\n    if (!agentId) {\n      const selectedAgent = await this.selectAgentForTask(task);\n      if (!selectedAgent) {\n        throw new Error('No suitable agent found for task');\n      }\n      agentId = selectedAgent;\n    }\n\n    // Use circuit breaker for assignment\n    await this.circuitBreakers.execute(`assign-${agentId}`, async () => {\n      await super.assignTask(task, agentId!);\n    });\n\n    // Update work stealing metrics\n    const taskCount = await this.getAgentTaskCount(agentId);\n    this.workStealing.updateAgentWorkload(agentId, { taskCount });\n  }\n\n  /**\n   * Select the best agent for a task\n   */\n  private async selectAgentForTask(task: Task): Promise<string | null> {\n    const availableAgents = Array.from(this.activeAgents.values());\n    if (availableAgents.length === 0) {\n      return null;\n    }\n\n    // Build scheduling context\n    const context: SchedulingContext = {\n      taskLoads: new Map(),\n      agentCapabilities: new Map(),\n      agentPriorities: new Map(),\n      taskHistory: this.taskStats,\n      currentTime: new Date(),\n    };\n\n    // Populate context\n    for (const agent of availableAgents) {\n      const taskCount = await this.getAgentTaskCount(agent.id);\n      context.taskLoads.set(agent.id, taskCount);\n      context.agentCapabilities.set(agent.id, agent.capabilities);\n      context.agentPriorities.set(agent.id, agent.priority);\n    }\n\n    // Try work stealing first\n    const workStealingAgent = this.workStealing.findBestAgent(task, availableAgents);\n    if (workStealingAgent) {\n      return workStealingAgent;\n    }\n\n    // Use configured strategy\n    const strategy = this.strategies.get(this.defaultStrategy);\n    if (!strategy) {\n      throw new Error(`Strategy not found: ${this.defaultStrategy}`);\n    }\n\n    return strategy.selectAgent(task, availableAgents, context);\n  }\n\n  /**\n   * Override completeTask to update stats and dependency graph\n   */\n  override async completeTask(taskId: string, result: unknown): Promise<void> {\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task not found: ${taskId}`);\n    }\n\n    // Calculate duration\n    const duration = task.startedAt ? new Date().getTime() - task.startedAt.getTime() : 0;\n\n    // Update task stats\n    this.updateTaskStats(task.type, true, duration);\n\n    // Update work stealing metrics\n    if (task.assignedAgent) {\n      this.workStealing.recordTaskDuration(task.assignedAgent, duration);\n    }\n\n    // Mark as completed in dependency graph\n    const readyTasks = this.dependencyGraph.markCompleted(taskId);\n\n    // Complete the task\n    await super.completeTask(taskId, result);\n\n    // Start ready tasks\n    for (const readyTaskId of readyTasks) {\n      const readyTask = await this.getTask(readyTaskId);\n      if (readyTask) {\n        this.eventBus.emit(SystemEvents.TASK_CREATED, { task: readyTask });\n      }\n    }\n  }\n\n  /**\n   * Override failTask to update stats and dependency graph\n   */\n  override async failTask(taskId: string, error: Error): Promise<void> {\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task not found: ${taskId}`);\n    }\n\n    // Update task stats\n    this.updateTaskStats(task.type, false, 0);\n\n    // Mark as failed in dependency graph\n    const toCancelIds = this.dependencyGraph.markFailed(taskId);\n\n    // Fail the task\n    await super.failTask(taskId, error);\n\n    // Cancel dependent tasks\n    for (const cancelId of toCancelIds) {\n      await this.cancelTask(cancelId, 'Parent task failed');\n    }\n  }\n\n  /**\n   * Get a task by ID (helper method)\n   */\n  private async getTask(taskId: string): Promise<Task | null> {\n    // This would need to be implemented based on how tasks are stored\n    // For now, return null\n    return null;\n  }\n\n  /**\n   * Update task statistics\n   */\n  private updateTaskStats(taskType: string, success: boolean, duration: number): void {\n    const stats = this.taskStats.get(taskType) || {\n      totalExecutions: 0,\n      avgDuration: 0,\n      successRate: 0,\n    };\n\n    stats.totalExecutions++;\n\n    if (success) {\n      const successCount = Math.round(stats.successRate * (stats.totalExecutions - 1));\n      stats.successRate = (successCount + 1) / stats.totalExecutions;\n\n      if (duration > 0) {\n        const totalDuration = stats.avgDuration * (stats.totalExecutions - 1);\n        stats.avgDuration = (totalDuration + duration) / stats.totalExecutions;\n      }\n    } else {\n      const successCount = Math.round(stats.successRate * (stats.totalExecutions - 1));\n      stats.successRate = successCount / stats.totalExecutions;\n    }\n\n    this.taskStats.set(taskType, stats);\n  }\n\n  /**\n   * Set up advanced event handlers\n   */\n  private setupAdvancedEventHandlers(): void {\n    // Handle work stealing requests\n    this.eventBus.on('workstealing:request', async (data: any) => {\n      const { sourceAgent, targetAgent, taskCount } = data;\n\n      try {\n        const tasks = await this.getAgentTasks(sourceAgent);\n        const tasksToSteal = tasks\n          .filter((t) => t.status === 'queued' || t.status === 'assigned')\n          .slice(0, taskCount);\n\n        for (const task of tasksToSteal) {\n          await this.reassignTask(task.id, targetAgent);\n        }\n\n        this.logger.info('Work stealing completed', {\n          from: sourceAgent,\n          to: targetAgent,\n          stolenCount: tasksToSteal.length,\n        });\n      } catch (error) {\n        this.logger.error('Work stealing failed', { error });\n      }\n    });\n\n    // Update workload on task events\n    this.eventBus.on(SystemEvents.TASK_ASSIGNED, async (data: any) => {\n      const { agentId } = data;\n      const taskCount = await this.getAgentTaskCount(agentId);\n      this.workStealing.updateAgentWorkload(agentId, { taskCount });\n    });\n\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: any) => {\n      const { taskId } = data;\n      // Update workload after task completion\n      // This would need the agent ID from the task\n    });\n  }\n\n  /**\n   * Reassign a task to a different agent\n   */\n  private async reassignTask(taskId: string, newAgentId: string): Promise<void> {\n    // Cancel the current assignment\n    await this.cancelTask(taskId, 'Reassigning to different agent');\n\n    // Get the task\n    const task = await this.getTask(taskId);\n    if (!task) {\n      throw new Error(`Task not found: ${taskId}`);\n    }\n\n    // Assign to new agent\n    await this.assignTask(task, newAgentId);\n  }\n\n  /**\n   * Get advanced scheduling metrics\n   */\n  async getSchedulingMetrics(): Promise<Record<string, unknown>> {\n    const baseMetrics = await this.getHealthStatus();\n    const workloadStats = this.workStealing.getWorkloadStats();\n    const depGraphStats = this.dependencyGraph.getStats();\n    const cbMetrics = this.circuitBreakers.getAllMetrics();\n\n    return {\n      ...baseMetrics.metrics,\n      workStealing: workloadStats,\n      dependencies: depGraphStats,\n      circuitBreakers: cbMetrics,\n      taskStats: Object.fromEntries(this.taskStats),\n      activeStrategies: Array.from(this.strategies.keys()),\n      defaultStrategy: this.defaultStrategy,\n    };\n  }\n}\n"],"names":["SystemEvents","TaskScheduler","WorkStealingCoordinator","DependencyGraph","CircuitBreakerManager","CapabilitySchedulingStrategy","name","selectAgent","task","agents","context","capableAgents","filter","agent","capabilities","agentCapabilities","get","id","type","includes","length","sort","a","b","loadA","taskLoads","loadB","priorityA","agentPriorities","priority","priorityB","RoundRobinSchedulingStrategy","lastIndex","LeastLoadedSchedulingStrategy","minLoad","Infinity","selectedAgent","load","AffinitySchedulingStrategy","taskStats","taskHistory","lastAgent","find","maxConcurrentTasks","AdvancedTaskScheduler","strategies","Map","activeAgents","workStealing","dependencyGraph","circuitBreakers","defaultStrategy","config","eventBus","logger","enabled","stealThreshold","maxStealBatch","stealInterval","cbConfig","failureThreshold","successThreshold","timeout","halfOpenLimit","registerStrategy","setupAdvancedEventHandlers","initialize","info","shutdown","strategy","set","setDefaultStrategy","has","Error","registerAgent","profile","updateAgentWorkload","agentId","taskCount","avgTaskDuration","cpuUsage","memoryUsage","unregisterAgent","delete","assignTask","addTask","selectAgentForTask","execute","getAgentTaskCount","availableAgents","Array","from","values","currentTime","Date","workStealingAgent","findBestAgent","completeTask","taskId","result","getTask","duration","startedAt","getTime","updateTaskStats","assignedAgent","recordTaskDuration","readyTasks","markCompleted","readyTaskId","readyTask","emit","TASK_CREATED","failTask","error","toCancelIds","markFailed","cancelId","cancelTask","taskType","success","stats","totalExecutions","avgDuration","successRate","successCount","Math","round","totalDuration","on","data","sourceAgent","targetAgent","tasks","getAgentTasks","tasksToSteal","t","status","slice","reassignTask","to","stolenCount","TASK_ASSIGNED","TASK_COMPLETED","newAgentId","getSchedulingMetrics","baseMetrics","getHealthStatus","workloadStats","getWorkloadStats","depGraphStats","getStats","cbMetrics","getAllMetrics","metrics","dependencies","Object","fromEntries","activeStrategies","keys"],"mappings":"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"}