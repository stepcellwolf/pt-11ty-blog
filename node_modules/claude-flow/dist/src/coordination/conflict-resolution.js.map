{"version":3,"sources":["../../../src/coordination/conflict-resolution.ts"],"sourcesContent":["/**\n * Conflict resolution mechanisms for multi-agent coordination\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { Task, Resource } from '../utils/types.js';\n\nexport interface ResourceConflict {\n  id: string;\n  resourceId: string;\n  agents: string[];\n  timestamp: Date;\n  resolved: boolean;\n  resolution?: ConflictResolution;\n}\n\nexport interface TaskConflict {\n  id: string;\n  taskId: string;\n  agents: string[];\n  type: 'assignment' | 'dependency' | 'output';\n  timestamp: Date;\n  resolved: boolean;\n  resolution?: ConflictResolution;\n}\n\nexport interface ConflictResolution {\n  type: 'priority' | 'timestamp' | 'vote' | 'manual' | 'retry';\n  winner?: string;\n  losers?: string[];\n  reason: string;\n  timestamp: Date;\n}\n\nexport interface ConflictResolutionStrategy {\n  name: string;\n  resolve(conflict: ResourceConflict | TaskConflict, context: any): Promise<ConflictResolution>;\n}\n\n/**\n * Priority-based resolution strategy\n */\nexport class PriorityResolutionStrategy implements ConflictResolutionStrategy {\n  name = 'priority';\n\n  async resolve(\n    conflict: ResourceConflict | TaskConflict,\n    context: { agentPriorities: Map<string, number> },\n  ): Promise<ConflictResolution> {\n    const priorities = conflict.agents.map((agentId) => ({\n      agentId,\n      priority: context.agentPriorities.get(agentId) || 0,\n    }));\n\n    // Sort by priority (descending)\n    priorities.sort((a, b) => b.priority - a.priority);\n\n    const winner = priorities[0].agentId;\n    const losers = priorities.slice(1).map((p) => p.agentId);\n\n    return {\n      type: 'priority',\n      winner,\n      losers,\n      reason: `Agent ${winner} has highest priority (${priorities[0].priority})`,\n      timestamp: new Date(),\n    };\n  }\n}\n\n/**\n * First-come-first-served resolution strategy\n */\nexport class TimestampResolutionStrategy implements ConflictResolutionStrategy {\n  name = 'timestamp';\n\n  async resolve(\n    conflict: ResourceConflict | TaskConflict,\n    context: { requestTimestamps: Map<string, Date> },\n  ): Promise<ConflictResolution> {\n    const timestamps = conflict.agents.map((agentId) => ({\n      agentId,\n      timestamp: context.requestTimestamps.get(agentId) || new Date(),\n    }));\n\n    // Sort by timestamp (ascending - earliest first)\n    timestamps.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    const winner = timestamps[0].agentId;\n    const losers = timestamps.slice(1).map((t) => t.agentId);\n\n    return {\n      type: 'timestamp',\n      winner,\n      losers,\n      reason: `Agent ${winner} made the earliest request`,\n      timestamp: new Date(),\n    };\n  }\n}\n\n/**\n * Voting-based resolution strategy (for multi-agent consensus)\n */\nexport class VotingResolutionStrategy implements ConflictResolutionStrategy {\n  name = 'vote';\n\n  async resolve(\n    conflict: ResourceConflict | TaskConflict,\n    context: { votes: Map<string, string[]> }, // agentId -> votes for that agent\n  ): Promise<ConflictResolution> {\n    const voteCounts = new Map<string, number>();\n\n    // Count votes\n    for (const [agentId, voters] of context.votes) {\n      voteCounts.set(agentId, voters.length);\n    }\n\n    // Find winner\n    let maxVotes = 0;\n    let winner = '';\n    const losers: string[] = [];\n\n    for (const [agentId, votes] of voteCounts) {\n      if (votes > maxVotes) {\n        if (winner) {\n          losers.push(winner);\n        }\n        maxVotes = votes;\n        winner = agentId;\n      } else {\n        losers.push(agentId);\n      }\n    }\n\n    return {\n      type: 'vote',\n      winner,\n      losers,\n      reason: `Agent ${winner} received the most votes (${maxVotes})`,\n      timestamp: new Date(),\n    };\n  }\n}\n\n/**\n * Conflict resolution manager\n */\nexport class ConflictResolver {\n  private strategies = new Map<string, ConflictResolutionStrategy>();\n  private conflicts = new Map<string, ResourceConflict | TaskConflict>();\n  private resolutionHistory: ConflictResolution[] = [];\n\n  constructor(\n    private logger: ILogger,\n    private eventBus: IEventBus,\n  ) {\n    // Register default strategies\n    this.registerStrategy(new PriorityResolutionStrategy());\n    this.registerStrategy(new TimestampResolutionStrategy());\n    this.registerStrategy(new VotingResolutionStrategy());\n  }\n\n  /**\n   * Register a conflict resolution strategy\n   */\n  registerStrategy(strategy: ConflictResolutionStrategy): void {\n    this.strategies.set(strategy.name, strategy);\n    this.logger.info('Registered conflict resolution strategy', { name: strategy.name });\n  }\n\n  /**\n   * Report a resource conflict\n   */\n  async reportResourceConflict(resourceId: string, agents: string[]): Promise<ResourceConflict> {\n    const conflict: ResourceConflict = {\n      id: `conflict-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      resourceId,\n      agents,\n      timestamp: new Date(),\n      resolved: false,\n    };\n\n    this.conflicts.set(conflict.id, conflict);\n    this.logger.warn('Resource conflict reported', conflict);\n\n    // Emit conflict event\n    this.eventBus.emit('conflict:resource', conflict);\n\n    return conflict;\n  }\n\n  /**\n   * Report a task conflict\n   */\n  async reportTaskConflict(\n    taskId: string,\n    agents: string[],\n    type: TaskConflict['type'],\n  ): Promise<TaskConflict> {\n    const conflict: TaskConflict = {\n      id: `conflict-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      taskId,\n      agents,\n      type,\n      timestamp: new Date(),\n      resolved: false,\n    };\n\n    this.conflicts.set(conflict.id, conflict);\n    this.logger.warn('Task conflict reported', conflict);\n\n    // Emit conflict event\n    this.eventBus.emit('conflict:task', conflict);\n\n    return conflict;\n  }\n\n  /**\n   * Resolve a conflict using a specific strategy\n   */\n  async resolveConflict(\n    conflictId: string,\n    strategyName: string,\n    context: any,\n  ): Promise<ConflictResolution> {\n    const conflict = this.conflicts.get(conflictId);\n    if (!conflict) {\n      throw new Error(`Conflict not found: ${conflictId}`);\n    }\n\n    if (conflict.resolved) {\n      throw new Error(`Conflict already resolved: ${conflictId}`);\n    }\n\n    const strategy = this.strategies.get(strategyName);\n    if (!strategy) {\n      throw new Error(`Strategy not found: ${strategyName}`);\n    }\n\n    // Resolve the conflict\n    const resolution = await strategy.resolve(conflict, context);\n\n    // Update conflict\n    conflict.resolved = true;\n    conflict.resolution = resolution;\n\n    // Store in history\n    this.resolutionHistory.push(resolution);\n\n    // Emit resolution event\n    this.eventBus.emit('conflict:resolved', {\n      conflict,\n      resolution,\n    });\n\n    this.logger.info('Conflict resolved', {\n      conflictId,\n      strategy: strategyName,\n      resolution,\n    });\n\n    return resolution;\n  }\n\n  /**\n   * Auto-resolve conflicts based on configuration\n   */\n  async autoResolve(\n    conflictId: string,\n    preferredStrategy: string = 'priority',\n  ): Promise<ConflictResolution> {\n    const conflict = this.conflicts.get(conflictId);\n    if (!conflict) {\n      throw new Error(`Conflict not found: ${conflictId}`);\n    }\n\n    // Build context based on conflict type\n    const context: any = {};\n\n    if (preferredStrategy === 'priority') {\n      // In a real implementation, fetch agent priorities from configuration\n      context.agentPriorities = new Map(\n        conflict.agents.map((id, index) => [id, conflict.agents.length - index]),\n      );\n    } else if (preferredStrategy === 'timestamp') {\n      // In a real implementation, fetch request timestamps\n      context.requestTimestamps = new Map(\n        conflict.agents.map((id, index) => [id, new Date(Date.now() - index * 1000)]),\n      );\n    }\n\n    return this.resolveConflict(conflictId, preferredStrategy, context);\n  }\n\n  /**\n   * Get active conflicts\n   */\n  getActiveConflicts(): Array<ResourceConflict | TaskConflict> {\n    return Array.from(this.conflicts.values()).filter((c) => !c.resolved);\n  }\n\n  /**\n   * Get conflict history\n   */\n  getConflictHistory(limit?: number): ConflictResolution[] {\n    if (limit) {\n      return this.resolutionHistory.slice(-limit);\n    }\n    return [...this.resolutionHistory];\n  }\n\n  /**\n   * Clear resolved conflicts older than a certain age\n   */\n  cleanupOldConflicts(maxAgeMs: number): number {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [id, conflict] of this.conflicts) {\n      if (conflict.resolved && now - conflict.timestamp.getTime() > maxAgeMs) {\n        this.conflicts.delete(id);\n        removed++;\n      }\n    }\n\n    // Also cleanup old history\n    const cutoffTime = now - maxAgeMs;\n    this.resolutionHistory = this.resolutionHistory.filter(\n      (r) => r.timestamp.getTime() > cutoffTime,\n    );\n\n    return removed;\n  }\n\n  /**\n   * Get conflict statistics\n   */\n  getStats(): Record<string, unknown> {\n    const stats = {\n      totalConflicts: this.conflicts.size,\n      activeConflicts: 0,\n      resolvedConflicts: 0,\n      resolutionsByStrategy: {} as Record<string, number>,\n      conflictsByType: {\n        resource: 0,\n        task: 0,\n      },\n    };\n\n    for (const conflict of this.conflicts.values()) {\n      if (conflict.resolved) {\n        stats.resolvedConflicts++;\n\n        if (conflict.resolution) {\n          const strategy = conflict.resolution.type;\n          stats.resolutionsByStrategy[strategy] = (stats.resolutionsByStrategy[strategy] || 0) + 1;\n        }\n      } else {\n        stats.activeConflicts++;\n      }\n\n      if ('resourceId' in conflict) {\n        stats.conflictsByType.resource++;\n      } else {\n        stats.conflictsByType.task++;\n      }\n    }\n\n    return stats;\n  }\n}\n\n/**\n * Optimistic concurrency control for resource updates\n */\nexport class OptimisticLockManager {\n  private versions = new Map<string, number>();\n  private locks = new Map<string, { version: number; holder: string; timestamp: Date }>();\n\n  constructor(private logger: ILogger) {}\n\n  /**\n   * Acquire an optimistic lock\n   */\n  acquireLock(resourceId: string, agentId: string): number {\n    const currentVersion = this.versions.get(resourceId) || 0;\n\n    this.locks.set(resourceId, {\n      version: currentVersion,\n      holder: agentId,\n      timestamp: new Date(),\n    });\n\n    this.logger.debug('Optimistic lock acquired', {\n      resourceId,\n      agentId,\n      version: currentVersion,\n    });\n\n    return currentVersion;\n  }\n\n  /**\n   * Validate and update with optimistic lock\n   */\n  validateAndUpdate(resourceId: string, agentId: string, expectedVersion: number): boolean {\n    const currentVersion = this.versions.get(resourceId) || 0;\n    const lock = this.locks.get(resourceId);\n\n    // Check if versions match\n    if (currentVersion !== expectedVersion) {\n      this.logger.warn('Optimistic lock conflict', {\n        resourceId,\n        agentId,\n        expectedVersion,\n        currentVersion,\n      });\n      return false;\n    }\n\n    // Check if this agent holds the lock\n    if (!lock || lock.holder !== agentId) {\n      this.logger.warn('Agent does not hold lock', {\n        resourceId,\n        agentId,\n      });\n      return false;\n    }\n\n    // Update version\n    this.versions.set(resourceId, currentVersion + 1);\n    this.locks.delete(resourceId);\n\n    this.logger.debug('Optimistic update successful', {\n      resourceId,\n      agentId,\n      newVersion: currentVersion + 1,\n    });\n\n    return true;\n  }\n\n  /**\n   * Release a lock without updating\n   */\n  releaseLock(resourceId: string, agentId: string): void {\n    const lock = this.locks.get(resourceId);\n\n    if (lock && lock.holder === agentId) {\n      this.locks.delete(resourceId);\n      this.logger.debug('Optimistic lock released', {\n        resourceId,\n        agentId,\n      });\n    }\n  }\n\n  /**\n   * Clean up stale locks\n   */\n  cleanupStaleLocks(maxAgeMs: number): number {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [resourceId, lock] of this.locks) {\n      if (now - lock.timestamp.getTime() > maxAgeMs) {\n        this.locks.delete(resourceId);\n        removed++;\n\n        this.logger.warn('Removed stale lock', {\n          resourceId,\n          holder: lock.holder,\n          age: now - lock.timestamp.getTime(),\n        });\n      }\n    }\n\n    return removed;\n  }\n}\n"],"names":["PriorityResolutionStrategy","name","resolve","conflict","context","priorities","agents","map","agentId","priority","agentPriorities","get","sort","a","b","winner","losers","slice","p","type","reason","timestamp","Date","TimestampResolutionStrategy","timestamps","requestTimestamps","getTime","t","VotingResolutionStrategy","voteCounts","Map","voters","votes","set","length","maxVotes","push","ConflictResolver","strategies","conflicts","resolutionHistory","logger","eventBus","registerStrategy","strategy","info","reportResourceConflict","resourceId","id","now","Math","random","toString","substr","resolved","warn","emit","reportTaskConflict","taskId","resolveConflict","conflictId","strategyName","Error","resolution","autoResolve","preferredStrategy","index","getActiveConflicts","Array","from","values","filter","c","getConflictHistory","limit","cleanupOldConflicts","maxAgeMs","removed","delete","cutoffTime","r","getStats","stats","totalConflicts","size","activeConflicts","resolvedConflicts","resolutionsByStrategy","conflictsByType","resource","task","OptimisticLockManager","versions","locks","acquireLock","currentVersion","version","holder","debug","validateAndUpdate","expectedVersion","lock","newVersion","releaseLock","cleanupStaleLocks","age"],"mappings":"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"}