{"version":3,"sources":["../../../src/coordination/advanced-task-executor.ts"],"sourcesContent":["import { getErrorMessage, getErrorStack } from '../utils/type-guards.js';\n/**\n * Advanced task executor with timeout handling, retry logic, and resource management\n */\n\nimport { EventEmitter } from 'node:events';\nimport { spawn, ChildProcess } from 'node:child_process';\nimport type {\n  TaskDefinition,\n  TaskResult,\n  TaskStatus,\n  AgentState,\n  TaskError,\n} from '../swarm/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport { CircuitBreaker, CircuitBreakerManager } from './circuit-breaker.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface TaskExecutorConfig {\n  maxConcurrentTasks: number;\n  defaultTimeout: number;\n  retryAttempts: number;\n  retryBackoffBase: number;\n  retryBackoffMax: number;\n  resourceLimits: {\n    memory: number;\n    cpu: number;\n    disk: number;\n  };\n  enableCircuitBreaker: boolean;\n  enableResourceMonitoring: boolean;\n  killTimeout: number;\n}\n\nexport interface ExecutionContext {\n  taskId: string;\n  agentId: string;\n  process?: ChildProcess;\n  startTime: Date;\n  timeout?: NodeJS.Timeout;\n  resources: ResourceUsage;\n  circuitBreaker?: CircuitBreaker;\n}\n\nexport interface ResourceUsage {\n  memory: number;\n  cpu: number;\n  disk: number;\n  network: number;\n  lastUpdated: Date;\n}\n\nexport interface TaskExecutionResult {\n  success: boolean;\n  result?: TaskResult;\n  error?: TaskError;\n  executionTime: number;\n  resourcesUsed: ResourceUsage;\n  retryCount: number;\n}\n\n/**\n * Advanced task executor with comprehensive timeout and resource management\n */\nexport class AdvancedTaskExecutor extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: TaskExecutorConfig;\n  private runningTasks = new Map<string, ExecutionContext>();\n  private circuitBreakerManager: CircuitBreakerManager;\n  private resourceMonitor?: NodeJS.Timeout;\n  private queuedTasks: TaskDefinition[] = [];\n  private isShuttingDown = false;\n\n  constructor(config: Partial<TaskExecutorConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      maxConcurrentTasks: 10,\n      defaultTimeout: 300000, // 5 minutes\n      retryAttempts: 3,\n      retryBackoffBase: 1000,\n      retryBackoffMax: 30000,\n      resourceLimits: {\n        memory: 512 * 1024 * 1024, // 512MB\n        cpu: 1.0, // 1 CPU core\n        disk: 1024 * 1024 * 1024, // 1GB\n      },\n      enableCircuitBreaker: true,\n      enableResourceMonitoring: true,\n      killTimeout: 5000,\n      ...config,\n    };\n\n    // Initialize circuit breaker manager\n    this.circuitBreakerManager = new CircuitBreakerManager(\n      {\n        failureThreshold: 5,\n        successThreshold: 3,\n        timeout: 60000, // 1 minute\n        halfOpenLimit: 2,\n      },\n      this.logger,\n      this.eventBus,\n    );\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    // Handle process events\n    process.on('SIGTERM', () => this.gracefulShutdown());\n    process.on('SIGINT', () => this.gracefulShutdown());\n\n    // Handle circuit breaker events\n    this.eventBus.on('circuitbreaker:state-change', (event) => {\n      this.logger.info('Circuit breaker state changed', event);\n      this.emit('circuit-breaker-changed', event);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing advanced task executor', {\n      maxConcurrentTasks: this.config.maxConcurrentTasks,\n      defaultTimeout: this.config.defaultTimeout,\n      resourceLimits: this.config.resourceLimits,\n    });\n\n    if (this.config.enableResourceMonitoring) {\n      this.startResourceMonitoring();\n    }\n\n    this.emit('executor-initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down task executor');\n    this.isShuttingDown = true;\n\n    // Stop resource monitoring\n    if (this.resourceMonitor) {\n      clearInterval(this.resourceMonitor);\n    }\n\n    // Cancel all running tasks\n    const cancelPromises = Array.from(this.runningTasks.values()).map((ctx) =>\n      this.cancelTask(ctx.taskId, 'Shutdown requested'),\n    );\n\n    await Promise.all(cancelPromises);\n\n    this.emit('executor-shutdown');\n  }\n\n  /**\n   * Execute a task with comprehensive error handling and resource management\n   */\n  async executeTask(\n    task: TaskDefinition,\n    agent: AgentState,\n    options: {\n      timeout?: number;\n      retryAttempts?: number;\n      priority?: number;\n    } = {},\n  ): Promise<TaskExecutionResult> {\n    const startTime = Date.now();\n    let retryCount = 0;\n    const maxRetries = options.retryAttempts ?? this.config.retryAttempts;\n    const timeout = options.timeout ?? this.config.defaultTimeout;\n\n    this.logger.info('Starting task execution', {\n      taskId: task.id.id,\n      agentId: agent.id.id,\n      type: task.type,\n      timeout,\n      maxRetries,\n    });\n\n    // Check if we have capacity\n    if (this.runningTasks.size >= this.config.maxConcurrentTasks) {\n      this.queuedTasks.push(task);\n      this.logger.info('Task queued due to capacity limits', {\n        taskId: task.id.id,\n        queueSize: this.queuedTasks.length,\n      });\n\n      // Wait for capacity\n      await this.waitForCapacity();\n    }\n\n    while (retryCount <= maxRetries) {\n      try {\n        const result = await this.executeSingleAttempt(task, agent, timeout, retryCount);\n\n        this.logger.info('Task completed successfully', {\n          taskId: task.id.id,\n          executionTime: Date.now() - startTime,\n          retryCount,\n        });\n\n        return {\n          success: true,\n          result: result.result,\n          executionTime: Date.now() - startTime,\n          resourcesUsed: result.resourcesUsed,\n          retryCount,\n        };\n      } catch (error) {\n        retryCount++;\n\n        this.logger.warn('Task attempt failed', {\n          taskId: task.id.id,\n          attempt: retryCount,\n          maxRetries,\n          error: getErrorMessage(error),\n        });\n\n        // Check if we should retry\n        if (retryCount > maxRetries) {\n          const taskError: TaskError = {\n            type: 'execution_failed',\n            message: getErrorMessage(error),\n            stack: getErrorStack(error),\n            context: {\n              retryCount,\n              maxRetries,\n              taskType: task.type,\n            },\n            recoverable: false,\n            retryable: false,\n          };\n\n          return {\n            success: false,\n            error: taskError,\n            executionTime: Date.now() - startTime,\n            resourcesUsed: this.getDefaultResourceUsage(),\n            retryCount,\n          };\n        }\n\n        // Calculate backoff delay\n        const backoffDelay = Math.min(\n          this.config.retryBackoffBase * Math.pow(2, retryCount - 1),\n          this.config.retryBackoffMax,\n        );\n\n        this.logger.info('Retrying task after backoff', {\n          taskId: task.id.id,\n          backoffDelay,\n          attempt: retryCount + 1,\n        });\n\n        await this.delay(backoffDelay);\n      }\n    }\n\n    // This should never be reached, but TypeScript requires it\n    throw new Error('Unexpected end of retry loop');\n  }\n\n  private async executeSingleAttempt(\n    task: TaskDefinition,\n    agent: AgentState,\n    timeout: number,\n    retryCount: number,\n  ): Promise<{ result: TaskResult; resourcesUsed: ResourceUsage }> {\n    const executionContext: ExecutionContext = {\n      taskId: task.id.id,\n      agentId: agent.id.id,\n      startTime: new Date(),\n      resources: this.getDefaultResourceUsage(),\n    };\n\n    this.runningTasks.set(task.id.id, executionContext);\n\n    try {\n      // Set up timeout\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        executionContext.timeout = setTimeout(() => {\n          reject(new Error(`Task timeout after ${timeout}ms`));\n        }, timeout);\n      });\n\n      // Set up circuit breaker if enabled\n      if (this.config.enableCircuitBreaker) {\n        executionContext.circuitBreaker = this.circuitBreakerManager.getBreaker(\n          `agent-${agent.id.id}`,\n        );\n      }\n\n      // Execute task with circuit breaker protection\n      const executionPromise =\n        this.config.enableCircuitBreaker && executionContext.circuitBreaker\n          ? executionContext.circuitBreaker.execute(() =>\n              this.performTaskExecution(task, agent, executionContext),\n            )\n          : this.performTaskExecution(task, agent, executionContext);\n\n      // Race between execution and timeout\n      const result = await Promise.race([executionPromise, timeoutPromise]);\n\n      // Clear timeout\n      if (executionContext.timeout) {\n        clearTimeout(executionContext.timeout);\n      }\n\n      return result;\n    } finally {\n      // Cleanup\n      this.runningTasks.delete(task.id.id);\n\n      // Process queued tasks\n      this.processQueuedTasks();\n    }\n  }\n\n  private async performTaskExecution(\n    task: TaskDefinition,\n    agent: AgentState,\n    context: ExecutionContext,\n  ): Promise<{ result: TaskResult; resourcesUsed: ResourceUsage }> {\n    const startTime = Date.now();\n\n    // Create task execution command\n    const command = this.buildExecutionCommand(task, agent);\n\n    this.logger.debug('Executing task command', {\n      taskId: task.id.id,\n      command: command.cmd,\n      args: command.args,\n    });\n\n    // Spawn process\n    const childProcess = spawn(command.cmd, command.args, {\n      stdio: ['pipe', 'pipe', 'pipe'],\n      env: {\n        ...process.env,\n        ...command.env,\n        TASK_ID: task.id.id,\n        AGENT_ID: agent.id.id,\n        TASK_TYPE: task.type,\n      },\n    });\n\n    context.process = childProcess;\n\n    // Collect output\n    let stdout = '';\n    let stderr = '';\n\n    childProcess.stdout?.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    childProcess.stderr?.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    // Send input if provided\n    if (task.input && childProcess.stdin) {\n      childProcess.stdin.write(\n        JSON.stringify({\n          task: task,\n          agent: agent,\n          input: task.input,\n        }),\n      );\n      childProcess.stdin.end();\n    }\n\n    // Wait for process completion\n    const exitCode = await new Promise<number>((resolve, reject) => {\n      childProcess.on('exit', (code) => {\n        resolve(code ?? 0);\n      });\n\n      childProcess.on('error', (error) => {\n        reject(new Error(`Process error: ${getErrorMessage(error)}`));\n      });\n    });\n\n    const executionTime = Date.now() - startTime;\n\n    // Parse result\n    let taskResult: TaskResult;\n\n    if (exitCode === 0) {\n      try {\n        const output = JSON.parse(stdout);\n        taskResult = {\n          output: output.result || output,\n          artifacts: output.artifacts || {},\n          metadata: output.metadata || {},\n          quality: output.quality || 0.8,\n          completeness: output.completeness || 1.0,\n          accuracy: output.accuracy || 0.9,\n          executionTime,\n          resourcesUsed: context.resources,\n          validated: false,\n        };\n      } catch (error) {\n        taskResult = {\n          output: stdout,\n          artifacts: {},\n          metadata: { stderr },\n          quality: 0.5,\n          completeness: 1.0,\n          accuracy: 0.7,\n          executionTime,\n          resourcesUsed: context.resources,\n          validated: false,\n        };\n      }\n    } else {\n      throw new Error(`Task execution failed with exit code ${exitCode}: ${stderr}`);\n    }\n\n    return {\n      result: taskResult,\n      resourcesUsed: context.resources,\n    };\n  }\n\n  private buildExecutionCommand(\n    task: TaskDefinition,\n    agent: AgentState,\n  ): {\n    cmd: string;\n    args: string[];\n    env: Record<string, string>;\n  } {\n    // This would be customized based on task type and agent capabilities\n    // For now, return a default Claude execution command\n\n    const cmd = 'deno';\n    const args = [\n      'run',\n      '--allow-all',\n      '--no-check',\n      './src/cli/commands/task-executor.ts',\n      '--task-type',\n      task.type,\n      '--agent-type',\n      agent.type,\n    ];\n\n    const env = {\n      TASK_TIMEOUT: (task.constraints.timeoutAfter || this.config.defaultTimeout).toString(),\n      MEMORY_LIMIT: this.config.resourceLimits.memory.toString(),\n      CPU_LIMIT: this.config.resourceLimits.cpu.toString(),\n    };\n\n    return { cmd, args, env };\n  }\n\n  private async cancelTask(taskId: string, reason: string): Promise<void> {\n    const context = this.runningTasks.get(taskId);\n    if (!context) {\n      return;\n    }\n\n    this.logger.info('Cancelling task', { taskId, reason });\n\n    // Clear timeout\n    if (context.timeout) {\n      clearTimeout(context.timeout);\n    }\n\n    // Kill process if running\n    if (context.process && !context.process.killed) {\n      context.process.kill('SIGTERM');\n\n      // Force kill after timeout\n      setTimeout(() => {\n        if (context.process && !context.process.killed) {\n          context.process.kill('SIGKILL');\n        }\n      }, this.config.killTimeout);\n    }\n\n    // Remove from running tasks\n    this.runningTasks.delete(taskId);\n\n    this.emit('task-cancelled', { taskId, reason });\n  }\n\n  private startResourceMonitoring(): void {\n    this.resourceMonitor = setInterval(() => {\n      this.updateResourceUsage();\n    }, 5000); // Update every 5 seconds\n  }\n\n  private async updateResourceUsage(): Promise<void> {\n    for (const [taskId, context] of this.runningTasks) {\n      if (context.process) {\n        try {\n          const usage = await this.getProcessResourceUsage(context.process.pid);\n          context.resources = {\n            ...usage,\n            lastUpdated: new Date(),\n          };\n\n          // Check resource limits\n          this.checkResourceLimits(taskId, context);\n        } catch (error) {\n          this.logger.warn('Failed to get resource usage', {\n            taskId,\n            error: getErrorMessage(error),\n          });\n        }\n      }\n    }\n  }\n\n  private async getProcessResourceUsage(pid: number | undefined): Promise<ResourceUsage> {\n    if (!pid) {\n      throw new Error('Process ID is undefined');\n    }\n    // In a real implementation, this would use system APIs\n    // For now, return mock data\n    return {\n      memory: Math.random() * this.config.resourceLimits.memory,\n      cpu: Math.random() * 100,\n      disk: Math.random() * this.config.resourceLimits.disk,\n      network: Math.random() * 1024 * 1024,\n      lastUpdated: new Date(),\n    };\n  }\n\n  private checkResourceLimits(taskId: string, context: ExecutionContext): void {\n    const { memory, cpu } = context.resources;\n    const limits = this.config.resourceLimits;\n\n    if (memory > limits.memory) {\n      this.logger.warn('Task exceeding memory limit', {\n        taskId,\n        current: memory,\n        limit: limits.memory,\n      });\n\n      this.cancelTask(taskId, 'Memory limit exceeded');\n    }\n\n    if (cpu > limits.cpu * 100) {\n      // CPU is in percentage\n      this.logger.warn('Task exceeding CPU limit', {\n        taskId,\n        current: cpu,\n        limit: limits.cpu * 100,\n      });\n    }\n  }\n\n  private getDefaultResourceUsage(): ResourceUsage {\n    return {\n      memory: 0,\n      cpu: 0,\n      disk: 0,\n      network: 0,\n      lastUpdated: new Date(),\n    };\n  }\n\n  private async waitForCapacity(): Promise<void> {\n    return new Promise((resolve) => {\n      const check = () => {\n        if (this.runningTasks.size < this.config.maxConcurrentTasks) {\n          resolve();\n        } else {\n          setTimeout(check, 1000);\n        }\n      };\n      check();\n    });\n  }\n\n  private processQueuedTasks(): void {\n    while (this.queuedTasks.length > 0 && this.runningTasks.size < this.config.maxConcurrentTasks) {\n      const task = this.queuedTasks.shift();\n      if (task) {\n        this.emit('task-dequeued', { taskId: task.id.id });\n      }\n    }\n  }\n\n  private async delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  private async gracefulShutdown(): Promise<void> {\n    this.logger.info('Received shutdown signal, initiating graceful shutdown');\n    await this.shutdown();\n    process.exit(0);\n  }\n\n  // Public API methods\n\n  getRunningTasks(): string[] {\n    return Array.from(this.runningTasks.keys());\n  }\n\n  getTaskContext(taskId: string): ExecutionContext | undefined {\n    return this.runningTasks.get(taskId);\n  }\n\n  getQueuedTasks(): TaskDefinition[] {\n    return [...this.queuedTasks];\n  }\n\n  getExecutorStats(): {\n    runningTasks: number;\n    queuedTasks: number;\n    maxConcurrentTasks: number;\n    totalCapacity: number;\n    resourceLimits: typeof this.config.resourceLimits;\n    circuitBreakers: Record<string, any>;\n  } {\n    return {\n      runningTasks: this.runningTasks.size,\n      queuedTasks: this.queuedTasks.length,\n      maxConcurrentTasks: this.config.maxConcurrentTasks,\n      totalCapacity: this.config.maxConcurrentTasks,\n      resourceLimits: this.config.resourceLimits,\n      circuitBreakers: this.circuitBreakerManager.getAllMetrics(),\n    };\n  }\n\n  async forceKillTask(taskId: string): Promise<void> {\n    await this.cancelTask(taskId, 'Force killed by user');\n  }\n\n  updateConfig(newConfig: Partial<TaskExecutorConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.logger.info('Task executor configuration updated', { newConfig });\n  }\n}\n"],"names":["getErrorMessage","getErrorStack","EventEmitter","spawn","CircuitBreakerManager","AdvancedTaskExecutor","logger","eventBus","config","runningTasks","Map","circuitBreakerManager","resourceMonitor","queuedTasks","isShuttingDown","maxConcurrentTasks","defaultTimeout","retryAttempts","retryBackoffBase","retryBackoffMax","resourceLimits","memory","cpu","disk","enableCircuitBreaker","enableResourceMonitoring","killTimeout","failureThreshold","successThreshold","timeout","halfOpenLimit","setupEventHandlers","process","on","gracefulShutdown","event","info","emit","initialize","startResourceMonitoring","shutdown","clearInterval","cancelPromises","Array","from","values","map","ctx","cancelTask","taskId","Promise","all","executeTask","task","agent","options","startTime","Date","now","retryCount","maxRetries","id","agentId","type","size","push","queueSize","length","waitForCapacity","result","executeSingleAttempt","executionTime","success","resourcesUsed","error","warn","attempt","taskError","message","stack","context","taskType","recoverable","retryable","getDefaultResourceUsage","backoffDelay","Math","min","pow","delay","Error","executionContext","resources","set","timeoutPromise","_","reject","setTimeout","circuitBreaker","getBreaker","executionPromise","execute","performTaskExecution","race","clearTimeout","delete","processQueuedTasks","command","buildExecutionCommand","debug","cmd","args","childProcess","stdio","env","TASK_ID","AGENT_ID","TASK_TYPE","stdout","stderr","data","toString","input","stdin","write","JSON","stringify","end","exitCode","resolve","code","taskResult","output","parse","artifacts","metadata","quality","completeness","accuracy","validated","TASK_TIMEOUT","constraints","timeoutAfter","MEMORY_LIMIT","CPU_LIMIT","reason","get","killed","kill","setInterval","updateResourceUsage","usage","getProcessResourceUsage","pid","lastUpdated","checkResourceLimits","random","network","limits","current","limit","check","shift","ms","exit","getRunningTasks","keys","getTaskContext","getQueuedTasks","getExecutorStats","totalCapacity","circuitBreakers","getAllMetrics","forceKillTask","updateConfig","newConfig"],"mappings":"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"}