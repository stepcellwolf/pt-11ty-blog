{"version":3,"sources":["../../../src/coordination/messaging.ts"],"sourcesContent":["/**\n * Inter-agent messaging system\n */\n\nimport { Message, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport type { CoordinationError } from '../utils/errors.js';\nimport { generateId, timeout as timeoutHelper } from '../utils/helpers.js';\n\ninterface MessageQueue {\n  messages: Message[];\n  handlers: Map<string, (message: Message) => void>;\n}\n\ninterface PendingResponse {\n  resolve: (response: unknown) => void;\n  reject: (error: Error) => void;\n  timeout: number;\n}\n\n/**\n * Message router for inter-agent communication\n */\nexport class MessageRouter {\n  private queues = new Map<string, MessageQueue>(); // agentId -> queue\n  private pendingResponses = new Map<string, PendingResponse>();\n  private messageCount = 0;\n\n  constructor(\n    private config: CoordinationConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing message router');\n\n    // Set up periodic cleanup\n    setInterval(() => this.cleanup(), 60000); // Every minute\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down message router');\n\n    // Reject all pending responses\n    for (const [id, pending] of this.pendingResponses) {\n      pending.reject(new Error('Message router shutdown'));\n      clearTimeout(pending.timeout);\n    }\n\n    this.queues.clear();\n    this.pendingResponses.clear();\n  }\n\n  async send(from: string, to: string, payload: unknown): Promise<void> {\n    const message: Message = {\n      id: generateId('msg'),\n      type: 'agent-message',\n      payload,\n      timestamp: new Date(),\n      priority: 0,\n    };\n\n    await this.sendMessage(from, to, message);\n  }\n\n  async sendWithResponse<T = unknown>(\n    from: string,\n    to: string,\n    payload: unknown,\n    timeoutMs?: number,\n  ): Promise<T> {\n    const message: Message = {\n      id: generateId('msg'),\n      type: 'agent-request',\n      payload,\n      timestamp: new Date(),\n      priority: 1,\n    };\n\n    // Create response promise\n    const responsePromise = new Promise<T>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingResponses.delete(message.id);\n        reject(new Error(`Message response timeout: ${message.id}`));\n      }, timeoutMs || this.config.messageTimeout);\n\n      this.pendingResponses.set(message.id, {\n        resolve: resolve as (response: unknown) => void,\n        reject,\n        timeout: timeout as unknown as number,\n      });\n    });\n\n    // Send message\n    await this.sendMessage(from, to, message);\n\n    // Wait for response\n    return await responsePromise;\n  }\n\n  async broadcast(from: string, payload: unknown): Promise<void> {\n    const message: Message = {\n      id: generateId('broadcast'),\n      type: 'broadcast',\n      payload,\n      timestamp: new Date(),\n      priority: 0,\n    };\n\n    // Send to all agents\n    const agents = Array.from(this.queues.keys()).filter((id) => id !== from);\n\n    await Promise.all(agents.map((to) => this.sendMessage(from, to, message)));\n  }\n\n  subscribe(agentId: string, handler: (message: Message) => void): void {\n    const queue = this.ensureQueue(agentId);\n    queue.handlers.set(generateId('handler'), handler);\n  }\n\n  unsubscribe(agentId: string, handlerId: string): void {\n    const queue = this.queues.get(agentId);\n    if (queue) {\n      queue.handlers.delete(handlerId);\n    }\n  }\n\n  async sendResponse(originalMessageId: string, response: unknown): Promise<void> {\n    const pending = this.pendingResponses.get(originalMessageId);\n    if (!pending) {\n      this.logger.warn('No pending response found', { messageId: originalMessageId });\n      return;\n    }\n\n    clearTimeout(pending.timeout);\n    this.pendingResponses.delete(originalMessageId);\n    pending.resolve(response);\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    const totalQueues = this.queues.size;\n    let totalMessages = 0;\n    let totalHandlers = 0;\n\n    for (const queue of this.queues.values()) {\n      totalMessages += queue.messages.length;\n      totalHandlers += queue.handlers.size;\n    }\n\n    return {\n      healthy: true,\n      metrics: {\n        activeQueues: totalQueues,\n        pendingMessages: totalMessages,\n        registeredHandlers: totalHandlers,\n        pendingResponses: this.pendingResponses.size,\n        totalMessagesSent: this.messageCount,\n      },\n    };\n  }\n\n  private async sendMessage(from: string, to: string, message: Message): Promise<void> {\n    this.logger.debug('Sending message', {\n      from,\n      to,\n      messageId: message.id,\n      type: message.type,\n    });\n\n    // Ensure destination queue exists\n    const queue = this.ensureQueue(to);\n\n    // Add to queue\n    queue.messages.push(message);\n    this.messageCount++;\n\n    // Emit event\n    this.eventBus.emit(SystemEvents.MESSAGE_SENT, { from, to, message });\n\n    // Process message immediately if handlers exist\n    if (queue.handlers.size > 0) {\n      await this.processMessage(to, message);\n    }\n  }\n\n  private async processMessage(agentId: string, message: Message): Promise<void> {\n    const queue = this.queues.get(agentId);\n    if (!queue) {\n      return;\n    }\n\n    // Remove message from queue\n    const index = queue.messages.indexOf(message);\n    if (index !== -1) {\n      queue.messages.splice(index, 1);\n    }\n\n    // Call all handlers\n    const handlers = Array.from(queue.handlers.values());\n    await Promise.all(\n      handlers.map((handler) => {\n        try {\n          handler(message);\n        } catch (error) {\n          this.logger.error('Message handler error', {\n            agentId,\n            messageId: message.id,\n            error,\n          });\n        }\n      }),\n    );\n\n    // Emit received event\n    this.eventBus.emit(SystemEvents.MESSAGE_RECEIVED, {\n      from: '', // Would need to track this\n      to: agentId,\n      message,\n    });\n  }\n\n  private ensureQueue(agentId: string): MessageQueue {\n    if (!this.queues.has(agentId)) {\n      this.queues.set(agentId, {\n        messages: [],\n        handlers: new Map(),\n      });\n    }\n    return this.queues.get(agentId)!;\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing message router maintenance');\n    this.cleanup();\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n\n    // Clean up old messages\n    for (const [agentId, queue] of this.queues) {\n      const filtered = queue.messages.filter((msg) => {\n        const age = now - msg.timestamp.getTime();\n        const maxAge = msg.expiry\n          ? msg.expiry.getTime() - msg.timestamp.getTime()\n          : this.config.messageTimeout;\n\n        if (age > maxAge) {\n          this.logger.warn('Dropping expired message', {\n            agentId,\n            messageId: msg.id,\n            age,\n          });\n          return false;\n        }\n        return true;\n      });\n\n      queue.messages = filtered;\n\n      // Remove empty queues\n      if (queue.messages.length === 0 && queue.handlers.size === 0) {\n        this.queues.delete(agentId);\n      }\n    }\n\n    // Clean up timed out responses\n    for (const [id, pending] of this.pendingResponses) {\n      // This is handled by the timeout, but double-check\n      clearTimeout(pending.timeout);\n      pending.reject(new Error('Response timeout during cleanup'));\n    }\n    this.pendingResponses.clear();\n  }\n}\n"],"names":["SystemEvents","generateId","MessageRouter","queues","Map","pendingResponses","messageCount","config","eventBus","logger","initialize","info","setInterval","cleanup","shutdown","id","pending","reject","Error","clearTimeout","timeout","clear","send","from","to","payload","message","type","timestamp","Date","priority","sendMessage","sendWithResponse","timeoutMs","responsePromise","Promise","resolve","setTimeout","delete","messageTimeout","set","broadcast","agents","Array","keys","filter","all","map","subscribe","agentId","handler","queue","ensureQueue","handlers","unsubscribe","handlerId","get","sendResponse","originalMessageId","response","warn","messageId","getHealthStatus","totalQueues","size","totalMessages","totalHandlers","values","messages","length","healthy","metrics","activeQueues","pendingMessages","registeredHandlers","totalMessagesSent","debug","push","emit","MESSAGE_SENT","processMessage","index","indexOf","splice","error","MESSAGE_RECEIVED","has","performMaintenance","now","filtered","msg","age","getTime","maxAge","expiry"],"mappings":"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"}