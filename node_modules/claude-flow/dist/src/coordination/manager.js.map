{"version":3,"sources":["../../../src/coordination/manager.ts"],"sourcesContent":["/**\n * Coordination manager for task scheduling and resource management\n */\n\nimport { Task, CoordinationConfig, SystemEvents } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { CoordinationError, DeadlockError } from '../utils/errors.js';\nimport { TaskScheduler } from './scheduler.js';\nimport { ResourceManager } from './resources.js';\nimport { MessageRouter } from './messaging.js';\nimport { AdvancedTaskScheduler } from './advanced-scheduler.js';\nimport { ConflictResolver } from './conflict-resolution.js';\nimport { CoordinationMetricsCollector } from './metrics.js';\n\nexport interface ICoordinationManager {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  assignTask(task: Task, agentId: string): Promise<void>;\n  getAgentTaskCount(agentId: string): Promise<number>;\n  getAgentTasks(agentId: string): Promise<Task[]>;\n  cancelTask(taskId: string, reason?: string): Promise<void>;\n  acquireResource(resourceId: string, agentId: string): Promise<void>;\n  releaseResource(resourceId: string, agentId: string): Promise<void>;\n  sendMessage(from: string, to: string, message: unknown): Promise<void>;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  performMaintenance(): Promise<void>;\n  getCoordinationMetrics(): Promise<Record<string, unknown>>;\n  enableAdvancedScheduling(): void;\n  reportConflict(type: 'resource' | 'task', id: string, agents: string[]): Promise<void>;\n}\n\n/**\n * Coordination manager implementation\n */\nexport class CoordinationManager implements ICoordinationManager {\n  private scheduler: TaskScheduler;\n  private resourceManager: ResourceManager;\n  private messageRouter: MessageRouter;\n  private conflictResolver: ConflictResolver;\n  private metricsCollector: CoordinationMetricsCollector;\n  private initialized = false;\n  private deadlockCheckInterval?: ReturnType<typeof setInterval>;\n  private advancedSchedulingEnabled = false;\n\n  constructor(\n    private config: CoordinationConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    this.scheduler = new TaskScheduler(config, eventBus, logger);\n    this.resourceManager = new ResourceManager(config, eventBus, logger);\n    this.messageRouter = new MessageRouter(config, eventBus, logger);\n    this.conflictResolver = new ConflictResolver(logger, eventBus);\n    this.metricsCollector = new CoordinationMetricsCollector(logger, eventBus);\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    this.logger.info('Initializing coordination manager...');\n\n    try {\n      // Initialize components\n      await this.scheduler.initialize();\n      await this.resourceManager.initialize();\n      await this.messageRouter.initialize();\n\n      // Start metrics collection\n      this.metricsCollector.start();\n\n      // Start deadlock detection if enabled\n      if (this.config.deadlockDetection) {\n        this.startDeadlockDetection();\n      }\n\n      // Set up event handlers\n      this.setupEventHandlers();\n\n      this.initialized = true;\n      this.logger.info('Coordination manager initialized');\n    } catch (error) {\n      this.logger.error('Failed to initialize coordination manager', error);\n      throw new CoordinationError('Coordination manager initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down coordination manager...');\n\n    try {\n      // Stop deadlock detection\n      if (this.deadlockCheckInterval) {\n        clearInterval(this.deadlockCheckInterval);\n      }\n\n      // Stop metrics collection\n      this.metricsCollector.stop();\n\n      // Shutdown components\n      await Promise.all([\n        this.scheduler.shutdown(),\n        this.resourceManager.shutdown(),\n        this.messageRouter.shutdown(),\n      ]);\n\n      this.initialized = false;\n      this.logger.info('Coordination manager shutdown complete');\n    } catch (error) {\n      this.logger.error('Error during coordination manager shutdown', error);\n      throw error;\n    }\n  }\n\n  async assignTask(task: Task, agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.scheduler.assignTask(task, agentId);\n  }\n\n  async getAgentTaskCount(agentId: string): Promise<number> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    return this.scheduler.getAgentTaskCount(agentId);\n  }\n\n  async acquireResource(resourceId: string, agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.resourceManager.acquire(resourceId, agentId);\n  }\n\n  async releaseResource(resourceId: string, agentId: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.resourceManager.release(resourceId, agentId);\n  }\n\n  async sendMessage(from: string, to: string, message: unknown): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.messageRouter.send(from, to, message);\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const [schedulerHealth, resourceHealth, messageHealth] = await Promise.all([\n        this.scheduler.getHealthStatus(),\n        this.resourceManager.getHealthStatus(),\n        this.messageRouter.getHealthStatus(),\n      ]);\n\n      const metrics = {\n        ...schedulerHealth.metrics,\n        ...resourceHealth.metrics,\n        ...messageHealth.metrics,\n      };\n\n      const healthy = schedulerHealth.healthy && resourceHealth.healthy && messageHealth.healthy;\n\n      const errors = [schedulerHealth.error, resourceHealth.error, messageHealth.error].filter(\n        Boolean,\n      );\n\n      const status: { healthy: boolean; error?: string; metrics?: Record<string, number> } = {\n        healthy,\n        metrics,\n      };\n      if (errors.length > 0) {\n        status.error = errors.join('; ');\n      }\n      return status;\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Handle task events\n    this.eventBus.on(SystemEvents.TASK_COMPLETED, async (data: unknown) => {\n      const { taskId, result } = data as { taskId: string; result: unknown };\n      try {\n        await this.scheduler.completeTask(taskId, result);\n      } catch (error) {\n        this.logger.error('Error handling task completion', { taskId, error });\n      }\n    });\n\n    this.eventBus.on(SystemEvents.TASK_FAILED, async (data: unknown) => {\n      const { taskId, error } = data as { taskId: string; error: Error };\n      try {\n        await this.scheduler.failTask(taskId, error);\n      } catch (err) {\n        this.logger.error('Error handling task failure', { taskId, error: err });\n      }\n    });\n\n    // Handle agent termination\n    this.eventBus.on(SystemEvents.AGENT_TERMINATED, async (data: unknown) => {\n      const { agentId } = data as { agentId: string };\n      try {\n        // Release all resources held by the agent\n        await this.resourceManager.releaseAllForAgent(agentId);\n\n        // Cancel all tasks assigned to the agent\n        await this.scheduler.cancelAgentTasks(agentId);\n      } catch (error) {\n        this.logger.error('Error handling agent termination', { agentId, error });\n      }\n    });\n  }\n\n  private startDeadlockDetection(): void {\n    this.deadlockCheckInterval = setInterval(async () => {\n      try {\n        const deadlock = await this.detectDeadlock();\n\n        if (deadlock) {\n          this.logger.error('Deadlock detected', deadlock);\n\n          // Emit deadlock event\n          this.eventBus.emit(SystemEvents.DEADLOCK_DETECTED, deadlock);\n\n          // Attempt to resolve deadlock\n          await this.resolveDeadlock(deadlock);\n        }\n      } catch (error) {\n        this.logger.error('Error during deadlock detection', error);\n      }\n    }, 10000); // Check every 10 seconds\n  }\n\n  private async detectDeadlock(): Promise<{\n    agents: string[];\n    resources: string[];\n  } | null> {\n    // Get resource allocation graph\n    const allocations = await this.resourceManager.getAllocations();\n    const waitingFor = await this.resourceManager.getWaitingRequests();\n\n    // Build dependency graph\n    const graph = new Map<string, Set<string>>();\n\n    // Add edges for resources agents are waiting for\n    for (const [agentId, resources] of waitingFor) {\n      if (!graph.has(agentId)) {\n        graph.set(agentId, new Set());\n      }\n\n      // Find who owns these resources\n      for (const resource of resources) {\n        const owner = allocations.get(resource);\n        if (owner && owner !== agentId) {\n          graph.get(agentId)!.add(owner);\n        }\n      }\n    }\n\n    // Detect cycles using DFS\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const cycle: string[] = [];\n\n    const hasCycle = (node: string): boolean => {\n      visited.add(node);\n      recursionStack.add(node);\n\n      const neighbors = graph.get(node) || new Set();\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          if (hasCycle(neighbor)) {\n            cycle.unshift(node);\n            return true;\n          }\n        } else if (recursionStack.has(neighbor)) {\n          cycle.unshift(node);\n          cycle.unshift(neighbor);\n          return true;\n        }\n      }\n\n      recursionStack.delete(node);\n      return false;\n    };\n\n    // Check for cycles\n    for (const node of graph.keys()) {\n      if (!visited.has(node) && hasCycle(node)) {\n        // Extract unique agents in cycle\n        const agents = Array.from(new Set(cycle));\n\n        // Find resources involved\n        const resources: string[] = [];\n        for (const agent of agents) {\n          const waiting = waitingFor.get(agent) || [];\n          resources.push(...waiting);\n        }\n\n        return {\n          agents,\n          resources: Array.from(new Set(resources)),\n        };\n      }\n    }\n\n    return null;\n  }\n\n  private async resolveDeadlock(deadlock: {\n    agents: string[];\n    resources: string[];\n  }): Promise<void> {\n    this.logger.warn('Attempting to resolve deadlock', deadlock);\n\n    // Simple resolution: release resources from the lowest priority agent\n    // In a real implementation, use more sophisticated strategies\n\n    try {\n      // Find the agent with the lowest priority or least work done\n      const agentToPreempt = deadlock.agents[0]; // Simplified\n\n      // Release all resources held by this agent\n      await this.resourceManager.releaseAllForAgent(agentToPreempt);\n\n      // Reschedule the agent's tasks\n      await this.scheduler.rescheduleAgentTasks(agentToPreempt);\n\n      this.logger.info('Deadlock resolved by preempting agent', {\n        agentId: agentToPreempt,\n      });\n    } catch (error) {\n      throw new DeadlockError('Failed to resolve deadlock', deadlock.agents, deadlock.resources);\n    }\n  }\n\n  async getAgentTasks(agentId: string): Promise<Task[]> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    return this.scheduler.getAgentTasks(agentId);\n  }\n\n  async cancelTask(taskId: string, reason?: string): Promise<void> {\n    if (!this.initialized) {\n      throw new CoordinationError('Coordination manager not initialized');\n    }\n\n    await this.scheduler.cancelTask(taskId, reason || 'User requested cancellation');\n  }\n\n  async performMaintenance(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.debug('Performing coordination manager maintenance');\n\n    try {\n      await Promise.all([\n        this.scheduler.performMaintenance(),\n        this.resourceManager.performMaintenance(),\n        this.messageRouter.performMaintenance(),\n      ]);\n\n      // Clean up old conflicts\n      this.conflictResolver.cleanupOldConflicts(24 * 60 * 60 * 1000); // 24 hours\n    } catch (error) {\n      this.logger.error('Error during coordination manager maintenance', error);\n    }\n  }\n\n  async getCoordinationMetrics(): Promise<Record<string, unknown>> {\n    const baseMetrics = await this.getHealthStatus();\n    const coordinationMetrics = this.metricsCollector.getCurrentMetrics();\n    const conflictStats = this.conflictResolver.getStats();\n\n    return {\n      ...baseMetrics.metrics,\n      coordination: coordinationMetrics,\n      conflicts: conflictStats,\n      advancedScheduling: this.advancedSchedulingEnabled,\n    };\n  }\n\n  enableAdvancedScheduling(): void {\n    if (this.advancedSchedulingEnabled) {\n      return;\n    }\n\n    this.logger.info('Enabling advanced scheduling features');\n\n    // Replace basic scheduler with advanced one\n    const advancedScheduler = new AdvancedTaskScheduler(this.config, this.eventBus, this.logger);\n\n    // Transfer state if needed (in a real implementation)\n    this.scheduler = advancedScheduler;\n    this.advancedSchedulingEnabled = true;\n  }\n\n  async reportConflict(type: 'resource' | 'task', id: string, agents: string[]): Promise<void> {\n    this.logger.warn('Conflict reported', { type, id, agents });\n\n    let conflict;\n    if (type === 'resource') {\n      conflict = await this.conflictResolver.reportResourceConflict(id, agents);\n    } else {\n      conflict = await this.conflictResolver.reportTaskConflict(id, agents, 'assignment');\n    }\n\n    // Auto-resolve using default strategy\n    try {\n      await this.conflictResolver.autoResolve(conflict.id);\n    } catch (error) {\n      this.logger.error('Failed to auto-resolve conflict', {\n        conflictId: conflict.id,\n        error,\n      });\n    }\n  }\n}\n"],"names":["SystemEvents","CoordinationError","DeadlockError","TaskScheduler","ResourceManager","MessageRouter","AdvancedTaskScheduler","ConflictResolver","CoordinationMetricsCollector","CoordinationManager","scheduler","resourceManager","messageRouter","conflictResolver","metricsCollector","initialized","deadlockCheckInterval","advancedSchedulingEnabled","config","eventBus","logger","initialize","info","start","deadlockDetection","startDeadlockDetection","setupEventHandlers","error","shutdown","clearInterval","stop","Promise","all","assignTask","task","agentId","getAgentTaskCount","acquireResource","resourceId","acquire","releaseResource","release","sendMessage","from","to","message","send","getHealthStatus","schedulerHealth","resourceHealth","messageHealth","metrics","healthy","errors","filter","Boolean","status","length","join","Error","on","TASK_COMPLETED","data","taskId","result","completeTask","TASK_FAILED","failTask","err","AGENT_TERMINATED","releaseAllForAgent","cancelAgentTasks","setInterval","deadlock","detectDeadlock","emit","DEADLOCK_DETECTED","resolveDeadlock","allocations","getAllocations","waitingFor","getWaitingRequests","graph","Map","resources","has","set","Set","resource","owner","get","add","visited","recursionStack","cycle","hasCycle","node","neighbors","neighbor","unshift","delete","keys","agents","Array","agent","waiting","push","warn","agentToPreempt","rescheduleAgentTasks","getAgentTasks","cancelTask","reason","performMaintenance","debug","cleanupOldConflicts","getCoordinationMetrics","baseMetrics","coordinationMetrics","getCurrentMetrics","conflictStats","getStats","coordination","conflicts","advancedScheduling","enableAdvancedScheduling","advancedScheduler","reportConflict","type","id","conflict","reportResourceConflict","reportTaskConflict","autoResolve","conflictId"],"mappings":"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"}