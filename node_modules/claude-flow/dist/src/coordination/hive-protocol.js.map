{"version":3,"sources":["../../../src/coordination/hive-protocol.ts"],"sourcesContent":["/**\n * Hive Mind Communication Protocol\n * Defines how agents communicate, vote, and share knowledge\n */\n\nimport { EventEmitter } from 'events';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface HiveMessage {\n  id: string;\n  from: string;\n  to: string | 'broadcast';\n  type: HiveMessageType;\n  payload: any;\n  timestamp: number;\n  priority: 'urgent' | 'high' | 'normal' | 'low';\n  requiresResponse?: boolean;\n  inReplyTo?: string;\n}\n\nexport type HiveMessageType =\n  | 'task_proposal'\n  | 'vote_request'\n  | 'vote_response'\n  | 'status_update'\n  | 'knowledge_share'\n  | 'help_request'\n  | 'consensus_check'\n  | 'quality_report'\n  | 'coordination_sync';\n\nexport interface HiveChannel {\n  id: string;\n  name: string;\n  type: 'broadcast' | 'consensus' | 'coordination' | 'knowledge';\n  members: Set<string>;\n  messages: HiveMessage[];\n}\n\nexport class HiveCommunicationProtocol extends EventEmitter {\n  private channels: Map<string, HiveChannel> = new Map();\n  private messageQueue: Map<string, HiveMessage[]> = new Map();\n  private knowledgeBase: Map<string, any> = new Map();\n  private consensusThreshold: number;\n\n  constructor(options: { consensusThreshold?: number } = {}) {\n    super();\n    this.consensusThreshold = options.consensusThreshold || 0.6;\n    this.initializeChannels();\n  }\n\n  /**\n   * Initialize default communication channels\n   */\n  private initializeChannels() {\n    // Broadcast channel for all agents\n    this.createChannel('broadcast', 'broadcast', 'General announcements and updates');\n\n    // Consensus channel for voting\n    this.createChannel('consensus', 'consensus', 'Voting and decision making');\n\n    // Coordination channel for task management\n    this.createChannel('coordination', 'coordination', 'Task assignment and progress');\n\n    // Knowledge channel for sharing insights\n    this.createChannel('knowledge', 'knowledge', 'Knowledge sharing and learning');\n  }\n\n  /**\n   * Create a new communication channel\n   */\n  createChannel(name: string, type: HiveChannel['type'], description: string): HiveChannel {\n    const channel: HiveChannel = {\n      id: generateId('channel'),\n      name,\n      type,\n      members: new Set(),\n      messages: [],\n    };\n\n    this.channels.set(channel.id, channel);\n    this.emit('channel:created', { channel, description });\n\n    return channel;\n  }\n\n  /**\n   * Join an agent to a channel\n   */\n  joinChannel(channelId: string, agentId: string) {\n    const channel = this.channels.get(channelId);\n    if (!channel) throw new Error(`Channel ${channelId} not found`);\n\n    channel.members.add(agentId);\n    this.emit('channel:joined', { channelId, agentId });\n  }\n\n  /**\n   * Send a message through the protocol\n   */\n  sendMessage(message: Omit<HiveMessage, 'id' | 'timestamp'>): HiveMessage {\n    const fullMessage: HiveMessage = {\n      ...message,\n      id: generateId('msg'),\n      timestamp: Date.now(),\n    };\n\n    // Route message based on type\n    this.routeMessage(fullMessage);\n\n    // Store in appropriate channel\n    const channelType = this.getChannelTypeForMessage(fullMessage.type);\n    const channel = Array.from(this.channels.values()).find((c) => c.type === channelType);\n    if (channel) {\n      channel.messages.push(fullMessage);\n    }\n\n    // Queue for recipient(s)\n    if (fullMessage.to === 'broadcast') {\n      // Queue for all agents\n      for (const channel of this.channels.values()) {\n        for (const member of channel.members) {\n          this.queueMessage(member, fullMessage);\n        }\n      }\n    } else {\n      // Queue for specific recipient\n      this.queueMessage(fullMessage.to, fullMessage);\n    }\n\n    this.emit('message:sent', fullMessage);\n\n    return fullMessage;\n  }\n\n  /**\n   * Route message based on type\n   */\n  private routeMessage(message: HiveMessage) {\n    switch (message.type) {\n      case 'vote_request':\n        this.handleVoteRequest(message);\n        break;\n      case 'knowledge_share':\n        this.handleKnowledgeShare(message);\n        break;\n      case 'consensus_check':\n        this.handleConsensusCheck(message);\n        break;\n      case 'quality_report':\n        this.handleQualityReport(message);\n        break;\n    }\n  }\n\n  /**\n   * Get channel type for message type\n   */\n  private getChannelTypeForMessage(messageType: HiveMessageType): HiveChannel['type'] {\n    switch (messageType) {\n      case 'vote_request':\n      case 'vote_response':\n      case 'consensus_check':\n        return 'consensus';\n      case 'task_proposal':\n      case 'status_update':\n      case 'coordination_sync':\n        return 'coordination';\n      case 'knowledge_share':\n        return 'knowledge';\n      default:\n        return 'broadcast';\n    }\n  }\n\n  /**\n   * Queue message for agent\n   */\n  private queueMessage(agentId: string, message: HiveMessage) {\n    if (!this.messageQueue.has(agentId)) {\n      this.messageQueue.set(agentId, []);\n    }\n    this.messageQueue.get(agentId)!.push(message);\n  }\n\n  /**\n   * Retrieve messages for agent\n   */\n  getMessages(agentId: string): HiveMessage[] {\n    const messages = this.messageQueue.get(agentId) || [];\n    this.messageQueue.set(agentId, []); // Clear after retrieval\n    return messages;\n  }\n\n  /**\n   * Handle vote request\n   */\n  private handleVoteRequest(message: HiveMessage) {\n    const { proposal, deadline } = message.payload;\n\n    this.emit('vote:requested', {\n      messageId: message.id,\n      proposal,\n      deadline,\n      from: message.from,\n    });\n\n    // Set timeout for vote collection\n    if (deadline) {\n      setTimeout(() => {\n        this.collectVotes(message.id);\n      }, deadline - Date.now());\n    }\n  }\n\n  /**\n   * Submit a vote response\n   */\n  submitVote(requestId: string, agentId: string, vote: boolean, confidence: number = 1.0) {\n    const voteMessage = this.sendMessage({\n      from: agentId,\n      to: 'consensus',\n      type: 'vote_response',\n      payload: {\n        requestId,\n        vote,\n        confidence,\n        reasoning: this.generateVoteReasoning(vote, confidence),\n      },\n      priority: 'high',\n    });\n\n    this.emit('vote:submitted', {\n      requestId,\n      agentId,\n      vote,\n      confidence,\n    });\n\n    return voteMessage;\n  }\n\n  /**\n   * Generate reasoning for vote\n   */\n  private generateVoteReasoning(vote: boolean, confidence: number): string {\n    if (vote && confidence > 0.8) {\n      return 'Strong alignment with objectives and capabilities';\n    } else if (vote && confidence > 0.5) {\n      return 'Moderate alignment, some concerns but manageable';\n    } else if (!vote && confidence > 0.8) {\n      return 'Significant concerns or misalignment detected';\n    } else {\n      return 'Insufficient information or capability mismatch';\n    }\n  }\n\n  /**\n   * Collect and evaluate votes\n   */\n  private collectVotes(requestId: string) {\n    const votes = new Map<string, { vote: boolean; confidence: number }>();\n\n    // Collect all vote responses for this request\n    for (const channel of this.channels.values()) {\n      for (const message of channel.messages) {\n        if (message.type === 'vote_response' && message.payload.requestId === requestId) {\n          votes.set(message.from, {\n            vote: message.payload.vote,\n            confidence: message.payload.confidence,\n          });\n        }\n      }\n    }\n\n    // Calculate consensus\n    const consensus = this.calculateConsensus(votes);\n\n    this.emit('consensus:reached', {\n      requestId,\n      consensus,\n      votes: Array.from(votes.entries()),\n    });\n  }\n\n  /**\n   * Calculate consensus from votes\n   */\n  private calculateConsensus(votes: Map<string, { vote: boolean; confidence: number }>): {\n    approved: boolean;\n    confidence: number;\n  } {\n    if (votes.size === 0) {\n      return { approved: false, confidence: 0 };\n    }\n\n    let totalWeight = 0;\n    let approvalWeight = 0;\n\n    for (const [_, { vote, confidence }] of votes) {\n      totalWeight += confidence;\n      if (vote) {\n        approvalWeight += confidence;\n      }\n    }\n\n    const approvalRate = approvalWeight / totalWeight;\n    const approved = approvalRate >= this.consensusThreshold;\n\n    return { approved, confidence: approvalRate };\n  }\n\n  /**\n   * Handle knowledge sharing\n   */\n  private handleKnowledgeShare(message: HiveMessage) {\n    const { key, value, metadata } = message.payload;\n\n    // Store in knowledge base\n    this.knowledgeBase.set(key, {\n      value,\n      metadata,\n      contributor: message.from,\n      timestamp: message.timestamp,\n    });\n\n    this.emit('knowledge:shared', {\n      key,\n      contributor: message.from,\n      timestamp: message.timestamp,\n    });\n  }\n\n  /**\n   * Query knowledge base\n   */\n  queryKnowledge(pattern: string): any[] {\n    const results = [];\n\n    for (const [key, data] of this.knowledgeBase) {\n      if (key.includes(pattern)) {\n        results.push({ key, ...data });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Handle consensus check\n   */\n  private handleConsensusCheck(message: HiveMessage) {\n    const { topic, options } = message.payload;\n\n    // Initiate voting round\n    const voteRequest = this.sendMessage({\n      from: 'consensus-system',\n      to: 'broadcast',\n      type: 'vote_request',\n      payload: {\n        topic,\n        options,\n        deadline: Date.now() + 30000, // 30 second deadline\n      },\n      priority: 'urgent',\n      requiresResponse: true,\n    });\n\n    this.emit('consensus:initiated', {\n      topic,\n      options,\n      requestId: voteRequest.id,\n    });\n  }\n\n  /**\n   * Handle quality report\n   */\n  private handleQualityReport(message: HiveMessage) {\n    const { taskId, metrics, issues } = message.payload;\n\n    // Store quality metrics\n    this.knowledgeBase.set(`quality/${taskId}`, {\n      metrics,\n      issues,\n      reporter: message.from,\n      timestamp: message.timestamp,\n    });\n\n    // Check if quality threshold breached\n    if (metrics.score < 0.7) {\n      this.emit('quality:alert', {\n        taskId,\n        score: metrics.score,\n        issues,\n        reporter: message.from,\n      });\n    }\n  }\n\n  /**\n   * Get communication statistics\n   */\n  getStatistics() {\n    const stats = {\n      totalMessages: 0,\n      messagesByType: new Map<HiveMessageType, number>(),\n      messagesByPriority: new Map<string, number>(),\n      activeChannels: this.channels.size,\n      knowledgeEntries: this.knowledgeBase.size,\n      avgResponseTime: 0,\n    };\n\n    // Aggregate message statistics\n    for (const channel of this.channels.values()) {\n      stats.totalMessages += channel.messages.length;\n\n      for (const message of channel.messages) {\n        const typeCount = stats.messagesByType.get(message.type) || 0;\n        stats.messagesByType.set(message.type, typeCount + 1);\n\n        const priorityCount = stats.messagesByPriority.get(message.priority) || 0;\n        stats.messagesByPriority.set(message.priority, priorityCount + 1);\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Export communication log\n   */\n  exportLog(): any {\n    const log = {\n      channels: Array.from(this.channels.values()).map((channel) => ({\n        id: channel.id,\n        name: channel.name,\n        type: channel.type,\n        memberCount: channel.members.size,\n        messageCount: channel.messages.length,\n      })),\n      messages: [],\n      knowledge: Array.from(this.knowledgeBase.entries()).map(([key, value]) => ({\n        key,\n        ...value,\n      })),\n    };\n\n    // Collect all messages\n    for (const channel of this.channels.values()) {\n      log.messages.push(...channel.messages);\n    }\n\n    // Sort by timestamp\n    log.messages.sort((a, b) => a.timestamp - b.timestamp);\n\n    return log;\n  }\n}\n"],"names":["EventEmitter","generateId","HiveCommunicationProtocol","channels","Map","messageQueue","knowledgeBase","consensusThreshold","options","initializeChannels","createChannel","name","type","description","channel","id","members","Set","messages","set","emit","joinChannel","channelId","agentId","get","Error","add","sendMessage","message","fullMessage","timestamp","Date","now","routeMessage","channelType","getChannelTypeForMessage","Array","from","values","find","c","push","to","member","queueMessage","handleVoteRequest","handleKnowledgeShare","handleConsensusCheck","handleQualityReport","messageType","has","getMessages","proposal","deadline","payload","messageId","setTimeout","collectVotes","submitVote","requestId","vote","confidence","voteMessage","reasoning","generateVoteReasoning","priority","votes","consensus","calculateConsensus","entries","size","approved","totalWeight","approvalWeight","_","approvalRate","key","value","metadata","contributor","queryKnowledge","pattern","results","data","includes","topic","voteRequest","requiresResponse","taskId","metrics","issues","reporter","score","getStatistics","stats","totalMessages","messagesByType","messagesByPriority","activeChannels","knowledgeEntries","avgResponseTime","length","typeCount","priorityCount","exportLog","log","map","memberCount","messageCount","knowledge","sort","a","b"],"mappings":"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"}